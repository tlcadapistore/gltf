async function deploymodel(app){
	let reader = new FileReader();
	let models = new DataTransfer();
	let response = await fetch('http://127.0.0.1:8080/bolt.zip');
	let data = await response.blob();
	let metadata = {
		type: 'application/zip'
	};
	let file = new File([data], "bolt.zip", metadata);
	
	models.items.add(file);
	console.log(models);
	app.project.loadFiles(Array.from(models.files));
	return models;
}

(() => {
    "use strict";
    var a, l, L, D, s = {
            4522: (e, t, s) => {
                s = s(1533);
                t.s = s.createRoot, s.hydrateRoot
            },
            6650: (e, t, s) => {
                s.d(t, {
                    g: () => r
                });
                t = s(82);
                class r {}
                r.EPS_6 = 1e-6, r.EPS = r.EPS_6, r.VEC3_X_UNIT = t.R.fromValues(1, 0, 0), r.VEC3_Y_UNIT = t.R.fromValues(0, 1, 0), r.VEC3_Z_UNIT = t.R.fromValues(0, 0, 1), r.VEC3_LEFT = t.R.fromValues(-1, 0, 0), r.VEC3_RIGHT = t.R.fromValues(1, 0, 0), r.VEC3_UP = t.R.fromValues(0, 1, 0), r.VEC3_DOWN = t.R.fromValues(0, -1, 0), r.VEC3_FORWARD = t.R.fromValues(0, 0, 1), r.VEC3_BACK = t.R.fromValues(0, 0, -1)
            },
            6407: (e, t, s) => {
                s.d(t, {
                    M: () => r
                });
                class r {
                    static isPowerOfTwo(e) {
                        return 0 == (e & e - 1)
                    }
                    static nextHighestPowerOfTwo(t) {
                        --t;
                        for (let e = 1; e < 32; e <<= 1) t |= t >> e;
                        return t + 1
                    }
                    static previousHighestPowerOfTwo(e) {
                        var t;
                        return e < 1 ? 0 : (t = r.nextHighestPowerOfTwo(e)) === e ? t : t / 2
                    }
                    static previousMultiple(e, t) {
                        return Math.floor(e / t) * t
                    }
                    static nextMultiple(e, t) {
                        return Math.ceil(e / t) * t
                    }
                    static roundTo(e, t) {
                        return Math.round(e / t) * t
                    }
                    static findFirstNumber(...e) {
                        for (const t of e)
                            if (r.isValidNumber(t)) return t;
                        let t = e[e.length - 1];
                        return "number" != typeof t && (t = 0, console.warn("No valid number found in params, returning 0")), t
                    }
                    static isPositiveOrZero(e) {
                        return void 0 !== e && (0 < e || 0 === e)
                    }
                    static isPositive(e) {
                        return void 0 !== e && 0 < e
                    }
                    static isValidNumber(e) {
                        return null != e && !isNaN(e) && e !== 1 / 0 && e !== -1 / 0
                    }
                    static validate(e, t = 0) {
                        return isFinite(e) && "number" == typeof e ? e : t
                    }
                    static wrapPi(e) {
                        return Math.abs(e) > Math.PI && (e -= Math.floor((e + Math.PI) * (1 / r.TWO_PI)) * r.TWO_PI), e
                    }
                    static sign(e) {
                        return 0 == (e = +e) || isNaN(e) ? Number(e) : 0 < e ? 1 : -1
                    }
                    static copySign(e, t) {
                        return Math.abs(e) * this.sign(t)
                    }
                    static clamp(e, t, s) {
                        return void 0 !== t && e < t ? t : void 0 !== s && s < e ? s : e
                    }
                    static mod(e, t) {
                        return (e % t + t) % t
                    }
                    static sum(t, s) {
                        let r = 0;
                        for (let e = 0; e < t.length; ++e) r += s(t[e]);
                        return r
                    }
                    static max(e) {
                        return Math.max.apply(null, e)
                    }
                    static min(e) {
                        return Math.min.apply(null, e)
                    }
                    static avg(t) {
                        let s = 0;
                        for (let e = 0; e < t.length; ++e) s += t[e];
                        return s /= t.length
                    }
                    static setPrecision(e, t = 2) {
                        return t = Math.pow(10, t), Math.round(e * t) / t
                    }
                    static fitInto(e, t, s = []) {
                        return e[0] > t[0] || e[1] > t[1] ? this.scaleInto(e, t, s) : e
                    }
                    static scaleInto(e, t, s = []) {
                        e = e[0] / e[1];
                        return e > t[0] / t[1] ? (s[0] = t[0], s[1] = s[0] / e) : (s[1] = t[1], s[0] = s[1] * e), s
                    }
                    static fitAroundSize(e, t, s = []) {
                        e = e[0] / e[1];
                        return e > t[0] / t[1] ? (s[1] = t[1], s[0] = s[1] * e) : (s[0] = t[0], s[1] = s[0] / e), s
                    }
                    static equalsStrict(e, t, s = 0) {
                        return e.length === t.length && r.equals(e, t, s)
                    }
                    static equals(t, s, r = 0) {
                        var i = Math.min(t.length, s.length);
                        if (0 === r) {
                            for (let e = 0; e < i; ++e)
                                if (t[e] !== s[e]) return !1
                        } else
                            for (let e = 0; e < i; ++e)
                                if (Math.abs(t[e] - s[e]) >= r) return !1;
                        return !0
                    }
                    static lerp(t, s, r, i) {
                        for (let e = 0; e < s.length; ++e) t[e] = s[e] + i * (r[e] - s[e]);
                        return t
                    }
                }
                r.TWO_PI = 2 * Math.PI, r.PI_HALF = Math.PI / 2, r.DEG2RAD = Math.PI / 180, r.RAD2DEG = 180 / Math.PI
            },
            387: (e, t, s) => {
                s.d(t, {
                    x: () => i
                });
                var r = s(82);
                class i {
                    static union(e, t, s) {
                        return e.min[0] = Math.min(t.min[0], s.min[0]), e.min[1] = Math.min(t.min[1], s.min[1]), e.min[2] = Math.min(t.min[2], s.min[2]), e.max[0] = Math.max(t.max[0], s.max[0]), e.max[1] = Math.max(t.max[1], s.max[1]), e.max[2] = Math.max(t.max[2], s.max[2]), e
                    }
                    static transform(e, t) {
                        var s = r.R.transformMat4(r.R.create(), e.min, t),
                            e = r.R.transformMat4(r.R.create(), e.max, t),
                            t = r.R.min(r.R.create(), s, e),
                            s = r.R.max(r.R.create(), s, e);
                        return new i(t, s)
                    }
                    constructor(e = r.R.create(), t = r.R.create()) {
                        this.min = e, this.max = t
                    }
                    getCenter() {
                        var e = this.min,
                            t = this.max;
                        return [e[0] + (t[0] - e[0]) / 2, e[1] + (t[1] - e[1]) / 2, e[2] + (t[2] - e[2]) / 2]
                    }
                    getSize() {
                        return r.R.sub(r.R.create(), this.max, this.min)
                    }
                    clone() {
                        return new i(r.R.clone(this.min), r.R.clone(this.max))
                    }
                }
            },
            4233: (e, t, s) => {
                s.d(t, {
                    A: () => a
                });
                var i = s(889);
                class a {
                    static createFromEdges(e, t, s, r) {
                        t -= e, r -= s;
                        return new a(e + t / 2, s + r / 2, t, r)
                    }
                    static getUnion(e, t) {
                        var s = Math.max(e.left, t.left),
                            r = Math.min(e.right, t.right),
                            i = Math.max(e.bottom, t.bottom),
                            e = Math.min(e.top, t.top);
                        return s < r && i < e ? a.createFromEdges(s, r, i, e) : null
                    }
                    static getUnionRectangles(e, t) {
                        var s = a.getUnion(e, t);
                        return s ? {
                            result1: a.createFromEdges(s.left - e.left, s.right - e.left, s.bottom - e.bottom, s.top - e.bottom),
                            result2: a.createFromEdges(s.left - t.left, s.right - t.left, s.bottom - t.bottom, s.top - t.bottom)
                        } : null
                    }
                    constructor(e = 0, t = 0, s = 1, r = 1) {
                        this._x = 0, this._y = 0, this._width = 0, this._height = 0, this._x = e, this._y = t, this._width = s, this._height = r
                    }
                    getVertexByUV(e, t, s, r) {
                        s = s || i.K.create();
                        e = this.left + this._width * e, t = this.bottom + this._height * t;
                        return s[0] = e, s[1] = t, r && (r[0] = 0, r[1] = 0, r[2] = 1), s
                    }
                    copyFrom(e) {
                        this._x = e.x, this._y = e.y, this._width = e.width, this._height = e.height
                    }
                    setFromEdges(e, t, s, r) {
                        this._width = t - e, this._height = r - s, this._x = e + this._width / 2, this._y = s + this._height / 2
                    }
                    set x(e) {
                        this._x = e
                    }
                    get x() {
                        return this._x
                    }
                    set y(e) {
                        this._y = e
                    }
                    get y() {
                        return this._y
                    }
                    move(e, t) {
                        this._x += e, this._y += t
                    }
                    set width(e) {
                        this._width = e
                    }
                    get width() {
                        return this._width
                    }
                    set height(e) {
                        this._height = e
                    }
                    get height() {
                        return this._height
                    }
                    set left(e) {
                        var t = this.right;
                        this._x = (e + t) / 2, this._width = Math.abs(t - e)
                    }
                    get left() {
                        var e = this._width / 2;
                        return this._x - e
                    }
                    set right(e) {
                        var t = this.left;
                        this._x = (t + e) / 2, this._width = Math.abs(e - t)
                    }
                    get right() {
                        var e = this._width / 2;
                        return this._x + e
                    }
                    set bottom(e) {
                        var t = this.top;
                        this._y = (e + t) / 2, this._height = Math.abs(t - e)
                    }
                    get bottom() {
                        var e = this._height / 2;
                        return this._y - e
                    }
                    set top(e) {
                        var t = this.bottom;
                        this._y = (t + e) / 2, this._height = Math.abs(e - t)
                    }
                    get top() {
                        var e = this._height / 2;
                        return this._y + e
                    }
                    clone() {
                        return new a(this.x, this.y, this.width, this.height)
                    }
                }
            },
            3790: (e, t, s) => {
                s.d(t, {
                    w: () => c
                });
                var b = s(6650),
                    a = s(6407);
                class c {
                    static create() {
                        var e = new c.GLMAT_ARRAY_TYPE(9);
                        return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 1, e[5] = 0, e[6] = 0, e[7] = 0, e[8] = 1, e
                    }
                    static zero() {
                        return new c.GLMAT_ARRAY_TYPE(9)
                    }
                    static fromMat4(e, t) {
                        return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[4], e[4] = t[5], e[5] = t[6], e[6] = t[8], e[7] = t[9], e[8] = t[10], e
                    }
                    static clone(e) {
                        var t = new c.GLMAT_ARRAY_TYPE(9);
                        return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4], t[5] = e[5], t[6] = e[6], t[7] = e[7], t[8] = e[8], t
                    }
                    static fromValues(e, t, s, r, i, a, n, o, l) {
                        var h = new c.GLMAT_ARRAY_TYPE(9);
                        return h[0] = e, h[1] = t, h[2] = s, h[3] = r, h[4] = i, h[5] = a, h[6] = n, h[7] = o, h[8] = l, h
                    }
                    static set(e, t, s, r, i, a, n, o, l, h) {
                        return e[0] = t, e[1] = s, e[2] = r, e[3] = i, e[4] = a, e[5] = n, e[6] = o, e[7] = l, e[8] = h, e
                    }
                    static identity(e) {
                        return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 1, e[5] = 0, e[6] = 0, e[7] = 0, e[8] = 1, e
                    }
                    static transpose(e, t) {
                        var s, r, i;
                        return e === t ? (s = t[1], r = t[2], i = t[5], e[1] = t[3], e[2] = t[6], e[3] = s, e[5] = t[7], e[6] = r, e[7] = i) : (e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8]), e
                    }
                    static invert(e, t) {
                        var s = t[0],
                            r = t[1],
                            i = t[2],
                            a = t[3],
                            n = t[4],
                            o = t[5],
                            l = t[6],
                            h = t[7],
                            t = t[8],
                            c = t * n - o * h,
                            d = -t * a + o * l,
                            u = h * a - n * l,
                            p = s * c + r * d + i * u;
                        return p ? (e[0] = c * (p = 1 / p), e[1] = (-t * r + i * h) * p, e[2] = (o * r - i * n) * p, e[3] = d * p, e[4] = (t * s - i * l) * p, e[5] = (-o * s + i * a) * p, e[6] = u * p, e[7] = (-h * s + r * l) * p, e[8] = (n * s - r * a) * p, e) : null
                    }
                    static adjoint(e, t) {
                        var s = t[0],
                            r = t[1],
                            i = t[2],
                            a = t[3],
                            n = t[4],
                            o = t[5],
                            l = t[6],
                            h = t[7],
                            t = t[8];
                        return e[0] = n * t - o * h, e[1] = i * h - r * t, e[2] = r * o - i * n, e[3] = o * l - a * t, e[4] = s * t - i * l, e[5] = i * a - s * o, e[6] = a * h - n * l, e[7] = r * l - s * h, e[8] = s * n - r * a, e
                    }
                    static determinant(e) {
                        var t = e[0],
                            s = e[1],
                            r = e[2],
                            i = e[3],
                            a = e[4],
                            n = e[5],
                            o = e[6],
                            l = e[7],
                            e = e[8];
                        return t * (e * a - n * l) + s * (-e * i + n * o) + r * (l * i - a * o)
                    }
                    static multiply(e, t, s) {
                        var r = t[0],
                            i = t[1],
                            a = t[2],
                            n = t[3],
                            o = t[4],
                            l = t[5],
                            h = t[6],
                            c = t[7],
                            t = t[8],
                            d = s[0],
                            u = s[1],
                            p = s[2],
                            m = s[3],
                            g = s[4],
                            _ = s[5],
                            f = s[6],
                            v = s[7],
                            s = s[8];
                        return e[0] = d * r + u * n + p * h, e[1] = d * i + u * o + p * c, e[2] = d * a + u * l + p * t, e[3] = m * r + g * n + _ * h, e[4] = m * i + g * o + _ * c, e[5] = m * a + g * l + _ * t, e[6] = f * r + v * n + s * h, e[7] = f * i + v * o + s * c, e[8] = f * a + v * l + s * t, e
                    }
                    static translate(e, t, s) {
                        var r = t[0],
                            i = t[1],
                            a = t[2],
                            n = t[3],
                            o = t[4],
                            l = t[5],
                            h = t[6],
                            c = t[7],
                            t = t[8],
                            d = s[0],
                            s = s[1];
                        return e[0] = r, e[1] = i, e[2] = a, e[3] = n, e[4] = o, e[5] = l, e[6] = d * r + s * n + h, e[7] = d * i + s * o + c, e[8] = d * a + s * l + t, e
                    }
                    static rotate(e, t, s) {
                        var r = t[0],
                            i = t[1],
                            a = t[2],
                            n = t[3],
                            o = t[4],
                            l = t[5],
                            h = t[6],
                            c = t[7],
                            t = t[8],
                            d = Math.sin(s),
                            s = Math.cos(s);
                        return e[0] = s * r + d * n, e[1] = s * i + d * o, e[2] = s * a + d * l, e[3] = s * n - d * r, e[4] = s * o - d * i, e[5] = s * l - d * a, e[6] = h, e[7] = c, e[8] = t, e
                    }
                    static setTranslation(e, t) {
                        return e[6] = t[0], e[7] = t[1], e
                    }
                    static scale(e, t, s) {
                        var r = s[0],
                            s = s[1];
                        return e[0] = r * t[0], e[1] = r * t[1], e[2] = r * t[2], e[3] = s * t[3], e[4] = s * t[4], e[5] = s * t[5], e[6] = t[6], e[7] = t[7], e[8] = t[8], e
                    }
                    static fromTranslation(e, t) {
                        return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 1, e[5] = 0, e[6] = t[0], e[7] = t[1], e[8] = 1, e
                    }
                    static fromRotation(e, t) {
                        var s = Math.sin(t),
                            t = Math.cos(t);
                        return e[0] = t, e[1] = s, e[2] = 0, e[3] = -s, e[4] = t, e[5] = 0, e[6] = 0, e[7] = 0, e[8] = 1, e
                    }
                    static fromScaling(e, t) {
                        return e[0] = t[0], e[1] = 0, e[2] = 0, e[3] = 0, e[4] = t[1], e[5] = 0, e[6] = 0, e[7] = 0, e[8] = 1, e
                    }
                    static fromMat2d(e, t) {
                        return e[0] = t[0], e[1] = t[1], e[2] = 0, e[3] = t[2], e[4] = t[3], e[5] = 0, e[6] = t[4], e[7] = t[5], e[8] = 1, e
                    }
                    static fromQuat(e, t) {
                        var s = t[0],
                            r = t[1],
                            i = t[2],
                            t = t[3],
                            a = s + s,
                            n = r + r,
                            o = i + i,
                            s = s * a,
                            l = r * a,
                            r = r * n,
                            h = i * a,
                            c = i * n,
                            i = i * o,
                            a = t * a,
                            n = t * n,
                            t = t * o;
                        return e[0] = 1 - r - i, e[3] = l - t, e[6] = h + n, e[1] = l + t, e[4] = 1 - s - i, e[7] = c - a, e[2] = h - n, e[5] = c + a, e[8] = 1 - s - r, e
                    }
                    static decompose(e, t, s) {
                        var r;
                        return this.getScaling(e, s), this.getTranslation(t, s), this.determinant(s) <= 0 && (e[0] *= -1), 0 === e[0] || 0 === e[1] || 0 === e[2] ? 0 : (t = 1 / e[0], r = 1 / e[1], e = 1 / e[2], t = [s[0] * t, s[1] * t, s[2] * t, 0, s[4] * r, s[5] * r, s[6] * r, 0, s[8] * e, s[9] * e, s[10] * e, 0, 0, 0, 0, 1], this.getRotation(t))
                    }
                    static getScaling(e, t) {
                        var s = t[0],
                            r = t[1],
                            i = t[3],
                            t = t[4];
                        return e[0] = a.M.sign(s) * Math.sqrt(s * s + r * r), e[1] = a.M.sign(t) * Math.sqrt(i * i + t * t), e
                    }
                    static getRotation(e) {
                        return -Math.atan2(e[1], e[0])
                    }
                    static getTranslation(e, t) {
                        return e[0] = t[6], e[1] = t[7], e
                    }
                    static normalFromMat4(e, t) {
                        var s = t[0],
                            r = t[1],
                            i = t[2],
                            a = t[3],
                            n = t[4],
                            o = t[5],
                            l = t[6],
                            h = t[7],
                            c = t[8],
                            d = t[9],
                            u = t[10],
                            p = t[11],
                            m = t[12],
                            g = t[13],
                            _ = t[14],
                            t = t[15],
                            f = s * o - r * n,
                            v = s * l - i * n,
                            b = s * h - a * n,
                            x = r * l - i * o,
                            T = r * h - a * o,
                            w = i * h - a * l,
                            E = c * g - d * m,
                            C = c * _ - u * m,
                            c = c * t - p * m,
                            y = d * _ - u * g,
                            d = d * t - p * g,
                            u = u * t - p * _,
                            p = f * u - v * d + b * y + x * c - T * C + w * E;
                        return p ? (e[0] = (o * u - l * d + h * y) * (p = 1 / p), e[1] = (l * c - n * u - h * C) * p, e[2] = (n * d - o * c + h * E) * p, e[3] = (i * d - r * u - a * y) * p, e[4] = (s * u - i * c + a * C) * p, e[5] = (r * c - s * d - a * E) * p, e[6] = (g * w - _ * T + t * x) * p, e[7] = (_ * b - m * w - t * v) * p, e[8] = (m * T - g * b + t * f) * p, e) : null
                    }
                    static str(e) {
                        return "mat3(" + e[0] + ", " + e[1] + ", " + e[2] + ", " + e[3] + ", " + e[4] + ", " + e[5] + ", " + e[6] + ", " + e[7] + ", " + e[8] + ")"
                    }
                    static frob(e) {
                        return Math.sqrt(Math.pow(e[0], 2) + Math.pow(e[1], 2) + Math.pow(e[2], 2) + Math.pow(e[3], 2) + Math.pow(e[4], 2) + Math.pow(e[5], 2) + Math.pow(e[6], 2) + Math.pow(e[7], 2) + Math.pow(e[8], 2))
                    }
                    static add(e, t, s) {
                        return e[0] = t[0] + s[0], e[1] = t[1] + s[1], e[2] = t[2] + s[2], e[3] = t[3] + s[3], e[4] = t[4] + s[4], e[5] = t[5] + s[5], e[6] = t[6] + s[6], e[7] = t[7] + s[7], e[8] = t[8] + s[8], e
                    }
                    static subtract(e, t, s) {
                        return e[0] = t[0] - s[0], e[1] = t[1] - s[1], e[2] = t[2] - s[2], e[3] = t[3] - s[3], e[4] = t[4] - s[4], e[5] = t[5] - s[5], e[6] = t[6] - s[6], e[7] = t[7] - s[7], e[8] = t[8] - s[8], e
                    }
                    static multiplyScalar(e, t, s) {
                        return e[0] = t[0] * s, e[1] = t[1] * s, e[2] = t[2] * s, e[3] = t[3] * s, e[4] = t[4] * s, e[5] = t[5] * s, e[6] = t[6] * s, e[7] = t[7] * s, e[8] = t[8] * s, e
                    }
                    static multiplyScalarAndAdd(e, t, s, r) {
                        return e[0] = t[0] + s[0] * r, e[1] = t[1] + s[1] * r, e[2] = t[2] + s[2] * r, e[3] = t[3] + s[3] * r, e[4] = t[4] + s[4] * r, e[5] = t[5] + s[5] * r, e[6] = t[6] + s[6] * r, e[7] = t[7] + s[7] * r, e[8] = t[8] + s[8] * r, e
                    }
                }
                c.GLMAT_ARRAY_TYPE = Float32Array, c.copy = function(e, t) {
                    return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5], e[6] = t[6], e[7] = t[7], e[8] = t[8], e
                }, c.mul = c.multiply, c.sub = c.subtract, c.exactEquals = function(e, t) {
                    return e[0] === t[0] && e[1] === t[1] && e[2] === t[2] && e[3] === t[3] && e[4] === t[4] && e[5] === t[5] && e[6] === t[6] && e[7] === t[7] && e[8] === t[8]
                }, c.equals = function(e, t) {
                    var s = b.g.EPS,
                        r = e[0],
                        i = e[1],
                        a = e[2],
                        n = e[3],
                        o = e[4],
                        l = e[5],
                        h = e[6],
                        c = e[7],
                        e = e[8],
                        d = t[0],
                        u = t[1],
                        p = t[2],
                        m = t[3],
                        g = t[4],
                        _ = t[5],
                        f = t[6],
                        v = t[7],
                        t = t[8];
                    return Math.abs(r - d) <= s * Math.max(1, Math.abs(r), Math.abs(d)) && Math.abs(i - u) <= s * Math.max(1, Math.abs(i), Math.abs(u)) && Math.abs(a - p) <= s * Math.max(1, Math.abs(a), Math.abs(p)) && Math.abs(n - m) <= s * Math.max(1, Math.abs(n), Math.abs(m)) && Math.abs(o - g) <= s * Math.max(1, Math.abs(o), Math.abs(g)) && Math.abs(l - _) <= s * Math.max(1, Math.abs(l), Math.abs(_)) && Math.abs(h - f) <= s * Math.max(1, Math.abs(h), Math.abs(f)) && Math.abs(c - v) <= s * Math.max(1, Math.abs(c), Math.abs(v)) && Math.abs(e - t) <= s * Math.max(1, Math.abs(e), Math.abs(t))
                }
            },
            7723: (e, t, s) => {
                s.d(t, {
                    _: () => E
                });
                var M = s(6650),
                    l = s(2671),
                    f = s(82);
                class E {
                    static create() {
                        var e = new E.GLMAT_ARRAY_TYPE(16);
                        return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = 1, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = 1, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e
                    }
                    static clone(e) {
                        var t = new E.GLMAT_ARRAY_TYPE(16);
                        return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4], t[5] = e[5], t[6] = e[6], t[7] = e[7], t[8] = e[8], t[9] = e[9], t[10] = e[10], t[11] = e[11], t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15], t
                    }
                    static copy(e, t) {
                        return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5], e[6] = t[6], e[7] = t[7], e[8] = t[8], e[9] = t[9], e[10] = t[10], e[11] = t[11], e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15], e
                    }
                    static identity(e) {
                        return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = 1, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = 1, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e
                    }
                    static transpose(e, t) {
                        var s, r, i, a, n, o;
                        return e === t ? (s = t[1], r = t[2], i = t[3], a = t[6], n = t[7], o = t[11], e[1] = t[4], e[2] = t[8], e[3] = t[12], e[4] = s, e[6] = t[9], e[7] = t[13], e[8] = r, e[9] = a, e[11] = t[14], e[12] = i, e[13] = n, e[14] = o) : (e[0] = t[0], e[1] = t[4], e[2] = t[8], e[3] = t[12], e[4] = t[1], e[5] = t[5], e[6] = t[9], e[7] = t[13], e[8] = t[2], e[9] = t[6], e[10] = t[10], e[11] = t[14], e[12] = t[3], e[13] = t[7], e[14] = t[11], e[15] = t[15]), e
                    }
                    static invert(e, t) {
                        var s = t[0],
                            r = t[1],
                            i = t[2],
                            a = t[3],
                            n = t[4],
                            o = t[5],
                            l = t[6],
                            h = t[7],
                            c = t[8],
                            d = t[9],
                            u = t[10],
                            p = t[11],
                            m = t[12],
                            g = t[13],
                            _ = t[14],
                            t = t[15],
                            f = s * o - r * n,
                            v = s * l - i * n,
                            b = s * h - a * n,
                            x = r * l - i * o,
                            T = r * h - a * o,
                            w = i * h - a * l,
                            E = c * g - d * m,
                            C = c * _ - u * m,
                            y = c * t - p * m,
                            A = d * _ - u * g,
                            M = d * t - p * g,
                            R = u * t - p * _,
                            S = f * R - v * M + b * A + x * y - T * C + w * E;
                        return S ? (e[0] = (o * R - l * M + h * A) * (S = 1 / S), e[1] = (i * M - r * R - a * A) * S, e[2] = (g * w - _ * T + t * x) * S, e[3] = (u * T - d * w - p * x) * S, e[4] = (l * y - n * R - h * C) * S, e[5] = (s * R - i * y + a * C) * S, e[6] = (_ * b - m * w - t * v) * S, e[7] = (c * w - u * b + p * v) * S, e[8] = (n * M - o * y + h * E) * S, e[9] = (r * y - s * M - a * E) * S, e[10] = (m * T - g * b + t * f) * S, e[11] = (d * b - c * T - p * f) * S, e[12] = (o * C - n * A - l * E) * S, e[13] = (s * A - r * C + i * E) * S, e[14] = (g * v - m * x - _ * f) * S, e[15] = (c * x - d * v + u * f) * S, e) : null
                    }
                    static adjoint(e, t) {
                        var s = t[0],
                            r = t[1],
                            i = t[2],
                            a = t[3],
                            n = t[4],
                            o = t[5],
                            l = t[6],
                            h = t[7],
                            c = t[8],
                            d = t[9],
                            u = t[10],
                            p = t[11],
                            m = t[12],
                            g = t[13],
                            _ = t[14],
                            t = t[15];
                        return e[0] = o * (u * t - p * _) - d * (l * t - h * _) + g * (l * p - h * u), e[1] = -(r * (u * t - p * _) - d * (i * t - a * _) + g * (i * p - a * u)), e[2] = r * (l * t - h * _) - o * (i * t - a * _) + g * (i * h - a * l), e[3] = -(r * (l * p - h * u) - o * (i * p - a * u) + d * (i * h - a * l)), e[4] = -(n * (u * t - p * _) - c * (l * t - h * _) + m * (l * p - h * u)), e[5] = s * (u * t - p * _) - c * (i * t - a * _) + m * (i * p - a * u), e[6] = -(s * (l * t - h * _) - n * (i * t - a * _) + m * (i * h - a * l)), e[7] = s * (l * p - h * u) - n * (i * p - a * u) + c * (i * h - a * l), e[8] = n * (d * t - p * g) - c * (o * t - h * g) + m * (o * p - h * d), e[9] = -(s * (d * t - p * g) - c * (r * t - a * g) + m * (r * p - a * d)), e[10] = s * (o * t - h * g) - n * (r * t - a * g) + m * (r * h - a * o), e[11] = -(s * (o * p - h * d) - n * (r * p - a * d) + c * (r * h - a * o)), e[12] = -(n * (d * _ - u * g) - c * (o * _ - l * g) + m * (o * u - l * d)), e[13] = s * (d * _ - u * g) - c * (r * _ - i * g) + m * (r * u - i * d), e[14] = -(s * (o * _ - l * g) - n * (r * _ - i * g) + m * (r * l - i * o)), e[15] = s * (o * u - l * d) - n * (r * u - i * d) + c * (r * l - i * o), e
                    }
                    static determinant(e) {
                        var t = e[0],
                            s = e[1],
                            r = e[2],
                            i = e[3],
                            a = e[4],
                            n = e[5],
                            o = e[6],
                            l = e[7],
                            h = e[8],
                            c = e[9],
                            d = e[10],
                            u = e[11],
                            p = e[12],
                            m = e[13],
                            g = e[14],
                            e = e[15];
                        return (t * n - s * a) * (d * e - u * g) - (t * o - r * a) * (c * e - u * m) + (t * l - i * a) * (c * g - d * m) + (s * o - r * n) * (h * e - u * p) - (s * l - i * n) * (h * g - d * p) + (r * l - i * o) * (h * m - c * p)
                    }
                    static multiply(e, t, s) {
                        var r = t[0],
                            i = t[1],
                            a = t[2],
                            n = t[3],
                            o = t[4],
                            l = t[5],
                            h = t[6],
                            c = t[7],
                            d = t[8],
                            u = t[9],
                            p = t[10],
                            m = t[11],
                            g = t[12],
                            _ = t[13],
                            f = t[14],
                            t = t[15],
                            v = s[0],
                            b = s[1],
                            x = s[2],
                            T = s[3];
                        return e[0] = v * r + b * o + x * d + T * g, e[1] = v * i + b * l + x * u + T * _, e[2] = v * a + b * h + x * p + T * f, e[3] = v * n + b * c + x * m + T * t, v = s[4], b = s[5], x = s[6], T = s[7], e[4] = v * r + b * o + x * d + T * g, e[5] = v * i + b * l + x * u + T * _, e[6] = v * a + b * h + x * p + T * f, e[7] = v * n + b * c + x * m + T * t, v = s[8], b = s[9], x = s[10], T = s[11], e[8] = v * r + b * o + x * d + T * g, e[9] = v * i + b * l + x * u + T * _, e[10] = v * a + b * h + x * p + T * f, e[11] = v * n + b * c + x * m + T * t, v = s[12], b = s[13], x = s[14], T = s[15], e[12] = v * r + b * o + x * d + T * g, e[13] = v * i + b * l + x * u + T * _, e[14] = v * a + b * h + x * p + T * f, e[15] = v * n + b * c + x * m + T * t, e
                    }
                    static translate(e, t, s) {
                        var r, i, a, n, o, l, h, c, d, u, p, m, g = s[0],
                            _ = s[1],
                            s = s[2];
                        return t === e ? (e[12] = t[0] * g + t[4] * _ + t[8] * s + t[12], e[13] = t[1] * g + t[5] * _ + t[9] * s + t[13], e[14] = t[2] * g + t[6] * _ + t[10] * s + t[14], e[15] = t[3] * g + t[7] * _ + t[11] * s + t[15]) : (r = t[0], i = t[1], a = t[2], n = t[3], o = t[4], l = t[5], h = t[6], c = t[7], d = t[8], u = t[9], p = t[10], m = t[11], e[0] = r, e[1] = i, e[2] = a, e[3] = n, e[4] = o, e[5] = l, e[6] = h, e[7] = c, e[8] = d, e[9] = u, e[10] = p, e[11] = m, e[12] = r * g + o * _ + d * s + t[12], e[13] = i * g + l * _ + u * s + t[13], e[14] = a * g + h * _ + p * s + t[14], e[15] = n * g + c * _ + m * s + t[15]), e
                    }
                    static setTranslation(e, t) {
                        return e[12] = t[0], e[13] = t[1], e[14] = t[2], e
                    }
                    static scale(e, t, s) {
                        var r = s[0],
                            i = s[1],
                            s = s[2];
                        return e[0] = t[0] * r, e[1] = t[1] * r, e[2] = t[2] * r, e[3] = t[3] * r, e[4] = t[4] * i, e[5] = t[5] * i, e[6] = t[6] * i, e[7] = t[7] * i, e[8] = t[8] * s, e[9] = t[9] * s, e[10] = t[10] * s, e[11] = t[11] * s, e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15], e
                    }
                    static setScale(e, t) {
                        return e[0] = t[0], e[5] = t[1], e[10] = t[2], e
                    }
                    static rotate(e, t, s, r) {
                        var i, a, n, o, l, h, c, d, u, p, m, g, _, f, v, b, x, T, w, E, C = r[0],
                            y = r[1],
                            r = r[2],
                            A = Math.sqrt(C * C + y * y + r * r);
                        return Math.abs(A) < M.g.EPS ? null : (C *= A = 1 / A, y *= A, r *= A, A = Math.sin(s), s = Math.cos(s), a = t[0], n = t[1], o = t[2], l = t[3], h = t[4], c = t[5], d = t[6], u = t[7], p = t[8], m = t[9], g = t[10], _ = t[11], v = C * y * (i = 1 - s) - r * A, b = y * y * i + s, x = r * y * i + C * A, T = C * r * i + y * A, w = y * r * i - C * A, E = r * r * i + s, e[0] = a * (s = C * C * i + s) + h * (f = y * C * i + r * A) + p * (r = r * C * i - y * A), e[1] = n * s + c * f + m * r, e[2] = o * s + d * f + g * r, e[3] = l * s + u * f + _ * r, e[4] = a * v + h * b + p * x, e[5] = n * v + c * b + m * x, e[6] = o * v + d * b + g * x, e[7] = l * v + u * b + _ * x, e[8] = a * T + h * w + p * E, e[9] = n * T + c * w + m * E, e[10] = o * T + d * w + g * E, e[11] = l * T + u * w + _ * E, t !== e && (e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15]), e)
                    }
                    static rotateX(e, t, s) {
                        var r = Math.sin(s),
                            s = Math.cos(s),
                            i = t[4],
                            a = t[5],
                            n = t[6],
                            o = t[7],
                            l = t[8],
                            h = t[9],
                            c = t[10],
                            d = t[11];
                        return t !== e && (e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15]), e[4] = i * s + l * r, e[5] = a * s + h * r, e[6] = n * s + c * r, e[7] = o * s + d * r, e[8] = l * s - i * r, e[9] = h * s - a * r, e[10] = c * s - n * r, e[11] = d * s - o * r, e
                    }
                    static rotateY(e, t, s) {
                        var r = Math.sin(s),
                            s = Math.cos(s),
                            i = t[0],
                            a = t[1],
                            n = t[2],
                            o = t[3],
                            l = t[8],
                            h = t[9],
                            c = t[10],
                            d = t[11];
                        return t !== e && (e[4] = t[4], e[5] = t[5], e[6] = t[6], e[7] = t[7], e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15]), e[0] = i * s - l * r, e[1] = a * s - h * r, e[2] = n * s - c * r, e[3] = o * s - d * r, e[8] = i * r + l * s, e[9] = a * r + h * s, e[10] = n * r + c * s, e[11] = o * r + d * s, e
                    }
                    static rotateZ(e, t, s) {
                        var r = Math.sin(s),
                            s = Math.cos(s),
                            i = t[0],
                            a = t[1],
                            n = t[2],
                            o = t[3],
                            l = t[4],
                            h = t[5],
                            c = t[6],
                            d = t[7];
                        return t !== e && (e[8] = t[8], e[9] = t[9], e[10] = t[10], e[11] = t[11], e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15]), e[0] = i * s + l * r, e[1] = a * s + h * r, e[2] = n * s + c * r, e[3] = o * s + d * r, e[4] = l * s - i * r, e[5] = h * s - a * r, e[6] = c * s - n * r, e[7] = d * s - o * r, e
                    }
                    static fromRotationTranslation(e, t, s) {
                        var r = t[0],
                            i = t[1],
                            a = t[2],
                            t = t[3],
                            n = r + r,
                            o = i + i,
                            l = a + a,
                            h = r * n,
                            c = r * o,
                            r = r * l,
                            d = i * o,
                            i = i * l,
                            a = a * l,
                            n = t * n,
                            o = t * o,
                            t = t * l;
                        return e[0] = 1 - (d + a), e[1] = c + t, e[2] = r - o, e[3] = 0, e[4] = c - t, e[5] = 1 - (h + a), e[6] = i + n, e[7] = 0, e[8] = r + o, e[9] = i - n, e[10] = 1 - (h + d), e[11] = 0, e[12] = s[0], e[13] = s[1], e[14] = s[2], e[15] = 1, e
                    }
                    static fromTranslation(e, t) {
                        return E.identity(e), E.setTranslation(e, t), e
                    }
                    static getTranslation(e, t) {
                        return e[0] = t[12], e[1] = t[13], e[2] = t[14], e
                    }
                    static getScaling(e, t) {
                        var s = t[0],
                            r = t[1],
                            i = t[2],
                            a = t[4],
                            n = t[5],
                            o = t[6],
                            l = t[8],
                            h = t[9],
                            t = t[10];
                        return e[0] = Math.hypot(s, r, i), e[1] = Math.hypot(a, n, o), e[2] = Math.hypot(l, h, t), e
                    }
                    static getRotation(e, t) {
                        var s = f.R.create();
                        this.getScaling(s, t);
                        let r = 1 / s[0],
                            i = 1 / s[1],
                            a = 1 / s[2],
                            n = t[0] * r,
                            o = t[1] * i,
                            l = t[2] * a,
                            h = t[4] * r,
                            c = t[5] * i,
                            d = t[6] * a,
                            u = t[8] * r,
                            p = t[9] * i,
                            m = t[10] * a,
                            g = n + c + m,
                            _ = 0;
                        return 0 < g ? (_ = 2 * Math.sqrt(1 + g), e[3] = .25 * _, e[0] = (d - p) / _, e[1] = (u - l) / _, e[2] = (o - h) / _) : c < n && m < n ? (_ = 2 * Math.sqrt(1 + n - c - m), e[3] = (d - p) / _, e[0] = .25 * _, e[1] = (o + h) / _, e[2] = (u + l) / _) : m < c ? (_ = 2 * Math.sqrt(1 + c - n - m), e[3] = (u - l) / _, e[0] = (o + h) / _, e[1] = .25 * _, e[2] = (d + p) / _) : (_ = 2 * Math.sqrt(1 + m - n - c), e[3] = (o - h) / _, e[0] = (u + l) / _, e[1] = (d + p) / _, e[2] = .25 * _), e
                    }
                    static decomposeOld(s, r, i, a) {
                        if (this.getScaling(i, a), this.getTranslation(r, a), this.determinant(a) <= 0 && (i[0] *= -1), 0 === i[0] || 0 === i[1] || 0 === i[2]) l.g.identity(s);
                        else {
                            const r = 1 / i[0],
                                l = 1 / i[1],
                                n = 1 / i[2],
                                o = [a[0] * r, a[1] * r, a[2] * r, 0, a[4] * l, a[5] * l, a[6] * l, 0, a[8] * n, a[9] * n, a[10] * n, 0, 0, 0, 0, 1];
                            let e = o[0] + o[5] + o[10],
                                t = 0;
                            0 < e ? (t = 2 * Math.sqrt(e + 1), s[3] = .25 * t, s[0] = (o[6] - o[9]) / t, s[1] = (o[8] - o[2]) / t, s[2] = (o[1] - o[4]) / t) : o[5] < o[0] && o[10] < o[0] ? (t = 2 * Math.sqrt(1 + o[0] - o[5] - o[10]), s[3] = (o[6] - o[9]) / t, s[0] = .25 * t, s[1] = (o[1] + o[4]) / t, s[2] = (o[8] + o[2]) / t) : o[10] < o[5] ? (t = 2 * Math.sqrt(1 + o[5] - o[0] - o[10]), s[3] = (o[8] - o[2]) / t, s[0] = (o[1] + o[4]) / t, s[1] = .25 * t, s[2] = (o[6] + o[9]) / t) : (t = 2 * Math.sqrt(1 + o[10] - o[0] - o[5]), s[3] = (o[1] - o[4]) / t, s[0] = (o[8] + o[2]) / t, s[1] = (o[6] + o[9]) / t, s[2] = .25 * t)
                        }
                    }
                    static fromRotationTranslationScale(e, t, s, r) {
                        var i = t[0],
                            a = t[1],
                            n = t[2],
                            t = t[3],
                            o = i + i,
                            l = a + a,
                            h = n + n,
                            c = i * o,
                            d = i * l,
                            i = i * h,
                            u = a * l,
                            a = a * h,
                            n = n * h,
                            o = t * o,
                            l = t * l,
                            t = t * h,
                            h = r[0],
                            p = r[1],
                            r = r[2];
                        return e[0] = (1 - (u + n)) * h, e[1] = (d + t) * h, e[2] = (i - l) * h, e[3] = 0, e[4] = (d - t) * p, e[5] = (1 - (c + n)) * p, e[6] = (a + o) * p, e[7] = 0, e[8] = (i + l) * r, e[9] = (a - o) * r, e[10] = (1 - (c + u)) * r, e[11] = 0, e[12] = s[0], e[13] = s[1], e[14] = s[2], e[15] = 1, e
                    }
                    static fromRotationTranslationScaleOrigin(e, t, s, r, i) {
                        var a = t[0],
                            n = t[1],
                            o = t[2],
                            t = t[3],
                            l = a + a,
                            h = n + n,
                            c = o + o,
                            d = a * l,
                            u = a * h,
                            a = a * c,
                            p = n * h,
                            n = n * c,
                            o = o * c,
                            l = t * l,
                            h = t * h,
                            t = t * c,
                            c = r[0],
                            m = r[1],
                            r = r[2],
                            g = i[0],
                            _ = i[1],
                            i = i[2];
                        return e[0] = (1 - (p + o)) * c, e[1] = (u + t) * c, e[2] = (a - h) * c, e[3] = 0, e[4] = (u - t) * m, e[5] = (1 - (d + o)) * m, e[6] = (n + l) * m, e[7] = 0, e[8] = (a + h) * r, e[9] = (n - l) * r, e[10] = (1 - (d + p)) * r, e[11] = 0, e[12] = s[0] + g - (e[0] * g + e[4] * _ + e[8] * i), e[13] = s[1] + _ - (e[1] * g + e[5] * _ + e[9] * i), e[14] = s[2] + i - (e[2] * g + e[6] * _ + e[10] * i), e[15] = 1, e
                    }
                    static fromQuat(e, t) {
                        var s = t[0],
                            r = t[1],
                            i = t[2],
                            t = t[3],
                            a = s + s,
                            n = r + r,
                            o = i + i,
                            s = s * a,
                            l = r * a,
                            r = r * n,
                            h = i * a,
                            c = i * n,
                            i = i * o,
                            a = t * a,
                            n = t * n,
                            t = t * o;
                        return e[0] = 1 - r - i, e[1] = l + t, e[2] = h - n, e[3] = 0, e[4] = l - t, e[5] = 1 - s - i, e[6] = c + a, e[7] = 0, e[8] = h + n, e[9] = c - a, e[10] = 1 - s - r, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e
                    }
                    static frustum(e, t, s, r, i, a, n) {
                        var o = 1 / (s - t),
                            l = 1 / (i - r),
                            h = 1 / (a - n);
                        return e[0] = 2 * a * o, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = 2 * a * l, e[6] = 0, e[7] = 0, e[8] = (s + t) * o, e[9] = (i + r) * l, e[10] = (n + a) * h, e[11] = -1, e[12] = 0, e[13] = 0, e[14] = n * a * 2 * h, e[15] = 0, e
                    }
                    static perspective(e, t, s, r, i) {
                        var t = 1 / Math.tan(t / 2),
                            a = 1 / (r - i);
                        return e[0] = t / s, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = t, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = (i + r) * a, e[11] = -1, e[12] = 0, e[13] = 0, e[14] = 2 * i * r * a, e[15] = 0, e
                    }
                    static ortho(e, t, s, r, i, a, n) {
                        var o = 1 / (t - s),
                            l = 1 / (r - i),
                            h = 1 / (a - n);
                        return e[0] = -2 * o, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = -2 * l, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = 2 * h, e[11] = 0, e[12] = (t + s) * o, e[13] = (i + r) * l, e[14] = (n + a) * h, e[15] = 1, e
                    }
                    static lookAt(e, t, s, r) {
                        let i, a, n, o, l, h, c, d, u, p, m = t[0],
                            g = t[1],
                            _ = t[2],
                            f = r[0],
                            v = r[1],
                            b = r[2],
                            x = s[0],
                            T = s[1],
                            w = s[2];
                        t = M.g.EPS;
                        return Math.abs(m - x) < t && Math.abs(g - T) < t && Math.abs(_ - w) < t ? E.identity(e) : (c = m - x, d = g - T, u = _ - w, c *= p = 1 / Math.sqrt(c * c + d * d + u * u), d *= p, u *= p, i = v * u - b * d, a = b * c - f * u, n = f * d - v * c, (p = Math.sqrt(i * i + a * a + n * n)) ? (p = 1 / p, i *= p, a *= p, n *= p) : (i = 0, a = 0, n = 0), o = d * n - u * a, l = u * i - c * n, h = c * a - d * i, (p = Math.sqrt(o * o + l * l + h * h)) ? (p = 1 / p, o *= p, l *= p, h *= p) : (o = 0, l = 0, h = 0), e[0] = i, e[1] = o, e[2] = c, e[3] = 0, e[4] = a, e[5] = l, e[6] = d, e[7] = 0, e[8] = n, e[9] = h, e[10] = u, e[11] = 0, e[12] = -(i * m + a * g + n * _), e[13] = -(o * m + l * g + h * _), e[14] = -(c * m + d * g + u * _), e[15] = 1, e)
                    }
                    static str(e) {
                        return "mat4(" + e[0] + ", " + e[1] + ", " + e[2] + ", " + e[3] + ", " + e[4] + ", " + e[5] + ", " + e[6] + ", " + e[7] + ", " + e[8] + ", " + e[9] + ", " + e[10] + ", " + e[11] + ", " + e[12] + ", " + e[13] + ", " + e[14] + ", " + e[15] + ")"
                    }
                    static frob(e) {
                        return Math.sqrt(Math.pow(e[0], 2) + Math.pow(e[1], 2) + Math.pow(e[2], 2) + Math.pow(e[3], 2) + Math.pow(e[4], 2) + Math.pow(e[5], 2) + Math.pow(e[6], 2) + Math.pow(e[6], 2) + Math.pow(e[7], 2) + Math.pow(e[8], 2) + Math.pow(e[9], 2) + Math.pow(e[10], 2) + Math.pow(e[11], 2) + Math.pow(e[12], 2) + Math.pow(e[13], 2) + Math.pow(e[14], 2) + Math.pow(e[15], 2))
                    }
                }
                E.GLMAT_ARRAY_TYPE = Float32Array, E.IDENTITY = E.identity(E.create()), E.mul = E.multiply
            },
            2671: (e, t, s) => {
                s.d(t, {
                    g: () => l
                });
                var a = s(82),
                    t = s(3790),
                    n = s(6650),
                    r = s(9816),
                    o = s(6407);
                class l {
                    static create() {
                        var e = new l.GLMAT_ARRAY_TYPE(4);
                        return e[0] = 0, e[1] = 0, e[2] = 0, e[3] = 1, e
                    }
                    static rotationTo(e, t, s) {
                        var r = a.R.dot(t, s),
                            i = l.tmpvec3;
                        return r < -.999999 ? (a.R.cross(i, n.g.VEC3_RIGHT, t), a.R.magnitude(i) < 1e-6 && a.R.cross(i, n.g.VEC3_UP, t), a.R.normalize(i, i), l.setAxisAngle(e, i, Math.PI), e) : .999999 < r ? (e[0] = 0, e[1] = 0, e[2] = 0, e[3] = 1, e) : (a.R.cross(i, t, s), e[0] = i[0], e[1] = i[1], e[2] = i[2], e[3] = 1 + r, l.normalize(e, e))
                    }
                    static setAxes(e, t, s, r) {
                        var i = l.tmpmat3;
                        return i[0] = s[0], i[3] = s[1], i[6] = s[2], i[1] = r[0], i[4] = r[1], i[7] = r[2], i[2] = -t[0], i[5] = -t[1], i[8] = -t[2], l.normalize(e, l.fromMat3(e, i))
                    }
                    static identity(e) {
                        return e[0] = 0, e[1] = 0, e[2] = 0, e[3] = 1, e
                    }
                    static isIdentity(e) {
                        return 1 === e[3] || -1 === e[3]
                    }
                    static setAxisAngle(e, t, s) {
                        s *= .5;
                        var r = Math.sin(s);
                        return e[0] = r * t[0], e[1] = r * t[1], e[2] = r * t[2], e[3] = Math.cos(s), e
                    }
                    static multiply(e, t, s) {
                        var r = t[0],
                            i = t[1],
                            a = t[2],
                            t = t[3],
                            n = s[0],
                            o = s[1],
                            l = s[2],
                            s = s[3];
                        return e[0] = r * s + t * n + i * l - a * o, e[1] = i * s + t * o + a * n - r * l, e[2] = a * s + t * l + r * o - i * n, e[3] = t * s - r * n - i * o - a * l, e
                    }
                    static rotateX(e, t, s) {
                        s *= .5;
                        var r = t[0],
                            i = t[1],
                            a = t[2],
                            t = t[3],
                            n = Math.sin(s),
                            s = Math.cos(s);
                        return e[0] = r * s + t * n, e[1] = i * s + a * n, e[2] = a * s - i * n, e[3] = t * s - r * n, e
                    }
                    static rotateY(e, t, s) {
                        s *= .5;
                        var r = t[0],
                            i = t[1],
                            a = t[2],
                            t = t[3],
                            n = Math.sin(s),
                            s = Math.cos(s);
                        return e[0] = r * s - a * n, e[1] = i * s + t * n, e[2] = a * s + r * n, e[3] = t * s - i * n, e
                    }
                    static rotateZ(e, t, s) {
                        s *= .5;
                        var r = t[0],
                            i = t[1],
                            a = t[2],
                            t = t[3],
                            n = Math.sin(s),
                            s = Math.cos(s);
                        return e[0] = r * s + i * n, e[1] = i * s - r * n, e[2] = a * s + t * n, e[3] = t * s - a * n, e
                    }
                    static calculateW(e, t) {
                        var s = t[0],
                            r = t[1],
                            t = t[2];
                        return e[0] = s, e[1] = r, e[2] = t, e[3] = Math.sqrt(Math.abs(1 - s * s - r * r - t * t)), e
                    }
                    static slerp(e, t, s, r) {
                        let i, a, n, o, l, h = t[0],
                            c = t[1],
                            d = t[2],
                            u = t[3],
                            p = s[0],
                            m = s[1],
                            g = s[2],
                            _ = s[3];
                        return (a = h * p + c * m + d * g + u * _) < 0 && (a = -a, p = -p, m = -m, g = -g, _ = -_), l = 1e-6 < 1 - a ? (i = Math.acos(a), n = Math.sin(i), o = Math.sin((1 - r) * i) / n, Math.sin(r * i) / n) : (o = 1 - r, r), e[0] = o * h + l * p, e[1] = o * c + l * m, e[2] = o * d + l * g, e[3] = o * u + l * _, e
                    }
                    static sqlerp(e, t, s, r, i, a) {
                        var n = l.temp1,
                            o = l.temp2;
                        return l.slerp(n, t, i, a), l.slerp(o, s, r, a), l.slerp(e, n, o, 2 * a * (1 - a)), e
                    }
                    static invert(e, t) {
                        var s = t[0],
                            r = t[1],
                            i = t[2],
                            t = t[3],
                            a = s * s + r * r + i * i + t * t,
                            a = a ? 1 / a : 0;
                        return e[0] = -s * a, e[1] = -r * a, e[2] = -i * a, e[3] = t * a, e
                    }
                    static conjugate(e, t) {
                        return e[0] = -t[0], e[1] = -t[1], e[2] = -t[2], e[3] = t[3], e
                    }
                    static fromMat3(t, s) {
                        var r = s[0] + s[4] + s[8];
                        let i;
                        if (0 < r) i = Math.sqrt(r + 1), t[3] = .5 * i, i = .5 / i, t[0] = (s[5] - s[7]) * i, t[1] = (s[6] - s[2]) * i, t[2] = (s[1] - s[3]) * i;
                        else {
                            let e = 0;
                            s[4] > s[0] && (e = 1);
                            var r = ((e = s[8] > s[3 * e + e] ? 2 : e) + 1) % 3,
                                a = (e + 2) % 3;
                            i = Math.sqrt(s[3 * e + e] - s[3 * r + r] - s[3 * a + a] + 1), t[e] = .5 * i, i = .5 / i, t[3] = (s[3 * r + a] - s[3 * a + r]) * i, t[r] = (s[3 * r + e] + s[3 * e + r]) * i, t[a] = (s[3 * a + e] + s[3 * e + a]) * i
                        }
                        return t
                    }
                    static fromEuler(e, t, s, r) {
                        var i = .5 * Math.PI / 180,
                            i = (t *= i, s *= i, r *= i, Math.sin(t)),
                            t = Math.cos(t),
                            a = Math.sin(s),
                            s = Math.cos(s),
                            n = Math.sin(r),
                            r = Math.cos(r);
                        return e[0] = i * s * r - t * a * n, e[1] = t * a * r + i * s * n, e[2] = t * s * n - i * a * r, e[3] = t * s * r + i * a * n, e
                    }
                    static toEuler(e, t) {
                        var s = t[0],
                            r = t[1],
                            i = t[2],
                            t = t[3],
                            a = Math.atan2(2 * (t * s + r * i), 1 - 2 * (s * s + r * r)),
                            n = 2 * (t * r - i * s),
                            n = 1 <= Math.abs(n) ? o.M.copySign(Math.PI / 2, n) : Math.asin(n),
                            t = Math.atan2(2 * (t * i + s * r), 1 - 2 * (r * r + i * i));
                        return e[0] = a, e[1] = n, e[2] = t, e
                    }
                    static toEulerDegrees(e, t) {
                        return (e = this.toEuler(e, t))[0] *= o.M.RAD2DEG, e[1] *= o.M.RAD2DEG, e[2] *= o.M.RAD2DEG, e
                    }
                    static fromEulerRad(e, t, s, r) {
                        t *= .5, s *= .5, r *= .5;
                        var i = Math.sin(t),
                            t = Math.cos(t),
                            a = Math.sin(s),
                            s = Math.cos(s),
                            n = Math.sin(r),
                            r = Math.cos(r);
                        return e[0] = i * s * r - t * a * n, e[1] = t * a * r + i * s * n, e[2] = t * s * n - i * a * r, e[3] = t * s * r + i * a * n, e
                    }
                    static str(e) {
                        return "quat(" + e[0] + ", " + e[1] + ", " + e[2] + ", " + e[3] + ")"
                    }
                }
                l.GLMAT_ARRAY_TYPE = Float32Array, l.tmpvec3 = a.R.create(), l.tmpmat3 = t.w.create(), l.temp1 = l.create(), l.temp2 = l.create(), l.copy = r.v.copy, l.set = r.v.set, l.add = r.v.add, l.mul = l.multiply, l.scale = r.v.scale, l.dot = r.v.dot, l.lerp = r.v.lerp, l.magnitude = r.v.magnitude, l.len = l.magnitude, l.squaredLength = r.v.squaredLength, l.sqrLen = l.squaredLength, l.normalize = r.v.normalize
            },
            9959: (e, t, s) => {
                s.d(t, {
                    j: () => h
                });
                var i = s(2671),
                    a = s(82),
                    n = s(7723);
                class r {
                    constructor(e, t, s) {
                        this._dirty = 1, this.vec = a.R.fromValues(e, t, s)
                    }
                    set x(e) {
                        this.vec[0] = e, this._dirty++, null != (e = this.onChange) && e.call(this)
                    }
                    set y(e) {
                        this.vec[1] = e, this._dirty++, null != (e = this.onChange) && e.call(this)
                    }
                    set z(e) {
                        this.vec[2] = e, this._dirty++, null != (e = this.onChange) && e.call(this)
                    }
                    set(e, t, s) {
                        this.vec[0] = e, this.vec[1] = t, this.vec[2] = s, this._dirty++, null != (e = this.onChange) && e.call(this)
                    }
                    copyFrom(e) {
                        this.vec[0] = e[0], this.vec[1] = e[1], this.vec[2] = e[2], this._dirty++, null != (e = this.onChange) && e.call(this)
                    }
                    get x() {
                        return this.vec[0]
                    }
                    get y() {
                        return this.vec[1]
                    }
                    get z() {
                        return this.vec[2]
                    }
                    get dirty() {
                        return this._dirty
                    }
                }
                var o = s(9816);
                class l {
                    constructor(e, t, s, r) {
                        this._dirty = 1, this.vec = o.v.fromValues(e, t, s, r)
                    }
                    set x(e) {
                        this.vec[0] = e, this._dirty++, null != (e = this.onChange) && e.call(this)
                    }
                    set y(e) {
                        this.vec[1] = e, this._dirty++, null != (e = this.onChange) && e.call(this)
                    }
                    set z(e) {
                        this.vec[2] = e, this._dirty++, null != (e = this.onChange) && e.call(this)
                    }
                    set w(e) {
                        this.vec[3] = e, this._dirty++, null != (e = this.onChange) && e.call(this)
                    }
                    set(e, t, s, r) {
                        this.vec[0] = e, this.vec[1] = t, this.vec[2] = s, this.vec[3] = r, this._dirty++, null != (e = this.onChange) && e.call(this)
                    }
                    copyFrom(e) {
                        this.vec[0] = e[0], this.vec[1] = e[1], this.vec[2] = e[2], this.vec[3] = e[3], this._dirty++, null != (e = this.onChange) && e.call(this)
                    }
                    get x() {
                        return this.vec[0]
                    }
                    get y() {
                        return this.vec[1]
                    }
                    get z() {
                        return this.vec[2]
                    }
                    get w() {
                        return this.vec[3]
                    }
                    get dirty() {
                        return this._dirty
                    }
                }
                class h extends class {
                    constructor(e) {
                        this._dirty = 1, this._mat = e || n._.create()
                    }
                    incDirty() {
                        this._dirty++
                    }
                    get dirty() {
                        return this._dirty
                    }
                    get mat() {
                        return this._mat
                    }
                } {
                    static fromMatrix(e) {
                        var t = new h;
                        return t.setFromMatrix(e), t
                    }
                    constructor() {
                        super(), this._dirtyCount = {
                            scale: 0,
                            rotation: 0,
                            translation: 0
                        }, this._onChange = () => {
                            var e;
                            null != (e = this.onChange) && e.call(this)
                        }, this.scale = new r(1, 1, 1), this.rotation = new l(0, 0, 0, 1), this.translation = new r(0, 0, 0), this.scale.onChange = this._onChange, this.rotation.onChange = this._onChange, this.translation.onChange = this._onChange
                    }
                    setUniformScale(e) {
                        this.scale.x = e, this.scale.y = e, this.scale.z = e
                    }
                    hasUniformScale() {
                        var e = this.scale;
                        return e.x === e.y && e.x === e.z
                    }
                    getNegativeScaleCount() {
                        let e = 0;
                        var t = this.scale;
                        return t.x < 0 && e++, t.y < 0 && e++, t.z < 0 && e++, e
                    }
                    isMirrored() {
                        return this.getNegativeScaleCount() % 2 == 1
                    }
                    setFromMatrix(e) {
                        var t = a.R.create(),
                            s = a.R.create(),
                            r = i.g.create();
                        n._.decomposeOld(r, s, t, e), this.scale.copyFrom(t), this.rotation.copyFrom(r), this.translation.copyFrom(s)
                    }
                    get dirty() {
                        return this.translation.dirty + this.scale.dirty + this.rotation.dirty
                    }
                    get translationDirty() {
                        return this.translation.dirty !== this._dirtyCount.translation
                    }
                    get scaleDirty() {
                        return this.scale.dirty !== this._dirtyCount.scale
                    }
                    get rotationDirty() {
                        return this.rotation.dirty !== this._dirtyCount.rotation
                    }
                    isIdentity() {
                        var e = this.scale;
                        return 1 === e.x && 1 === e.y && 1 === e.z && 0 === (e = this.translation).x && 0 === e.y && 0 === e.z && !!i.g.isIdentity(this.rotation.vec)
                    }
                    reset() {
                        this.scale.set(1, 1, 1), this.rotation.set(0, 0, 0, 1), this.translation.set(0, 0, 0)
                    }
                    setEuler(e, t, s) {
                        if (void 0 === e || void 0 === t || void 0 === s) {
                            const r = i.g.toEuler(a.R.create(), this.rotation.vec);
                            void 0 === e && (e = r[0]), void 0 === t && (t = r[1]), void 0 === s && (s = r[2])
                        }
                        const r = i.g.fromEulerRad(i.g.create(), e, t, s);
                        this.rotation.copyFrom(r)
                    }
                    get mat() {
                        this._mat = this._mat || n._.create();
                        var e = this._mat;
                        return !this.translationDirty || this.scaleDirty || this.rotationDirty ? (this.translationDirty || this.scaleDirty || this.rotationDirty) && (n._.fromRotationTranslationScale(this._mat, this.rotation.vec, this.translation.vec, this.scale.vec), this._dirtyCount.translation = this.translation.dirty, this._dirtyCount.scale = this.scale.dirty, this._dirtyCount.rotation = this.rotation.dirty) : (n._.setTranslation(e, this.translation.vec), this._dirtyCount.translation = this.translation.dirty), this._mat
                    }
                    clone() {
                        var e = new h;
                        return e.scale.copyFrom(this.scale.vec), e.rotation.copyFrom(this.rotation.vec), e.translation.copyFrom(this.translation.vec), e
                    }
                }
            },
            6438: (e, t, s) => {
                s.d(t, {
                    I: () => a
                });
                var r = s(3790),
                    i = s(9720);
                class a {
                    constructor() {
                        this.change = i.M.create(), this._scale = [1, 1], this._translation = [0, 0], this._rotation = 0, this._matDirty = !0, this._key = ""
                    }
                    clone() {
                        var e = new a;
                        return e.sx = this.sx, e.sy = this.sy, e.tx = this.tx, e.ty = this.ty, e.rotation = this.rotation, e
                    }
                    setUniformScale(e) {
                        var t = this._scale;
                        t[0] === e && t[1] === e || (this._scale[0] = e, this._scale[1] = e, this.onChange())
                    }
                    setScale(e) {
                        this._scale[0] === e[0] && this._scale[1] === e[1] || (this._scale[0] = e[0], this._scale[1] = e[1], this.onChange())
                    }
                    setTranslation(e) {
                        this._translation[0] === e[0] && this._translation[1] === e[1] || (this._translation[0] = e[0], this._translation[1] = e[1], this.onChange())
                    }
                    hasUniformScale() {
                        return this.sx === this.sy
                    }
                    set sx(e) {
                        this._scale[0] !== e && (this._scale[0] = e, this.onChange())
                    }
                    get sx() {
                        return this._scale[0]
                    }
                    set sy(e) {
                        this._scale[1] !== e && (this._scale[1] = e, this.onChange())
                    }
                    get sy() {
                        return this._scale[1]
                    }
                    get scale() {
                        return this._scale
                    }
                    set tx(e) {
                        this._translation[0] !== e && (this._translation[0] = e, this.onChange())
                    }
                    get tx() {
                        return this._translation[0]
                    }
                    set ty(e) {
                        this._translation[1] !== e && (this._translation[1] = e, this.onChange())
                    }
                    get ty() {
                        return this._translation[1]
                    }
                    get translation() {
                        return this._translation
                    }
                    set rotation(e) {
                        this._rotation !== e && (this._rotation = e, this.onChange())
                    }
                    get rotation() {
                        return this._rotation
                    }
                    onChange() {
                        this._key = "", this._matDirty = !0, this.change.dispatch(this)
                    }
                    isIdentity() {
                        var e = this._scale;
                        return 1 === e[0] && 1 === e[1] && 0 === (e = this._translation)[0] && 0 === e[1] && this.rotation % (2 * Math.PI) == 0
                    }
                    get mat() {
                        this._mat = this._mat || r.w.create();
                        var e = this._mat;
                        return this._matDirty && (r.w.identity(e), r.w.translate(e, e, this._translation), r.w.rotate(e, e, -this.rotation), r.w.scale(e, e, this._scale), this._matDirty = !1), this._mat
                    }
                    getKey() {
                        return this._key || (this._key = this.mat.toString()), this._key
                    }
                }
            },
            889: (e, t, s) => {
                s.d(t, {
                    K: () => r
                });
                class r {
                    static create() {
                        return new r.GLMAT_ARRAY_TYPE(2)
                    }
                    static clone(e) {
                        var t = new r.GLMAT_ARRAY_TYPE(2);
                        return t[0] = e[0], t[1] = e[1], t
                    }
                    static fromValues(e, t) {
                        var s = new r.GLMAT_ARRAY_TYPE(2);
                        return s[0] = e, s[1] = t, s
                    }
                    static copy(e, t) {
                        return e[0] = t[0], e[1] = t[1], e
                    }
                    static set(e, t, s) {
                        return e[0] = t, e[1] = s, e
                    }
                    static add(e, t, s) {
                        return e[0] = t[0] + s[0], e[1] = t[1] + s[1], e
                    }
                    static subtract(e, t, s) {
                        return e[0] = t[0] - s[0], e[1] = t[1] - s[1], e
                    }
                    static multiply(e, t, s) {
                        return e[0] = t[0] * s[0], e[1] = t[1] * s[1], e
                    }
                    static divide(e, t, s) {
                        return e[0] = t[0] / s[0], e[1] = t[1] / s[1], e
                    }
                    static min(e, t, s) {
                        return e[0] = Math.min(t[0], s[0]), e[1] = Math.min(t[1], s[1]), e
                    }
                    static max(e, t, s) {
                        return e[0] = Math.max(t[0], s[0]), e[1] = Math.max(t[1], s[1]), e
                    }
                    static scale(e, t, s) {
                        return e[0] = t[0] * s, e[1] = t[1] * s, e
                    }
                    static scaleAndAdd(e, t, s, r) {
                        return e[0] = t[0] + s[0] * r, e[1] = t[1] + s[1] * r, e
                    }
                    static distance(e, t) {
                        var s = t[0] - e[0],
                            t = t[1] - e[1];
                        return Math.sqrt(s * s + t * t)
                    }
                    static squaredDistance(e, t) {
                        var s = t[0] - e[0],
                            t = t[1] - e[1];
                        return s * s + t * t
                    }
                    static magnitude(e) {
                        var t = e[0],
                            e = e[1];
                        return Math.sqrt(t * t + e * e)
                    }
                    static squaredLength(e) {
                        var t = e[0],
                            e = e[1];
                        return t * t + e * e
                    }
                    static negate(e, t) {
                        return e[0] = -t[0], e[1] = -t[1], e
                    }
                    static inverse(e, t) {
                        return e[0] = 1 / t[0], e[1] = 1 / t[1], e
                    }
                    static normalize(e, t) {
                        var s = t[0],
                            r = t[1],
                            s = s * s + r * r;
                        return 0 < s && (s = 1 / Math.sqrt(s), e[0] = t[0] * s, e[1] = t[1] * s), e
                    }
                    static dot(e, t) {
                        return e[0] * t[0] + e[1] * t[1]
                    }
                    static cross(e, t, s) {
                        t = t[0] * s[1] - t[1] * s[0];
                        return e[0] = e[1] = 0, e[2] = t, e
                    }
                    static lerp(e, t, s, r) {
                        var i = t[0],
                            t = t[1];
                        return e[0] = i + r * (s[0] - i), e[1] = t + r * (s[1] - t), e
                    }
                    static transformMat2(e, t, s) {
                        var r = t[0],
                            t = t[1];
                        return e[0] = s[0] * r + s[2] * t, e[1] = s[1] * r + s[3] * t, e
                    }
                    static transformMat2d(e, t, s) {
                        var r = t[0],
                            t = t[1];
                        return e[0] = s[0] * r + s[2] * t + s[4], e[1] = s[1] * r + s[3] * t + s[5], e
                    }
                    static transformMat3(e, t, s) {
                        var r = t[0],
                            t = t[1];
                        return e[0] = s[0] * r + s[3] * t + s[6], e[1] = s[1] * r + s[4] * t + s[7], e
                    }
                    static transformMat4(e, t, s) {
                        var r = t[0],
                            t = t[1];
                        return e[0] = s[0] * r + s[4] * t + s[12], e[1] = s[1] * r + s[5] * t + s[13], e
                    }
                    static rotate(e, t, s, r) {
                        var i = t[0] - s[0],
                            t = t[1] - s[1],
                            a = Math.sin(r),
                            r = Math.cos(r);
                        return e[0] = i * r - t * a + s[0], e[1] = i * a + t * r + s[1], e
                    }
                    static str(e) {
                        return "vec2(" + e[0] + ", " + e[1] + ")"
                    }
                }
                r.GLMAT_ARRAY_TYPE = Float32Array, r.sub = r.subtract, r.mul = r.multiply, r.div = r.divide, r.dist = r.distance, r.sqrDist = r.squaredDistance, r.len = r.magnitude, r.sqrLen = r.squaredLength
            },
            82: (e, t, s) => {
                s.d(t, {
                    R: () => h
                });
                var r = s(3790);
                class h {
                    static create() {
                        return new h.GLMAT_ARRAY_TYPE(3)
                    }
                    static clone(e) {
                        var t = new h.GLMAT_ARRAY_TYPE(3);
                        return t[0] = e[0], t[1] = e[1], t[2] = e[2], t
                    }
                    static fromValues(e, t, s) {
                        var r = new h.GLMAT_ARRAY_TYPE(3);
                        return r[0] = e, r[1] = t, r[2] = s, r
                    }
                    static fromVec4(e) {
                        var t = new h.GLMAT_ARRAY_TYPE(3);
                        return t[0] = e[0] / e[3], t[1] = e[1] / e[3], t[2] = e[2] / e[3], t
                    }
                    static copy(e, t) {
                        return e[0] = t[0], e[1] = t[1], e[2] = t[2], e
                    }
                    static set(e, t, s, r) {
                        return e[0] = t, e[1] = s, e[2] = r, e
                    }
                    static add(e, t, s) {
                        return e[0] = t[0] + s[0], e[1] = t[1] + s[1], e[2] = t[2] + s[2], e
                    }
                    static subtract(e, t, s) {
                        return e[0] = t[0] - s[0], e[1] = t[1] - s[1], e[2] = t[2] - s[2], e
                    }
                    static multiply(e, t, s) {
                        return e[0] = t[0] * s[0], e[1] = t[1] * s[1], e[2] = t[2] * s[2], e
                    }
                    static mul_3x1_1x3(e, t, s) {
                        return (e = e || r.w.zero())[0] = t[0] * s[0], e[1] = t[0] * s[1], e[2] = t[0] * s[2], e[3] = t[1] * s[0], e[4] = t[1] * s[1], e[5] = t[1] * s[2], e[6] = t[2] * s[0], e[7] = t[2] * s[1], e[8] = t[2] * s[2], e
                    }
                    static divide(e, t, s) {
                        return e[0] = t[0] / s[0], e[1] = t[1] / s[1], e[2] = t[2] / s[2], e
                    }
                    static min(e, t, s) {
                        return e[0] = Math.min(t[0], s[0]), e[1] = Math.min(t[1], s[1]), e[2] = Math.min(t[2], s[2]), e
                    }
                    static max(e, t, s) {
                        return e[0] = Math.max(t[0], s[0]), e[1] = Math.max(t[1], s[1]), e[2] = Math.max(t[2], s[2]), e
                    }
                    static scale(e, t, s) {
                        return e[0] = t[0] * s, e[1] = t[1] * s, e[2] = t[2] * s, e
                    }
                    static scaleAndAdd(e, t, s, r) {
                        return e[0] = t[0] + s[0] * r, e[1] = t[1] + s[1] * r, e[2] = t[2] + s[2] * r, e
                    }
                    static distance(e, t) {
                        var s = t[0] - e[0],
                            r = t[1] - e[1],
                            t = t[2] - e[2];
                        return Math.sqrt(s * s + r * r + t * t)
                    }
                    static squaredDistance(e, t) {
                        var s = t[0] - e[0],
                            r = t[1] - e[1],
                            t = t[2] - e[2];
                        return s * s + r * r + t * t
                    }
                    static magnitude(e) {
                        var t = e[0],
                            s = e[1],
                            e = e[2];
                        return Math.sqrt(t * t + s * s + e * e)
                    }
                    static squaredLength(e) {
                        var t = e[0],
                            s = e[1],
                            e = e[2];
                        return t * t + s * s + e * e
                    }
                    static negate(e, t) {
                        return e[0] = -t[0], e[1] = -t[1], e[2] = -t[2], e
                    }
                    static inverse(e, t) {
                        return e[0] = 1 / t[0], e[1] = 1 / t[1], e[2] = 1 / t[2], e
                    }
                    static normalize(e, t) {
                        var s = t[0],
                            r = t[1],
                            i = t[2],
                            s = s * s + r * r + i * i;
                        return 0 < s && (s = 1 / Math.sqrt(s), e[0] = t[0] * s, e[1] = t[1] * s, e[2] = t[2] * s), e
                    }
                    static dot(e, t) {
                        return e[0] * t[0] + e[1] * t[1] + e[2] * t[2]
                    }
                    static cross(e, t, s) {
                        var r = t[0],
                            i = t[1],
                            t = t[2],
                            a = s[0],
                            n = s[1],
                            s = s[2];
                        return e[0] = i * s - t * n, e[1] = t * a - r * s, e[2] = r * n - i * a, e
                    }
                    static lerp(e, t, s, r) {
                        var i = t[0],
                            a = t[1],
                            t = t[2];
                        return e[0] = i + r * (s[0] - i), e[1] = a + r * (s[1] - a), e[2] = t + r * (s[2] - t), e
                    }
                    static transformMat4(e, t, s) {
                        var r = t[0],
                            i = t[1],
                            t = t[2],
                            a = s[3] * r + s[7] * i + s[11] * t + s[15];
                        return e[0] = (s[0] * r + s[4] * i + s[8] * t + s[12]) / (a = a || 1), e[1] = (s[1] * r + s[5] * i + s[9] * t + s[13]) / a, e[2] = (s[2] * r + s[6] * i + s[10] * t + s[14]) / a, e
                    }
                    static transformMat3(e, t, s) {
                        var r = t[0],
                            i = t[1],
                            t = t[2];
                        return e[0] = r * s[0] + i * s[3] + t * s[6], e[1] = r * s[1] + i * s[4] + t * s[7], e[2] = r * s[2] + i * s[5] + t * s[8], e
                    }
                    static transformQuat(e, t, s) {
                        var r = t[0],
                            i = t[1],
                            t = t[2],
                            a = s[0],
                            n = s[1],
                            o = s[2],
                            s = s[3],
                            l = s * r + n * t - o * i,
                            h = s * i + o * r - a * t,
                            c = s * t + a * i - n * r,
                            r = -a * r - n * i - o * t;
                        return e[0] = l * s + r * -a + h * -o - c * -n, e[1] = h * s + r * -n + c * -a - l * -o, e[2] = c * s + r * -o + l * -n - h * -a, e
                    }
                    static rotateX(e, t, s, r) {
                        var i = [],
                            a = [];
                        return i[0] = t[0] - s[0], i[1] = t[1] - s[1], i[2] = t[2] - s[2], a[0] = i[0], a[1] = i[1] * Math.cos(r) - i[2] * Math.sin(r), a[2] = i[1] * Math.sin(r) + i[2] * Math.cos(r), e[0] = a[0] + s[0], e[1] = a[1] + s[1], e[2] = a[2] + s[2], e
                    }
                    static rotateY(e, t, s, r) {
                        var i = [],
                            a = [];
                        return i[0] = t[0] - s[0], i[1] = t[1] - s[1], i[2] = t[2] - s[2], a[0] = i[2] * Math.sin(r) + i[0] * Math.cos(r), a[1] = i[1], a[2] = i[2] * Math.cos(r) - i[0] * Math.sin(r), e[0] = a[0] + s[0], e[1] = a[1] + s[1], e[2] = a[2] + s[2], e
                    }
                    static rotateZ(e, t, s, r) {
                        var i = [],
                            a = [];
                        return i[0] = t[0] - s[0], i[1] = t[1] - s[1], i[2] = t[2] - s[2], a[0] = i[0] * Math.cos(r) - i[1] * Math.sin(r), a[1] = i[0] * Math.sin(r) + i[1] * Math.cos(r), a[2] = i[2], e[0] = a[0] + s[0], e[1] = a[1] + s[1], e[2] = a[2] + s[2], e
                    }
                    static forEach(e, t, s, r, i, a) {
                        let n, o;
                        var l = h._temp1;
                        for (t = t || 3, s = s || 0, o = r ? Math.min(r * t + s, e.length) : e.length, n = s; n < o; n += t) l[0] = e[n], l[1] = e[n + 1], l[2] = e[n + 2], i(l, l, a), e[n] = l[0], e[n + 1] = l[1], e[n + 2] = l[2];
                        return e
                    }
                    static angle(e, t) {
                        e = h.fromValues(e[0], e[1], e[2]), t = h.fromValues(t[0], t[1], t[2]), h.normalize(e, e), h.normalize(t, t), e = h.dot(e, t);
                        return 1 < e ? 0 : Math.acos(e)
                    }
                    static str(e) {
                        return "vec3(" + e[0] + ", " + e[1] + ", " + e[2] + ")"
                    }
                }
                h.GLMAT_ARRAY_TYPE = Float32Array, h.sub = h.subtract, h.mul = h.multiply, h.div = h.divide, h.dist = h.distance, h.sqrDist = h.squaredDistance, h.len = h.magnitude, h.sqrLen = h.squaredLength, h._temp1 = h.create()
            },
            9816: (e, t, s) => {
                s.d(t, {
                    v: () => a
                });
                var r = s(82);
                class a {
                    static create() {
                        return new a.GLMAT_ARRAY_TYPE(4)
                    }
                    static clone(e) {
                        var t = new a.GLMAT_ARRAY_TYPE(4);
                        return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t
                    }
                    static fromValues(e, t, s, r) {
                        var i = new a.GLMAT_ARRAY_TYPE(4);
                        return i[0] = e, i[1] = t, i[2] = s, i[3] = r, i
                    }
                    static fromVec3(e, t = 1) {
                        var s = new a.GLMAT_ARRAY_TYPE(4);
                        return s[0] = e[0], s[1] = e[1], s[2] = e[2], s[3] = t, s
                    }
                    static copy(e, t) {
                        return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e
                    }
                    static set(e, t, s, r, i) {
                        return e[0] = t, e[1] = s, e[2] = r, e[3] = i, e
                    }
                    static add(e, t, s) {
                        return e[0] = t[0] + s[0], e[1] = t[1] + s[1], e[2] = t[2] + s[2], e[3] = t[3] + s[3], e
                    }
                    static subtract(e, t, s) {
                        return e[0] = t[0] - s[0], e[1] = t[1] - s[1], e[2] = t[2] - s[2], e[3] = t[3] - s[3], e
                    }
                    static multiply(e, t, s) {
                        return e[0] = t[0] * s[0], e[1] = t[1] * s[1], e[2] = t[2] * s[2], e[3] = t[3] * s[3], e
                    }
                    static divide(e, t, s) {
                        return e[0] = t[0] / s[0], e[1] = t[1] / s[1], e[2] = t[2] / s[2], e[3] = t[3] / s[3], e
                    }
                    static min(e, t, s) {
                        return e[0] = Math.min(t[0], s[0]), e[1] = Math.min(t[1], s[1]), e[2] = Math.min(t[2], s[2]), e[3] = Math.min(t[3], s[3]), e
                    }
                    static max(e, t, s) {
                        return e[0] = Math.max(t[0], s[0]), e[1] = Math.max(t[1], s[1]), e[2] = Math.max(t[2], s[2]), e[3] = Math.max(t[3], s[3]), e
                    }
                    static scale(e, t, s) {
                        return e[0] = t[0] * s, e[1] = t[1] * s, e[2] = t[2] * s, e[3] = t[3] * s, e
                    }
                    static scaleAndAdd(e, t, s, r) {
                        return e[0] = t[0] + s[0] * r, e[1] = t[1] + s[1] * r, e[2] = t[2] + s[2] * r, e[3] = t[3] + s[3] * r, e
                    }
                    static distance(e, t) {
                        var s = t[0] - e[0],
                            r = t[1] - e[1],
                            i = t[2] - e[2],
                            t = t[3] - e[3];
                        return Math.sqrt(s * s + r * r + i * i + t * t)
                    }
                    static squaredDistance(e, t) {
                        var s = t[0] - e[0],
                            r = t[1] - e[1],
                            i = t[2] - e[2],
                            t = t[3] - e[3];
                        return s * s + r * r + i * i + t * t
                    }
                    static magnitude(e) {
                        var t = e[0],
                            s = e[1],
                            r = e[2],
                            e = e[3];
                        return Math.sqrt(t * t + s * s + r * r + e * e)
                    }
                    static squaredLength(e) {
                        var t = e[0],
                            s = e[1],
                            r = e[2],
                            e = e[3];
                        return t * t + s * s + r * r + e * e
                    }
                    static negate(e, t) {
                        return e[0] = -t[0], e[1] = -t[1], e[2] = -t[2], e[3] = -t[3], e
                    }
                    static inverse(e, t) {
                        return e[0] = 1 / t[0], e[1] = 1 / t[1], e[2] = 1 / t[2], e[3] = 1 / t[3], e
                    }
                    static normalize(e, t) {
                        var s = t[0],
                            r = t[1],
                            i = t[2],
                            a = t[3],
                            s = s * s + r * r + i * i + a * a;
                        return 0 < s && (s = 1 / Math.sqrt(s), e[0] = t[0] * s, e[1] = t[1] * s, e[2] = t[2] * s, e[3] = t[3] * s), e
                    }
                    static dot(e, t) {
                        return e[0] * t[0] + e[1] * t[1] + e[2] * t[2] + e[3] * t[3]
                    }
                    static lerp(e, t, s, r) {
                        var i = t[0],
                            a = t[1],
                            n = t[2],
                            t = t[3];
                        return e[0] = i + r * (s[0] - i), e[1] = a + r * (s[1] - a), e[2] = n + r * (s[2] - n), e[3] = t + r * (s[3] - t), e
                    }
                    static transformMat4(e, t, s) {
                        var r = t[0],
                            i = t[1],
                            a = t[2],
                            t = t[3];
                        return e[0] = s[0] * r + s[4] * i + s[8] * a + s[12] * t, e[1] = s[1] * r + s[5] * i + s[9] * a + s[13] * t, e[2] = s[2] * r + s[6] * i + s[10] * a + s[14] * t, e[3] = s[3] * r + s[7] * i + s[11] * a + s[15] * t, e
                    }
                    static transformDirection(e, t, s) {
                        return a.transformMat4(e, t, s), r.R.normalize(e, e), e
                    }
                    static transformQuat(e, t, s) {
                        var r = t[0],
                            i = t[1],
                            t = t[2],
                            a = s[0],
                            n = s[1],
                            o = s[2],
                            s = s[3],
                            l = s * r + n * t - o * i,
                            h = s * i + o * r - a * t,
                            c = s * t + a * i - n * r,
                            r = -a * r - n * i - o * t;
                        return e[0] = l * s + r * -a + h * -o - c * -n, e[1] = h * s + r * -n + c * -a - l * -o, e[2] = c * s + r * -o + l * -n - h * -a, e
                    }
                    static str(e) {
                        return "vec4(" + e[0] + ", " + e[1] + ", " + e[2] + ", " + e[3] + ")"
                    }
                }
                a.GLMAT_ARRAY_TYPE = Float32Array, a.sub = a.subtract, a.mul = a.subtract, a.div = a.divide, a.dist = a.distance, a.sqrDist = a.squaredDistance, a.len = a.magnitude, a.sqrLen = a.squaredLength
            },
            1695: (e, t, s) => {
                s.d(t, {
                    t: () => o
                });
                var a = s(1201),
                    n = s(6407),
                    r = s(3829),
                    i = s(6017);
                class o {
                    constructor(e) {
                        this._buffer = e.buffer, this._attributes = this.initAttributes(e.attributes), this.updateAttributesCount()
                    }
                    initAttributes(e) {
                        var t = [];
                        let s = !1;
                        for (const i of e) {
                            !s && 0 < e.length && !n.M.isPositiveOrZero(i.byteStride) && (s = !0);
                            var r = {
                                name: i.name || "",
                                semantic: i.semantic,
                                size: i.size || 3,
                                sizeY: i.sizeY || 1,
                                componentType: i.componentType || a.g.FLOAT,
                                byteOffset: i.byteOffset || 0,
                                byteStride: i.byteStride || 0,
                                normalized: i.normalized || !1,
                                count: i.count || 0,
                                buffer: this._buffer
                            };
                            t.push(r)
                        }
                        return s && this.calculateInterleavedAttributes(t), t
                    }
                    calculateInterleavedAttributes(e) {
                        let t, s = 0;
                        for (const t of e) t.byteOffset = s, s += r.oY.getAttributeByteSize(t);
                        t = s;
                        for (const s of e) s.byteStride = t
                    }
                    updateAttributesCount() {
                        for (const e of this._attributes) 0 < e.count || (e.count = this.count)
                    }
                    get count() {
                        return this._count || (this._count = this.getVertexCount()), this._count
                    }
                    getVertexCount() {
                        var e = null == (e = this._attributes[0]) ? void 0 : e.count;
                        if (e) return e; {
                            const e = this._attributes[0].byteStride;
                            return n.M.isPositiveOrZero(e) || console.warn("byteStride at this point should already be set!"), this._buffer.data.byteLength / e
                        }
                    }
                    isInterleaved() {
                        return i.B.forEachPair(this.attributes, (e, t) => {
                            if (Math.abs(e.byteOffset - t.byteOffset) > this.buffer.byteStride) return !0
                        })
                    }
                    getBytesPerVertex() {
                        return n.M.sum(this.attributes, e => r.oY.getAttributeByteSize(e))
                    }
                    getByteStrideAligned() {
                        return r.oY.ensureByteStrideAlignment(this.getBytesPerVertex())
                    }
                    get buffer() {
                        return this._buffer
                    }
                    get attributes() {
                        return this._attributes
                    }
                    get byteStride() {
                        return this._attributes[0].byteStride || 0
                    }
                    clone() {
                        const t = this._buffer.clone();
                        return new o({
                            buffer: t,
                            attributes: this._attributes.map(e => ({ ...e,
                                buffer: t
                            }))
                        })
                    }
                }
            },
            428: (e, t, s) => {
                s.d(t, {
                    f: () => a
                });
                var r = s(1201),
                    i = s(7934);
                class a {
                    constructor(e) {
                        var t;
                        this.id = ++a.highestId, this.name = "", e = i.g.mergeConfig(a.defaultConfig, e), this._config = e, this.target = null != (t = e.target) ? t : r.g.ARRAY_BUFFER, this.data = e.data, this.name = e.name || ""
                    }
                    get arrayBuffer() {
                        return this.data instanceof ArrayBuffer ? this.data : this.data.buffer
                    }
                    get byteStride() {
                        var e;
                        return null != (e = this._config.byteStride) ? e : 0
                    }
                    clone() {
                        return new a({
                            data: this.data.slice(),
                            byteStride: this.byteStride,
                            target: this.target,
                            usage: this._config.usage,
                            keepData: this._config.keepData,
                            name: this.name
                        })
                    }
                }
                a.highestId = 0, a.defaultConfig = {
                    data: null,
                    target: r.g.ARRAY_BUFFER,
                    usage: r.g.STATIC_DRAW,
                    keepData: !0
                }
            },
            604: (e, t, s) => {
                s.d(t, {
                    Z: () => h
                });
                var i = s(1695),
                    r = s(1201),
                    a = s(4735),
                    n = s(6017),
                    o = s(6407),
                    l = s(3829);
                class h {
                    constructor(e) {
                        var t;
                        this.id = ++h.highestId, this.name = "", this.dataVersion = 0, this._indexBuffer = e.indexBuffer, this._buffers = e.buffers, this.mode = null != (t = e.mode) ? t : r.g.TRIANGLES, this.start = null != (t = e.start) ? t : 0, this._count = e.count
                    }
                    getAttributes() {
                        return this._buffers.flatMap(e => e.attributes)
                    }
                    getAttributesWithBuffers() {
                        return this._buffers.flatMap(t => t.attributes.map(e => ({
                            attribute: e,
                            buffer: t
                        })))
                    }
                    removeAttribute(t) {
                        if (this.getAttribute(t)) {
                            var s = this._buffers.find(e => e.attributes.some(e => e.semantic === t));
                            if (s) {
                                if (1 === s.attributes.length) n.B.removeMutable(this._buffers, s);
                                else {
                                    var r = s.attributes.find(e => e.semantic === t);
                                    if (r) {
                                        let e = n.B.removeMutable(s.attributes, r);
                                        e = e.map(e => ({ ...e
                                        })), n.B.replaceMutable(this._buffers, s, new i.t({
                                            buffer: s.buffer,
                                            attributes: e
                                        }))
                                    }
                                }
                                this._shortestBuffer = void 0, this.dataVersion++
                            }
                        }
                    }
                    getUVChannels() {
                        var e = [];
                        for (const s of this.getAttributes()) {
                            var t = s.semantic;
                            t && 0 === t.indexOf(a.p.TEXCOORD_BASE) && (t = Number(t.split("_")[1]), e.push(t))
                        }
                        return e
                    }
                    get count() {
                        var e;
                        return this._count || ((e = 0) < (e = this.indexBuffer ? this.indexBuffer.count : this.shortestBufferCount) || console.warn("length should be > 0!"), e)
                    }
                    get vertexCount() {
                        return this.shortestBufferCount
                    }
                    get shortestBufferCount() {
                        return this.getShortestBuffer().count
                    }
                    getShortestBuffer() {
                        return this._shortestBuffer || (this._shortestBuffer = this.findShortestBuffer()), this._shortestBuffer
                    }
                    findShortestBuffer() {
                        var t = this.buffers;
                        let s = t[0],
                            r = s.count;
                        for (let e = 1; e < t.length; ++e) {
                            var i = t[e],
                                a = i.count;
                            a < r && (r = a, s = i)
                        }
                        return s
                    }
                    getAttribute(t) {
                        return this.getAttributes().find(e => e.semantic === t)
                    }
                    hasAttribute(t) {
                        return !!this.getAttributes().find(e => e.semantic === t)
                    }
                    isInterleaved() {
                        return this.buffers.some(e => e.isInterleaved())
                    }
                    getBytesPerVertex() {
                        return o.M.sum(this.getAttributes(), e => l.oY.getAttributeByteSize(e))
                    }
                    getTotalVertexByteSize() {
                        return this.vertexCount * this.getBytesPerVertex()
                    }
                    getVertexByteSizeAligned() {
                        var e = o.M.sum(this.buffers, e => e.getByteStrideAligned());
                        return this.vertexCount * e
                    }
                    getIndexByteSize() {
                        return this.indexBuffer ? this.count * l._Z[this.indexBuffer.componentType] : 0
                    }
                    getTotalByteSize() {
                        return this.getVertexByteSizeAligned() + this.getIndexByteSize()
                    }
                    get indexBuffer() {
                        return this._indexBuffer
                    }
                    get buffers() {
                        return this._buffers
                    }
                    set count(e) {
                        this._count = e
                    }
                    clone() {
                        var e = this.buffers.map(e => e.clone());
                        return new h({
                            buffers: e,
                            indexBuffer: null == (e = this.indexBuffer) ? void 0 : e.clone(),
                            mode: this.mode,
                            start: this.start,
                            count: this.count
                        })
                    }
                    dispose() {}
                }
                h.highestId = 0
            },
            5216: (e, t, s) => {
                s.d(t, {
                    Y: () => n
                });
                var r = s(428),
                    i = s(3829),
                    a = s(1201);
                class n {
                    static fromData(e, t = "") {
                        return new n({
                            name: t,
                            buffer: new r.f({
                                data: e,
                                target: a.g.ELEMENT_ARRAY_BUFFER
                            }),
                            count: e.length
                        })
                    }
                    constructor(e) {
                        var t;
                        this.name = e.name || "", this.buffer = e.buffer, this.componentType = null != (t = e.componentType) ? t : i.oY.findIndexComponentTypeFromData(e.buffer.data), this.byteOffset = null != (t = e.byteOffset) ? t : 0, this.count = e.count
                    }
                    get data() {
                        var e, t;
                        return this._data || (e = i.oY.getClassForType(this.componentType), t = this.buffer.data.byteOffset + this.byteOffset, this._data = new e(this.buffer.data.buffer, t, this.count)), this._data
                    }
                    clone() {
                        return new n({
                            name: this.name,
                            buffer: this.buffer.clone(),
                            byteOffset: this.byteOffset,
                            componentType: this.componentType,
                            count: this.count
                        })
                    }
                }
            },
            4735: (e, t, s) => {
                s.d(t, {
                    p: () => r
                });
                class r {
                    static getTexCoord(e) {
                        return r.TEXCOORD_BASE + "_" + e
                    }
                    static decomposeTexCoord(e) {
                        e = e.split("_");
                        return {
                            semantic: e[0],
                            index: Number(e[1])
                        }
                    }
                    static isTexCoord(e) {
                        return 0 === (null == e ? void 0 : e.indexOf(this.TEXCOORD_BASE))
                    }
                    static getMorph(e, t) {
                        return r.MORPH_PREFIX + e + "_" + t
                    }
                    static decomposeMorph(e) {
                        e = e.split("_");
                        return {
                            semantic: e[1].toLowerCase(),
                            index: Number(e[2])
                        }
                    }
                }
                r.POSITION = "POSITION", r.NORMAL = "NORMAL", r.TANGENT = "TANGENT", r.COLOR = "COLOR_0", r.TEXCOORD_BASE = "TEXCOORD", r.TEXCOORD_0 = "TEXCOORD_0", r.TEXCOORD_1 = "TEXCOORD_1", r.TEXCOORD_2 = "TEXCOORD_2", r.TEXCOORD_3 = "TEXCOORD_3", r.TEXCOORD_4 = "TEXCOORD_4", r.TEXCOORD_5 = "TEXCOORD_5", r.TEXCOORD_6 = "TEXCOORD_6", r.TEXCOORD_7 = "TEXCOORD_7", r.JOINTS_0 = "JOINTS_0", r.WEIGHTS_0 = "WEIGHTS_0", r.MORPH_PREFIX = "MORPH_"
            },
            1219: (e, t, s) => {
                s.d(t, {
                    c: () => r
                });
                var i = s(3829);
                class r {
                    constructor(e) {
                        this.byteOffset = 0, this.buffer = new ArrayBuffer(e), this.dataView = new DataView(this.buffer)
                    }
                    writeUint8(e) {
                        this.dataView.setUint8(this.byteOffset, e), this.byteOffset += 1
                    }
                    writeUint16(e) {
                        this.dataView.setUint16(this.byteOffset, e, !0), this.byteOffset += 2
                    }
                    writeUint32(e) {
                        this.dataView.setUint32(this.byteOffset, e, !0), this.byteOffset += 4
                    }
                    writeInt32(e) {
                        this.dataView.setInt32(this.byteOffset, e, !0), this.byteOffset += 4
                    }
                    writeFloat32(e) {
                        this.dataView.setFloat32(this.byteOffset, e, !0), this.byteOffset += 4
                    }
                    writeVec(t, s = t.length) {
                        for (let e = 0; e < s; ++e) this.writeFloat32(t[e])
                    }
                    write(e, t, s = this.byteOffset) {
                        var r = i.rg[t];
                        r && (r.call(this.dataView, s, e, !0), r = i._Z[t], this.byteOffset += r)
                    }
                }
            },
            8706: (e, t, s) => {
                s.d(t, {
                    s: () => h
                });
                var n = s(3829),
                    r = s(82),
                    i = s(9816),
                    a = s(889),
                    o = s(8255),
                    l = s(1219);
                class h {
                    static createReaders(e) {
                        return e.getAttributes().map(e => new h(e))
                    }
                    static readIntoTypedArray(e, r) {
                        const i = e.getAttribute(r),
                            t = e.buffers.find(e => e.attributes.find(e => e.semantic === r));
                        if (i && t) {
                            const r = new h(i),
                                t = e.vertexCount * n.oY.getAttributeByteSize(i),
                                a = new l.c(t);
                            return o.O.iterateIndexedVerticesOnce(e, t => {
                                for (let e = 0; e < i.size; ++e) {
                                    var s = r.readAt(t, e);
                                    a.write(s, i.componentType)
                                }
                            }), new n.eE[i.componentType](a.buffer)
                        }
                        return null
                    }
                    constructor(e) {
                        this.attribute = e, this._componentType = e.componentType, this._getter = n._s[e.componentType], this._byteOffset = e.byteOffset || 0, this._bytesPerComponent = n.oY.getBytesForType(e.componentType), this._byteStride = e.byteStride || e.size * this._bytesPerComponent;
                        e = e.buffer.data;
                        this._dataView = new DataView(e.buffer, e.byteOffset, e.byteLength)
                    }
                    readAt(e, t) {
                        e *= this._byteStride;
                        return this._getter.call(this._dataView, this._byteOffset + e + t * this._bytesPerComponent, !0)
                    }
                    writeAt(e, t, s) {
                        var r = n.rg[this._componentType],
                            e = e * this._byteStride;
                        r.call(this._dataView, this._byteOffset + e + t * this._bytesPerComponent, s, !0)
                    }
                    readToVec(t, s = i.v.create()) {
                        for (let e = 0; e < this.attribute.size; ++e) s[e] = this.readAt(t, e);
                        return s
                    }
                    writeVec(t, s) {
                        for (let e = 0; e < this.attribute.size; ++e) this.writeAt(t, e, s[e])
                    }
                    readToVec2(e, t = a.K.create()) {
                        return t[0] = this.readAt(e, 0), t[1] = this.readAt(e, 1), t
                    }
                    readToVec3(e, t = r.R.create()) {
                        return t[0] = this.readAt(e, 0), t[1] = this.readAt(e, 1), t[2] = this.readAt(e, 2), t
                    }
                    readToVec4(e, t = i.v.create()) {
                        return t[0] = this.readAt(e, 0), t[1] = this.readAt(e, 1), t[2] = this.readAt(e, 2), t[3] = this.readAt(e, 3), t
                    }
                    readPointToVec4(e, t = i.v.create()) {
                        return t[0] = this.readAt(e, 0), t[1] = this.readAt(e, 1), t[2] = this.readAt(e, 2), t[3] = 1, t
                    }
                    readNormalToVec4(e, t = i.v.create()) {
                        return t[0] = this.readAt(e, 0), t[1] = this.readAt(e, 1), t[2] = this.readAt(e, 2), t[3] = 0, t
                    }
                    writeVec3(e, t) {
                        this.writeAt(e, 0, t[0]), this.writeAt(e, 1, t[1]), this.writeAt(e, 2, t[2])
                    }
                }
            },
            3829: (e, t, s) => {
                s.d(t, {
                    _Z: () => o,
                    _s: () => i,
                    eE: () => n,
                    oY: () => l,
                    rg: () => a
                });
                var r = s(1201);
                const i = {
                        [r.g.UNSIGNED_BYTE]: DataView.prototype.getUint8,
                        [r.g.UNSIGNED_SHORT]: DataView.prototype.getUint16,
                        [r.g.UNSIGNED_INT]: DataView.prototype.getUint32,
                        [r.g.BYTE]: DataView.prototype.getInt8,
                        [r.g.SHORT]: DataView.prototype.getInt16,
                        [r.g.INT]: DataView.prototype.getInt32,
                        [r.g.FLOAT]: DataView.prototype.getFloat32
                    },
                    a = {
                        [r.g.UNSIGNED_BYTE]: DataView.prototype.setUint8,
                        [r.g.UNSIGNED_SHORT]: DataView.prototype.setUint16,
                        [r.g.UNSIGNED_INT]: DataView.prototype.setUint32,
                        [r.g.BYTE]: DataView.prototype.setInt8,
                        [r.g.SHORT]: DataView.prototype.setInt16,
                        [r.g.INT]: DataView.prototype.setInt32,
                        [r.g.FLOAT]: DataView.prototype.setFloat32
                    },
                    n = {
                        [r.g.BYTE]: Int8Array,
                        [r.g.UNSIGNED_BYTE]: Uint8Array,
                        [r.g.SHORT]: Int16Array,
                        [r.g.UNSIGNED_SHORT]: Uint16Array,
                        [r.g.INT]: Int32Array,
                        [r.g.UNSIGNED_INT]: Uint32Array,
                        [r.g.FLOAT]: Float32Array
                    },
                    o = {
                        [r.g.BYTE]: 1,
                        [r.g.UNSIGNED_BYTE]: 1,
                        [r.g.SHORT]: 2,
                        [r.g.UNSIGNED_SHORT]: 2,
                        [r.g.INT]: 4,
                        [r.g.UNSIGNED_INT]: 4,
                        [r.g.FLOAT]: 4
                    };
                class l {
                    static getBytesForType(e) {
                        var t = o[e];
                        if (void 0 === t) throw new Error("This type is not recognized:" + e);
                        return t
                    }
                    static getAttributeByteSize(e) {
                        return e.size * (e.sizeY || 1) * l.getBytesForType(e.componentType)
                    }
                    static getClassForType(e) {
                        var t = n[e];
                        if (void 0 === t) throw new Error("This type is not recognized:" + e);
                        return t
                    }
                    static findComponentTypeForClass(e) {
                        for (const t in n)
                            if (n[t] === e) return Number(t);
                        throw new Error("This arrayType is not recognized:" + e)
                    }
                    static findIndexComponentTypeFromData(e) {
                        e = this.findComponentTypeFromData(e);
                        return {
                            [r.g.BYTE]: r.g.UNSIGNED_BYTE,
                            [r.g.SHORT]: r.g.UNSIGNED_SHORT,
                            [r.g.INT]: r.g.UNSIGNED_INT
                        }[e] || e
                    }
                    static findComponentTypeFromData(e) {
                        return this.findComponentTypeForClass(e.constructor)
                    }
                    static getClassForCount(e) {
                        e -= 1;
                        return 4294967296 <= e && console.warn("Too many vertices to fit into a single IndexBuffer"), 65536 <= e ? Uint32Array : Uint16Array
                    }
                    static createIndexArray(e, t) {
                        return new(this.getClassForCount(e))(t)
                    }
                    static calculateNumberOfPrimitives(e, t) {
                        switch (t) {
                            case r.g.TRIANGLES:
                                return e / 3;
                            case r.g.TRIANGLE_STRIP:
                            case r.g.TRIANGLE_FAN:
                                return e - 2;
                            case r.g.POINTS:
                                return e;
                            case r.g.LINES:
                                return e / 2;
                            case r.g.LINE_STRIP:
                                return e - 1;
                            case r.g.LINE_LOOP:
                                return e;
                            default:
                                throw new Error("BufferUtils::calculateNumberOfPrimitives mode not found")
                        }
                    }
                    static ensureByteStrideAlignment(e) {
                        return (e = Math.ceil(e)) < 4 ? 4 : e % 4 == 0 ? e : e + (4 - e % 4)
                    }
                }
            },
            4155: (e, t, s) => {
                s.d(t, {
                    g: () => r
                });
                var n = s(8706),
                    o = s(8255),
                    l = s(387);
                class r {
                    static calculateMinMax(s, e) {
                        const r = new Array(s.size),
                            i = new Array(s.size),
                            a = new n.s(s);
                        o.O.iterateIndexedVerticesOnce(e, t => {
                            for (let e = 0; e < s.size; ++e) {
                                const s = a.readAt(t, e);
                                (s < r[e] || void 0 === r[e]) && (r[e] = s), (s > i[e] || void 0 === i[e]) && (i[e] = s)
                            }
                        });
                        for (let e = 0; e < s.size; ++e) r[e] = r[e] || 0, i[e] = i[e] || 0;
                        return new l.x(r, i)
                    }
                    static calculateAttributeMinMax(s) {
                        var e = s.count,
                            r = new Array(s.size),
                            i = new Array(s.size),
                            a = new n.s(s);
                        for (let e = 0; e < s.size; ++e) r[e] = i[e] = a.readAt(0, e);
                        for (let t = 1; t < e; ++t)
                            for (let e = 0; e < s.size; ++e) {
                                const s = a.readAt(0 + t, e);
                                s < r[e] && (r[e] = s), s > i[e] && (i[e] = s)
                            }
                        return {
                            min: r,
                            max: i
                        }
                    }
                    static calculateMinMaxIndex(e) {
                        let s, r;
                        return o.O.iterateIndices(e, (e, t) => {
                            (void 0 === s || e < s) && (s = e), (void 0 === r || e > r) && (r = e)
                        }), void 0 === s || void 0 === r ? void 0 : {
                            min: [s],
                            max: [r]
                        }
                    }
                }
            },
            8255: (e, t, s) => {
                s.d(t, {
                    O: () => a
                });
                class a {
                    static iterateIndexedVertices(e, t) {
                        e.indexBuffer ? a.iterateIndices(e, t) : a.iterateVertices(e, t)
                    }
                    static getIndex(e, t) {
                        var s = e.indexBuffer;
                        return s ? s.data[e.start + t] : t
                    }
                    static iterateIndices(t, s) {
                        var r = t.indexBuffer;
                        if (r)
                            for (let e = 0; e < t.count && !1 !== s(r.data[t.start + e], e); ++e);
                        else
                            for (let e = 0; e < t.count && !1 !== s(e, e); ++e);
                    }
                    static iterateVertices(t, s) {
                        var r = t.indexBuffer ? 0 : t.start;
                        for (let e = 0; e < t.vertexCount && !1 !== s(r + e, e); ++e);
                    }
                    static iterateIndexedVerticesOnce(e, r) {
                        if (e.indexBuffer) {
                            const i = new Set;
                            let s = 0;
                            a.iterateIndexedVertices(e, (e, t) => {
                                if (!i.has(e)) {
                                    if (i.add(e), !1 === r(e, s)) return !1;
                                    s++
                                }
                            })
                        } else this.iterateVertices(e, r)
                    }
                    static iterateTriangles(e, s) {
                        const r = [0, 0, 0];
                        let i = 0;
                        this.iterateIndexedVertices(e, (e, t) => {
                            t %= 3;
                            if (r[t] = e, 2 == t) {
                                if (!1 === s(r[t - 2], r[t - 1], r[t], i)) return !1;
                                i++
                            }
                        })
                    }
                }
            },
            1201: (e, t, s) => {
                s.d(t, {
                    g: () => r
                });
                var r = {
                    ACTIVE_ATTRIBUTES: 35721,
                    ACTIVE_ATTRIBUTE_MAX_LENGTH: 35722,
                    ACTIVE_TEXTURE: 34016,
                    ACTIVE_UNIFORMS: 35718,
                    ACTIVE_UNIFORM_MAX_LENGTH: 35719,
                    ALIASED_LINE_WIDTH_RANGE: 33902,
                    ALIASED_POINT_SIZE_RANGE: 33901,
                    ALPHA: 6406,
                    ALPHA_BITS: 3413,
                    ALWAYS: 519,
                    ARRAY_BUFFER: 34962,
                    ARRAY_BUFFER_BINDING: 34964,
                    ATTACHED_SHADERS: 35717,
                    BACK: 1029,
                    BLEND: 3042,
                    BLEND_COLOR: 32773,
                    BLEND_DST_ALPHA: 32970,
                    BLEND_DST_RGB: 32968,
                    BLEND_EQUATION: 32777,
                    BLEND_EQUATION_ALPHA: 34877,
                    BLEND_EQUATION_RGB: 32777,
                    BLEND_SRC_ALPHA: 32971,
                    BLEND_SRC_RGB: 32969,
                    BLUE_BITS: 3412,
                    BOOL: 35670,
                    BOOL_VEC2: 35671,
                    BOOL_VEC3: 35672,
                    BOOL_VEC4: 35673,
                    BROWSER_DEFAULT_WEBGL: 37444,
                    BUFFER_SIZE: 34660,
                    BUFFER_USAGE: 34661,
                    BYTE: 5120,
                    CCW: 2305,
                    CLAMP_TO_EDGE: 33071,
                    COLOR_ATTACHMENT0: 36064,
                    COLOR_BUFFER_BIT: 16384,
                    COLOR_CLEAR_VALUE: 3106,
                    COLOR_WRITEMASK: 3107,
                    COMPILE_STATUS: 35713,
                    COMPRESSED_TEXTURE_FORMATS: 34467,
                    CONSTANT_ALPHA: 32771,
                    CONSTANT_COLOR: 32769,
                    CONTEXT_LOST_WEBGL: 37442,
                    CULL_FACE: 2884,
                    CULL_FACE_MODE: 2885,
                    CURRENT_PROGRAM: 35725,
                    CURRENT_VERTEX_ATTRIB: 34342,
                    CW: 2304,
                    DECR: 7683,
                    DECR_WRAP: 34056,
                    DELETE_STATUS: 35712,
                    DEPTH_ATTACHMENT: 36096,
                    DEPTH_BITS: 3414,
                    DEPTH_BUFFER_BIT: 256,
                    DEPTH_CLEAR_VALUE: 2931,
                    DEPTH_COMPONENT: 6402,
                    DEPTH_COMPONENT16: 33189,
                    DEPTH_FUNC: 2932,
                    DEPTH_RANGE: 2928,
                    DEPTH_STENCIL: 34041,
                    DEPTH_STENCIL_ATTACHMENT: 33306,
                    DEPTH_TEST: 2929,
                    DEPTH_WRITEMASK: 2930,
                    DITHER: 3024,
                    DONT_CARE: 4352,
                    DST_ALPHA: 772,
                    DST_COLOR: 774,
                    DYNAMIC_DRAW: 35048,
                    ELEMENT_ARRAY_BUFFER: 34963,
                    ELEMENT_ARRAY_BUFFER_BINDING: 34965,
                    EQUAL: 514,
                    FASTEST: 4353,
                    HALF_FLOAT: 5131,
                    FLOAT: 5126,
                    FLOAT_MAT2: 35674,
                    FLOAT_MAT3: 35675,
                    FLOAT_MAT4: 35676,
                    FLOAT_VEC2: 35664,
                    FLOAT_VEC3: 35665,
                    FLOAT_VEC4: 35666,
                    FRAGMENT_SHADER: 35632,
                    FRAMEBUFFER: 36160,
                    FRAMEBUFFER_ATTACHMENT_OBJECT_NAME: 36049,
                    FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE: 36048,
                    FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE: 36051,
                    FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL: 36050,
                    FRAMEBUFFER_BINDING: 36006,
                    FRAMEBUFFER_COMPLETE: 36053,
                    FRAMEBUFFER_INCOMPLETE_ATTACHMENT: 36054,
                    FRAMEBUFFER_INCOMPLETE_DIMENSIONS: 36057,
                    FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT: 36055,
                    FRAMEBUFFER_UNSUPPORTED: 36061,
                    FRONT: 1028,
                    FRONT_AND_BACK: 1032,
                    FRONT_FACE: 2886,
                    FUNC_ADD: 32774,
                    FUNC_REVERSE_SUBTRACT: 32779,
                    FUNC_SUBTRACT: 32778,
                    GENERATE_MIPMAP_HINT: 33170,
                    GEQUAL: 518,
                    GREATER: 516,
                    GREEN_BITS: 3411,
                    HIGH_FLOAT: 36338,
                    HIGH_INT: 36341,
                    INCR: 7682,
                    INCR_WRAP: 34055,
                    INFO_LOG_LENGTH: 35716,
                    INT: 5124,
                    INT_VEC2: 35667,
                    INT_VEC3: 35668,
                    INT_VEC4: 35669,
                    INVALID_ENUM: 1280,
                    INVALID_FRAMEBUFFER_OPERATION: 1286,
                    INVALID_OPERATION: 1282,
                    INVALID_VALUE: 1281,
                    INVERT: 5386,
                    KEEP: 7680,
                    LEQUAL: 515,
                    LESS: 513,
                    LINEAR: 9729,
                    LINEAR_MIPMAP_LINEAR: 9987,
                    LINEAR_MIPMAP_NEAREST: 9985,
                    LINES: 1,
                    LINE_LOOP: 2,
                    LINE_STRIP: 3,
                    LINE_WIDTH: 2849,
                    LINK_STATUS: 35714,
                    LOW_FLOAT: 36336,
                    LOW_INT: 36339,
                    LUMINANCE: 6409,
                    LUMINANCE_ALPHA: 6410,
                    MAX_COMBINED_TEXTURE_IMAGE_UNITS: 35661,
                    MAX_CUBE_MAP_TEXTURE_SIZE: 34076,
                    MAX_FRAGMENT_UNIFORM_VECTORS: 36349,
                    MAX_RENDERBUFFER_SIZE: 34024,
                    MAX_TEXTURE_IMAGE_UNITS: 34930,
                    MAX_TEXTURE_SIZE: 3379,
                    MAX_VARYING_VECTORS: 36348,
                    MAX_VERTEX_ATTRIBS: 34921,
                    MAX_VERTEX_TEXTURE_IMAGE_UNITS: 35660,
                    MAX_VERTEX_UNIFORM_VECTORS: 36347,
                    MAX_VIEWPORT_DIMS: 3386,
                    MEDIUM_FLOAT: 36337,
                    MEDIUM_INT: 36340,
                    MIRRORED_REPEAT: 33648,
                    NEAREST: 9728,
                    NEAREST_MIPMAP_LINEAR: 9986,
                    NEAREST_MIPMAP_NEAREST: 9984,
                    NEVER: 512,
                    NICEST: 4354,
                    NONE: 0,
                    NOTEQUAL: 517,
                    NO_ERROR: 0,
                    NUM_COMPRESSED_TEXTURE_FORMATS: 34466,
                    ONE: 1,
                    ONE_MINUS_CONSTANT_ALPHA: 32772,
                    ONE_MINUS_CONSTANT_COLOR: 32770,
                    ONE_MINUS_DST_ALPHA: 773,
                    ONE_MINUS_DST_COLOR: 775,
                    ONE_MINUS_SRC_ALPHA: 771,
                    ONE_MINUS_SRC_COLOR: 769,
                    OUT_OF_MEMORY: 1285,
                    PACK_ALIGNMENT: 3333,
                    POINTS: 0,
                    POLYGON_OFFSET_FACTOR: 32824,
                    POLYGON_OFFSET_FILL: 32823,
                    POLYGON_OFFSET_UNITS: 10752,
                    RED_BITS: 3410,
                    RENDERBUFFER: 36161,
                    RENDERBUFFER_ALPHA_SIZE: 36179,
                    RENDERBUFFER_BINDING: 36007,
                    RENDERBUFFER_BLUE_SIZE: 36178,
                    RENDERBUFFER_DEPTH_SIZE: 36180,
                    RENDERBUFFER_GREEN_SIZE: 36177,
                    RENDERBUFFER_HEIGHT: 36163,
                    RENDERBUFFER_INTERNAL_FORMAT: 36164,
                    RENDERBUFFER_RED_SIZE: 36176,
                    RENDERBUFFER_STENCIL_SIZE: 36181,
                    RENDERBUFFER_WIDTH: 36162,
                    RENDERER: 7937,
                    REPEAT: 10497,
                    REPLACE: 7681,
                    RGB: 6407,
                    RGB5_A1: 32855,
                    RGB565: 36194,
                    RGBA: 6408,
                    RGBA4: 32854,
                    SAMPLER_2D: 35678,
                    SAMPLER_CUBE: 35680,
                    SAMPLES: 32937,
                    SAMPLE_ALPHA_TO_COVERAGE: 32926,
                    SAMPLE_BUFFERS: 32936,
                    SAMPLE_COVERAGE: 32928,
                    SAMPLE_COVERAGE_INVERT: 32939,
                    SAMPLE_COVERAGE_VALUE: 32938,
                    SCISSOR_BOX: 3088,
                    SCISSOR_TEST: 3089,
                    SHADER_COMPILER: 36346,
                    SHADER_SOURCE_LENGTH: 35720,
                    SHADER_TYPE: 35663,
                    SHADING_LANGUAGE_VERSION: 35724,
                    SHORT: 5122,
                    SRC_ALPHA: 770,
                    SRC_ALPHA_SATURATE: 776,
                    SRC_COLOR: 768,
                    STATIC_DRAW: 35044,
                    STENCIL_ATTACHMENT: 36128,
                    STENCIL_BACK_FAIL: 34817,
                    STENCIL_BACK_FUNC: 34816,
                    STENCIL_BACK_PASS_DEPTH_FAIL: 34818,
                    STENCIL_BACK_PASS_DEPTH_PASS: 34819,
                    STENCIL_BACK_REF: 36003,
                    STENCIL_BACK_VALUE_MASK: 36004,
                    STENCIL_BACK_WRITEMASK: 36005,
                    STENCIL_BITS: 3415,
                    STENCIL_BUFFER_BIT: 1024,
                    STENCIL_CLEAR_VALUE: 2961,
                    STENCIL_FAIL: 2964,
                    STENCIL_FUNC: 2962,
                    STENCIL_INDEX: 6401,
                    STENCIL_INDEX8: 36168,
                    STENCIL_PASS_DEPTH_FAIL: 2965,
                    STENCIL_PASS_DEPTH_PASS: 2966,
                    STENCIL_REF: 2967,
                    STENCIL_TEST: 2960,
                    STENCIL_VALUE_MASK: 2963,
                    STENCIL_WRITEMASK: 2968,
                    STREAM_DRAW: 35040,
                    SUBPIXEL_BITS: 3408,
                    TEXTURE: 5890,
                    TEXTURE0: 33984,
                    TEXTURE1: 33985,
                    TEXTURE2: 33986,
                    TEXTURE3: 33987,
                    TEXTURE4: 33988,
                    TEXTURE5: 33989,
                    TEXTURE6: 33990,
                    TEXTURE7: 33991,
                    TEXTURE8: 33992,
                    TEXTURE9: 33993,
                    TEXTURE10: 33994,
                    TEXTURE11: 33995,
                    TEXTURE12: 33996,
                    TEXTURE13: 33997,
                    TEXTURE14: 33998,
                    TEXTURE15: 33999,
                    TEXTURE16: 34e3,
                    TEXTURE17: 34001,
                    TEXTURE18: 34002,
                    TEXTURE19: 34003,
                    TEXTURE20: 34004,
                    TEXTURE21: 34005,
                    TEXTURE22: 34006,
                    TEXTURE23: 34007,
                    TEXTURE24: 34008,
                    TEXTURE25: 34009,
                    TEXTURE26: 34010,
                    TEXTURE27: 34011,
                    TEXTURE28: 34012,
                    TEXTURE29: 34013,
                    TEXTURE30: 34014,
                    TEXTURE31: 34015,
                    TEXTURE_2D: 3553,
                    TEXTURE_BINDING_2D: 32873,
                    TEXTURE_BINDING_CUBE_MAP: 34068,
                    TEXTURE_CUBE_MAP: 34067,
                    TEXTURE_CUBE_MAP_NEGATIVE_X: 34070,
                    TEXTURE_CUBE_MAP_NEGATIVE_Y: 34072,
                    TEXTURE_CUBE_MAP_NEGATIVE_Z: 34074,
                    TEXTURE_CUBE_MAP_POSITIVE_X: 34069,
                    TEXTURE_CUBE_MAP_POSITIVE_Y: 34071,
                    TEXTURE_CUBE_MAP_POSITIVE_Z: 34073,
                    TEXTURE_MAG_FILTER: 10240,
                    TEXTURE_MIN_FILTER: 10241,
                    TEXTURE_WRAP_S: 10242,
                    TEXTURE_WRAP_T: 10243,
                    TRIANGLES: 4,
                    TRIANGLE_FAN: 6,
                    TRIANGLE_STRIP: 5,
                    UNPACK_ALIGNMENT: 3317,
                    UNPACK_COLORSPACE_CONVERSION_WEBGL: 37443,
                    UNPACK_FLIP_Y_WEBGL: 37440,
                    UNPACK_PREMULTIPLY_ALPHA_WEBGL: 37441,
                    UNSIGNED_BYTE: 5121,
                    UNSIGNED_INT: 5125,
                    UNSIGNED_SHORT: 5123,
                    UNSIGNED_SHORT_4_4_4_4: 32819,
                    UNSIGNED_SHORT_5_5_5_1: 32820,
                    UNSIGNED_SHORT_5_6_5: 33635,
                    VALIDATE_STATUS: 35715,
                    VENDOR: 7936,
                    VERSION: 7938,
                    VERTEX_ATTRIB_ARRAY_BUFFER_BINDING: 34975,
                    VERTEX_ATTRIB_ARRAY_ENABLED: 34338,
                    VERTEX_ATTRIB_ARRAY_NORMALIZED: 34922,
                    VERTEX_ATTRIB_ARRAY_POINTER: 34373,
                    VERTEX_ATTRIB_ARRAY_SIZE: 34339,
                    VERTEX_ATTRIB_ARRAY_STRIDE: 34340,
                    VERTEX_ATTRIB_ARRAY_TYPE: 34341,
                    VERTEX_SHADER: 35633,
                    VIEWPORT: 2978,
                    ZERO: 0
                }
            },
            2718: (e, t, s) => {
                s.d(t, {
                    a: () => n
                });
                var r = s(651),
                    i = s(9720),
                    a = s(1668);
                class n {
                    constructor(e) {
                        this.signals = {
                            change: i.M.create(),
                            loaded: i.M.create()
                        }, this._loadStarted = !1, this._loaded = !1, this._url = "", this._zipFiles = [], this.onComplete = e => {
                            e.successful || console.log(e.resultMessage), this.onXHRLoaded(e)
                        }, this._config = e, this._scene = new r.x, this._scenes = [this._scene]
                    }
                    load(t) {
                        return new Promise(e => {
                            this._url = t, this._loaded ? setTimeout(() => {
                                e(this)
                            }, 0) : (this.signals.loaded.addOnce(e), this._loadStarted || (this._loadStarted = !0, this.innerLoad(t)))
                        })
                    }
                    async onAllMeshesLoaded() {
                        return Promise.all([])
                    }
                    invalidate() {
                        this.signals.change.dispatch()
                    }
                    innerLoad(e) {
                        a.i.load({
                            url: e,
                            json: !1,
                            onComplete: this.onComplete
                        })
                    }
                    onXHRLoaded(e) {
                        e = e.xhr.responseText;
                        this.parse(e)
                    }
                    parse(e) {
                        this.completeLoad()
                    }
                    completeLoad() {
                        this._loaded = !0, this.signals.loaded.dispatch(this)
                    }
                    createDrawUnit() {
                        return null
                    }
                    get animationEngine() {
                        return null
                    }
                    get scene() {
                        return this._scene
                    }
                    get scenes() {
                        return this._scenes
                    }
                    get loaded() {
                        return this._loaded
                    }
                    get url() {
                        return this._url
                    }
                    get copyright() {
                        return null
                    }
                    get zipFiles() {
                        return this._zipFiles
                    }
                }
            },
            8402: (e, t, s) => {
                s.d(t, {
                    c: () => a
                });
                var i = s(8766),
                    r = s(5081);
                class a {
                    constructor(e) {
                        this._bufferViews = new Map, this._buffers = new Map, this._firstBuffer = null, this._chunks = [], this._completed = !1, this._glTFExporter = e, this.createFirstBuffer()
                    }
                    createFirstBuffer() {
                        var e = this._glTFExporter.jsonWriter.addBufferConfig({
                            byteLength: 0
                        });
                        if (this._firstBuffer = this._glTFExporter.jsonWriter.json.buffers[e], 0 !== e) throw new Error("Binary buffer has to be the first one in the buffers list!")
                    }
                    addTexture(e, t) {
                        var s = this.addArrayBuffer(e),
                            e = {
                                buffer: 0,
                                byteLength: e.byteLength,
                                byteOffset: s.byteOffset,
                                name: t
                            };
                        return this._glTFExporter.jsonWriter.addBufferView(e)
                    }
                    addBufferView(e, t) {
                        var s, r;
                        return this._bufferViews.has(e) || (s = this.addArrayBuffer(e.arrayBuffer), r = e.data, r = this._glTFExporter.addBufferView({
                            buffer: 0,
                            byteLength: r.byteLength,
                            byteOffset: r.byteOffset + s.byteOffset,
                            byteStride: t,
                            target: e.target
                        }), this._bufferViews.set(e, r)), this._bufferViews.get(e)
                    }
                    addArrayBuffer(e) {
                        if (!this._firstBuffer || this._completed) throw new Error("Can't call addArrayBuffer after complete()!");
                        let t = this._buffers.get(e);
                        return t || (t = {
                            byteOffset: this._firstBuffer.byteLength
                        }, this._buffers.set(e, t), e = r.W.getPaddedBufferSize(e.byteLength), this._firstBuffer.byteLength += e), t
                    }
                    complete() {
                        this._completed || (this._completed = !0, this.removeFirstBufferIfEmpty(), this.createResultBuffer())
                    }
                    createFile() {
                        this.complete();
                        var e = this._glTFExporter.getFileName();
                        if (this._result) return new File([this._result], e, {
                            type: a.mimeType,
                            lastModified: Date.now()
                        });
                        throw new Error("No result buffer!")
                    }
                    removeFirstBufferIfEmpty() {
                        var e = this._glTFExporter.jsonWriter.json;
                        if (0 === this._buffers.size) {
                            e.buffers.splice(0, 1), this._firstBuffer = null;
                            for (const t of e.bufferViews) 0 < t.buffer ? --t.buffer : console.warn("buffer id is 0, yet buffer is empty?")
                        }
                    }
                    createResultBuffer() {
                        this.addJSONChunk();
                        var {
                            binaryStart: e,
                            totalByteLength: t
                        } = this.calculateLengths();
                        this._result = new ArrayBuffer(t), this.writeHeader(), this.writeJSONChunk(), this.writeBinaryChunk(e)
                    }
                    addJSONChunk() {
                        var e = this._glTFExporter.getJSONString(!0),
                            e = r.W.string2arraybuffer(e),
                            e = r.W.getPaddedArrayBuffer(e, 32);
                        this._chunks.push({
                            type: i.K.CHUNKTYPE_JSON,
                            buffer: e
                        })
                    }
                    calculateLengths() {
                        let e = i.K.HEADER_LENGTH;
                        var t = e += this._chunks[0].buffer.byteLength + i.K.CHUNK_PREFIX_LENGTH;
                        return this._firstBuffer && (e += this._firstBuffer.byteLength + i.K.CHUNK_PREFIX_LENGTH), {
                            binaryStart: t,
                            totalByteLength: e
                        }
                    }
                    writeHeader() {
                        if (!this._result) throw new Error("No result buffer!");
                        var e = new DataView(this._result, 0, i.K.HEADER_LENGTH),
                            t = this._result.byteLength;
                        e.setUint32(0, i.K.HEADER_MAGIC, !0), e.setUint32(4, 2, !0), e.setUint32(8, t, !0)
                    }
                    writeJSONChunk() {
                        if (!this._result) throw new Error("No result buffer!");
                        var e = new Uint8Array(this._result),
                            t = new DataView(new ArrayBuffer(i.K.CHUNK_PREFIX_LENGTH));
                        t.setUint32(0, this._chunks[0].buffer.byteLength, !0), t.setUint32(4, i.K.CHUNKTYPE_JSON, !0), e.set(new Uint8Array(t.buffer), i.K.HEADER_LENGTH), e.set(new Uint8Array(this._chunks[0].buffer), i.K.HEADER_LENGTH + i.K.CHUNK_PREFIX_LENGTH)
                    }
                    writeBinaryChunk(s) {
                        if (!this._result) throw new Error("No result buffer!");
                        if (this._firstBuffer) {
                            const r = new Uint8Array(this._result),
                                t = new DataView(new ArrayBuffer(i.K.CHUNK_PREFIX_LENGTH));
                            t.setUint32(0, this._firstBuffer.byteLength, !0), t.setUint32(4, i.K.CHUNKTYPE_BIN, !0), r.set(new Uint8Array(t.buffer), s), s += i.K.CHUNK_PREFIX_LENGTH;
                            var e = window.performance.now();
                            this._buffers.forEach((e, t) => {
                                t = new Uint8Array(t), e = s + e.byteOffset;
                                r.set(t, e)
                            }), console.log(window.performance.now() - e)
                        }
                    }
                }
                a.mimeType = "model/gltf-binary"
            },
            6385: (e, t, s) => {
                s.d(t, {
                    T: () => r
                });
                class r {}
                r.ID = "KHR_draco_mesh_compression"
            },
            3205: (e, t, s) => {
                s.d(t, {
                    X: () => r
                });
                class r {}
                r.ID = "KHR_lights_punctual", r.url = ""
            },
            3707: (e, t, s) => {
                s.d(t, {
                    j: () => r
                });
                class r {}
                r.ID = "KHR_materials_anisotropy"
            },
            6040: (e, t, s) => {
                s.d(t, {
                    o: () => r
                });
                class r {}
                r.ID = "KHR_materials_clearcoat"
            },
            8987: (e, t, s) => {
                s.d(t, {
                    O: () => r
                });
                class r {}
                r.ID = "KHR_materials_emissive_strength"
            },
            503: (e, t, s) => {
                s.d(t, {
                    H: () => r
                });
                class r {}
                r.ID = "KHR_materials_ior", r.defaultIOR = 1.5
            },
            7375: (e, t, s) => {
                s.d(t, {
                    q: () => r
                });
                class r {}
                r.ID = "KHR_materials_sheen"
            },
            4815: (e, t, s) => {
                s.d(t, {
                    w: () => r
                });
                class r {}
                r.ID = "KHR_materials_specular"
            },
            4108: (e, t, s) => {
                s.d(t, {
                    I: () => r
                });
                class r {}
                r.ID = "KHR_materials_transmission"
            },
            9421: (e, t, s) => {
                s.d(t, {
                    W: () => r
                });
                class r {}
                r.ID = "KHR_materials_unlit"
            },
            433: (e, t, s) => {
                s.d(t, {
                    n: () => r
                });
                class r {}
                r.ID = "KHR_materials_volume"
            },
            6504: (e, t, s) => {
                s.d(t, {
                    _: () => r
                });
                class r {}
                r.ID = "KHR_mesh_quantization"
            },
            5396: (e, t, s) => {
                s.d(t, {
                    V: () => r
                });
                class r {}
                r.ID = "KHR_node_visibility", r.url = "https://github.com/KhronosGroup/glTF/pull/2410"
            },
            3960: (e, t, s) => {
                s.d(t, {
                    j: () => r
                });
                class r {}
                r.ID = "KHR_texture_transform"
            },
            7054: (e, t, s) => {
                var r;
                s.d(t, {
                    RW: () => function(e) {
                        return Boolean(e.sparse)
                    },
                    mM: () => r
                }), s(4108), s(9421), s(8987), s(503), s(7375), s(6040), s(433), s(4815), s(3707), s(5396), (t = r = r || {}).OPAQUE = "OPAQUE", t.MASK = "MASK", t.BLEND = "BLEND"
            },
            8539: (O, e, t) => {
                t.r(e), t.d(e, {
                    glTFLoader: () => D
                });
                var s = t(8766),
                    B = t(4955),
                    U = t(2263),
                    u = t(6646),
                    p = t(3629),
                    m = t(9866),
                    c = t(6407),
                    k = t(9894),
                    r = t(9959),
                    h = t(8396),
                    z = t(8706),
                    V = t(540);
                class G {
                    constructor(e, t) {
                        this._promises = [], this._config = e, this._loader = t, this.init()
                    }
                    async init() {
                        this._config.inverseBindMatrices && this._promises.push(this.parseAttribute(this._config.inverseBindMatrices).then(e => {
                            this._inverseBindMatrices = e
                        }))
                    }
                    async onLoaded() {
                        await Promise.all(this._promises)
                    }
                    async parseAttribute(e) {
                        const s = this._loader.json.accessors[e],
                            r = this._loader.getBufferView(e);
                        if (!r) throw new Error("BufferView not found, zero fill not implemented!");
                        r.byteOffset % 4 != 0 && console.warn("byteOffset should be aligned to 4-byte!");
                        var e = await r.getBuffer(),
                            e = V.J.createAttribute(s, "", e),
                            i = new z.s(e),
                            a = h.s.accessorType2size(s.type),
                            n = [];
                        for (let t = 0; t < s.count; ++t)
                            for (let e = 0; e < a; ++e) {
                                const r = i.readAt(t, e);
                                n.push(r)
                            }
                        return new Float32Array(n)
                    }
                    get inverseBindMatrices() {
                        return this._inverseBindMatrices
                    }
                    get name() {
                        return this._config.name
                    }
                    get skeleton() {
                        return this._config.skeleton
                    }
                    get joints() {
                        return this._config.joints
                    }
                    get jointCount() {
                        return this._config.joints.length
                    }
                }
                var W = t(7723);
                class H {
                    constructor(e) {
                        this._jointMatrices = [], this._inverseBindMatrices = [], this._config = e, this._jointData = new Float32Array(16 * this.jointCount);
                        var t = this._config.inverseBindMatricesData;
                        for (let e = 0; e < this.jointCount; ++e) this._inverseBindMatrices.push(new Float32Array(t.buffer, t.byteOffset + 16 * e * Float32Array.BYTES_PER_ELEMENT, 16)), this._jointMatrices.push(new Float32Array(this._jointData.buffer, 16 * e * Float32Array.BYTES_PER_ELEMENT, 16))
                    }
                    update(t) {
                        for (let e = 0; e < this.jointCount; ++e) {
                            var s = this._config.joints[e].worldMatrix,
                                r = this._inverseBindMatrices[e],
                                i = this._jointMatrices[e];
                            W._.mul(i, s, r), t.setUniform(`u_bones[${e}]`, i)
                        }
                    }
                    get jointCount() {
                        return this._config.jointCount
                    }
                }
                var Y = t(6438),
                    j = t(1644),
                    g = t(9421),
                    K = t(6039);
                class q {
                    constructor(e) {
                        this._materials = {}, this._meshes = {}, this._skins = {}, this._loader = e
                    }
                    createSceneNode(s) {
                        var e = (null == (i = this._loader.json.nodes) ? void 0 : i[s]) || {};
                        let t = e.name || "";
                        const r = new B.B({
                            transform: this.getNodeTransform(e)
                        });
                        r.visible = !(!1 === (null == (i = null == (i = e.extensions) ? void 0 : i.KHR_node_visibility) ? void 0 : i.visible)), r.gltf.nodeId = s;
                        var i = e.mesh,
                            a = [];
                        let n = null;
                        if (c.M.isPositiveOrZero(i)) {
                            const s = this.getMesh(i);
                            if (s) {
                                !t && s.name && (t = s.name), s.weights && (r.morphWeights = s.weights), n = s.onLoaded(), a.push(n);
                                const i = this.getSkin(e.skin);
                                i && a.push(i.onLoaded()), Promise.all(a).then(() => {
                                    for (const t of s.primitives) {
                                        const s = t.geometry;
                                        let e = this.getMaterial(t.material);
                                        e = e || new u.q, s ? r.addRenderNode(new U.j({
                                            geometry: s,
                                            material: e,
                                            boundingBox: t.boundingBox,
                                            skin: this.createSkin(i, r)
                                        })) : console.log("No geometry/material for primitive", t)
                                    }
                                    this._loader.invalidate()
                                })
                            }
                        }
                        return r.name = t, e.weights && (r.morphWeights = e.weights), this.addLight(r, e), {
                            sceneNode: r,
                            meshPromise: n
                        }
                    }
                    getMesh(e) {
                        if (!this._meshes[e]) {
                            var t = null == (t = this._loader.json.meshes) ? void 0 : t[e];
                            if (!t) return console.warn("Mesh not found for id: " + e), null;
                            this._meshes[e] = new h.s(t, this._loader)
                        }
                        return this._meshes[e]
                    }
                    getSkin(e) {
                        if (c.M.isPositiveOrZero(e)) {
                            if (!this._skins[e]) {
                                var t = null == (t = this._loader.json.skins) ? void 0 : t[e];
                                if (!t) return void console.warn("Skin not found for id: " + e);
                                this._skins[e] = new G(t, this._loader)
                            }
                            return this._skins[e]
                        }
                    }
                    createSkin(e, t) {
                        if (e) {
                            var t = c.M.isPositiveOrZero(e.skeleton) ? this._loader.sceneNodes[e.skeleton] : t.scene,
                                s = [];
                            for (const t of e.joints) s.push(this._loader.sceneNodes[t]);
                            if (e.inverseBindMatrices) return new H({
                                inverseBindMatricesData: e.inverseBindMatrices,
                                jointCount: e.jointCount,
                                skeleton: t,
                                joints: s
                            });
                            throw new Error("InverseBindMatrices not found!")
                        }
                    }
                    getNodeTransform(e) {
                        let t;
                        return e.matrix ? t = r.j.fromMatrix(e.matrix) : (t = new r.j, e.scale && t.scale.copyFrom(e.scale), e.rotation && t.rotation.copyFrom(e.rotation), e.translation && t.translation.copyFrom(e.translation)), t
                    }
                    getMaterial(e) {
                        return this._materials[e] || (this._materials[e] = this.createMaterial(e)), this._materials[e]
                    }
                    createMaterial(e) {
                        var e = this.getMaterialConfig(e) || {},
                            t = e.pbrMetallicRoughness || {};
                        let s, r;
                        e.occlusionTexture && (s = e.occlusionTexture.strength), e.normalTexture && (r = e.normalTexture.scale);
                        var i, a, n, o, l, h, c = null != (c = t.baseColorFactor) ? c : [1, 1, 1, 1],
                            d = e.name || "";
                        return null != (i = e.extensions) && i[g.W.ID] ? new k.z({
                            name: d,
                            baseColorTexture: this.getTextureInfo(t.baseColorTexture, "base", d),
                            baseColorFactor: p.I.vec3_to_hex(c),
                            baseColorAlpha: c[3]
                        }) : (i = null == (i = e.extensions) ? void 0 : i.KHR_materials_transmission, a = null == (a = e.extensions) ? void 0 : a.KHR_materials_sheen, n = null == (n = e.extensions) ? void 0 : n.KHR_materials_clearcoat, o = null == (o = e.extensions) ? void 0 : o.KHR_materials_volume, l = null == (l = e.extensions) ? void 0 : l.KHR_materials_specular, h = null == (h = e.extensions) ? void 0 : h.KHR_materials_anisotropy, new u.q({
                            name: d,
                            side: e.doubleSided ? m.N.DOUBLE : m.N.FRONT,
                            alphaMode: e.alphaMode,
                            alphaCutoff: e.alphaCutoff,
                            baseColorTexture: this.getTextureInfo(t.baseColorTexture, "base", d),
                            baseColorFactor: p.I.vec3_to_hex(c),
                            baseColorAlpha: c[3],
                            emissiveTexture: this.getTextureInfo(e.emissiveTexture, "emissive", d),
                            emissiveFactor: e.emissiveFactor ? p.I.vec3_to_hex(e.emissiveFactor) : void 0,
                            emissiveStrength: null != (c = null == (c = null == (c = e.extensions) ? void 0 : c.KHR_materials_emissive_strength) ? void 0 : c.emissiveStrength) ? c : 1,
                            metallicRoughnessTexture: this.getTextureInfo(t.metallicRoughnessTexture, "metallicRoughness", d),
                            metallicFactor: null != (c = t.metallicFactor) ? c : 1,
                            roughnessFactor: null != (c = t.roughnessFactor) ? c : 1,
                            occlusionTexture: this.getTextureInfo(e.occlusionTexture, "occlusion", d),
                            occlusionStrength: s,
                            normalTexture: this.getTextureInfo(e.normalTexture, "normal", d),
                            normalScale: r,
                            transmissionTexture: this.getTextureInfo(null == i ? void 0 : i.transmissionTexture, "transmission", d),
                            transmissionFactor: null != (t = null == i ? void 0 : i.transmissionFactor) ? t : 0,
                            ior: null != (t = null == (i = null == (c = e.extensions) ? void 0 : c.KHR_materials_ior) ? void 0 : i.ior) ? t : 1.5,
                            sheenColorFactor: null != a && a.sheenColorFactor ? p.I.vec3_to_hex(null == a ? void 0 : a.sheenColorFactor) : void 0,
                            sheenColorTexture: this.getTextureInfo(null == a ? void 0 : a.sheenColorTexture, "sheenColor", d),
                            sheenRoughnessFactor: null == a ? void 0 : a.sheenRoughnessFactor,
                            sheenRoughnessTexture: this.getTextureInfo(null == a ? void 0 : a.sheenColorTexture, "sheenRoughness", d),
                            clearcoatFactor: null != (e = null == n ? void 0 : n.clearcoatFactor) ? e : 0,
                            clearcoatTexture: this.getTextureInfo(null == n ? void 0 : n.clearcoatTexture, "clearcoat", d),
                            clearcoatRoughnessFactor: null != (c = null == n ? void 0 : n.clearcoatRoughnessFactor) ? c : 0,
                            clearcoatRoughnessTexture: this.getTextureInfo(null == n ? void 0 : n.clearcoatRoughnessTexture, "clearcoatRoughness", d),
                            clearcoatNormalTexture: this.getTextureInfo(null == n ? void 0 : n.clearcoatNormalTexture, "clearcoatNormal", d),
                            thicknessFactor: null != (i = null == o ? void 0 : o.thicknessFactor) ? i : 0,
                            thicknessTexture: this.getTextureInfo(null == o ? void 0 : o.thicknessTexture, "thickness", d),
                            attenuationDistance: null != (t = null == o ? void 0 : o.attenuationDistance) ? t : 1 / 0,
                            attenuationColor: null != o && o.attenuationColor ? p.I.vec3_to_hex(null == o ? void 0 : o.attenuationColor) : 16777215,
                            anisotropyStrength: null != (a = null == h ? void 0 : h.anisotropyStrength) ? a : 0,
                            anisotropyRotation: null != (e = null == h ? void 0 : h.anisotropyRotation) ? e : 0,
                            anisotropyTexture: this.getTextureInfo(null == h ? void 0 : h.anisotropyTexture, "anisotropy", d),
                            specularFactor: null != (c = null == l ? void 0 : l.specularFactor) ? c : 1,
                            specularTexture: this.getTextureInfo(null == l ? void 0 : l.specularTexture, "specular", d),
                            specularColorFactor: null != l && l.specularColorFactor ? p.I.vec3_to_hex(null == l ? void 0 : l.specularColorFactor) : 16777215,
                            specularColorTexture: this.getTextureInfo(null == l ? void 0 : l.specularColorTexture, "specularColor", d)
                        }))
                    }
                    getTextureInfo(e, t, s) {
                        return new K.l({
                            texture: this.getTexture(e, this.getTextureName(t, s)),
                            channel: this.getChannel(e),
                            transform: this.getTransform(e)
                        })
                    }
                    getMaterialConfig(e) {
                        var t;
                        let s = {};
                        return s = c.M.isValidNumber(e) ? (null == (t = this._loader.json.materials) ? void 0 : t[e]) || s : s
                    }
                    getTextureName(e, t) {
                        return e
                    }
                    getTexture(e, t) {
                        return this._loader.textureFactory.getTexture(e, t)
                    }
                    getChannel(e) {
                        var t;
                        return e ? (t = (null == (t = e.extensions) ? void 0 : t.KHR_texture_transform) || null, c.M.isPositiveOrZero(null == t ? void 0 : t.texCoord) ? t.texCoord : e.texCoord || 0) : 0
                    }
                    getTransform(e) {
                        var t = new Y.I,
                            e = (null == (e = null == e ? void 0 : e.extensions) ? void 0 : e.KHR_texture_transform) || null;
                        return e && (e.offset && t.setTranslation(e.offset), e.scale && t.setScale(e.scale), t.rotation = e.rotation || 0), t
                    }
                    addLight(e, t) {
                        var s, r, i = null == (t = null == (s = t.extensions) ? void 0 : s.KHR_lights_punctual) ? void 0 : t.light;
                        if (c.M.isValidNumber(i)) {
                            const t = null == (r = null == (r = this._loader.json.extensions) ? void 0 : r.KHR_lights_punctual) ? void 0 : r.lights,
                                s = null == t ? void 0 : t[i];
                            s ? e.light = new j.a(e, s) : console.warn("Light not found for id: " + i)
                        }
                    }
                }
                var e = t(2718),
                    $ = t(7054),
                    i = t(5433),
                    X = t(1668);
                class Z {
                    constructor(e, t) {
                        this._loaded = !1, this._loadStarted = !1, this._resolves = [], this.onFileLoaded = e => {
                            this.setArraybuffer(e)
                        }, this.onComplete = e => {
                            e.successful ? this.setArraybuffer(e.xhr.response) : console.log("Couldn't load buffer: " + e.result)
                        }, this._config = e, this._loader = t
                    }
                    initLoading() {
                        if (!this._loadStarted)
                            if (this._loadStarted = !0, this._config.uri) this.load(this._config.uri);
                            else {
                                if (!this._loader.glbLoader) throw new Error("No glbLoader set!");
                                this._arraybuffer = this._loader.glbLoader.buffer, this.success()
                            }
                    }
                    load(e) {
                        let t;
                        0 === e.indexOf("data:") ? t = e : this._loader.files ? this.loadFile(e) : t = this._loader.getUrl(e), t && X.i.load({
                            url: t,
                            responseType: "arraybuffer",
                            onComplete: this.onComplete
                        })
                    }
                    loadFile(e) {
                        var t = null == (t = this._loader.files) ? void 0 : t.getByName(this._loader.getFileUrl(e));
                        t ? i.P.readAsArraybuffer(t).then(this.onFileLoaded) : alert("File missing: " + e)
                    }
                    setArraybuffer(e) {
                        this._arraybuffer = e, this.success()
                    }
                    async getArraybuffer() {
                        return new Promise((e, t) => {
                            this._arraybuffer ? e(this._arraybuffer) : (this._resolves.push(e), this.initLoading())
                        })
                    }
                    success() {
                        this._loaded = !0;
                        for (const e of this._resolves) e(this._arraybuffer);
                        this._resolves.length = 0
                    }
                    get config() {
                        return this._config
                    }
                }
                var a = t(1201),
                    J = t(428);
                class n {
                    constructor(e, t) {
                        this._config = e, this._loader = t
                    }
                    async getData() {
                        var e;
                        return this._data || (e = await this._loader.bufferLoaders[this._config.buffer].getArraybuffer(), this._data = new Uint8Array(e, this.byteOffset, this.byteLength)), this._data
                    }
                    async cloneData() {
                        return (await this.getData()).buffer.slice(this.byteOffset, this.byteOffset + this.byteLength)
                    }
                    async getBuffer(e = a.g.ARRAY_BUFFER) {
                        var t;
                        return this._buffer || (t = await this.getData(), this._buffer) || (this._buffer = new J.f({
                            name: this._config.name,
                            data: t,
                            byteStride: this.byteStride,
                            target: e
                        })), this._buffer
                    }
                    get byteOffset() {
                        return this._config.byteOffset || 0
                    }
                    get byteStride() {
                        return this._config.byteStride
                    }
                    get byteLength() {
                        return this._config.byteLength
                    }
                }
                var Q = t(651),
                    d = t(6780),
                    ee = t(8227);
                class o {
                    constructor(e) {
                        this._textures = [], this.onImageLoaded = () => {
                            this._loader.invalidate()
                        }, this._loader = e
                    }
                    getTexture(e, t) {
                        if (e) {
                            var s, r = this._loader.json.textures[e.index];
                            if (r) return (s = this.getTextureResource(e.index)).image.name || (s.image.name = r.name || t || ""), s;
                            console.warn("Texture missing!", e)
                        }
                    }
                    getTextureResource(e) {
                        return this._textures[e] || (this._textures[e] = this.createTextureResource(e)), this._textures[e]
                    }
                    createTextureResource(e) {
                        const t = this._loader.json.textures[e],
                            s = null != (e = null != (n = null == (e = null == (n = t.extensions) ? void 0 : n.EXT_texture_webp) ? void 0 : e.source) ? n : null == (n = null == (e = t.extensions) ? void 0 : e.KHR_texture_basisu) ? void 0 : n.source) ? e : t.source,
                            i = c.M.isPositiveOrZero(s) ? this._loader.json.images[s] : {};
                        let r = "",
                            a = "";
                        if (null != i && i.uri)
                            if (this._loader.files) {
                                const e = this._loader.getFileUrl(i.uri),
                                    n = this._loader.files.getByName(e);
                                n ? (r = URL.createObjectURL(n), a = n.name || a) : "data:" === i.uri.substr(0, 5) ? r = i.uri : console.warn("File is missing: ", i.uri)
                            } else 0 !== (r = this._loader.getUrl(i.uri)).indexOf("proxy.php?url=") && (r = "proxy.php?url=" + r), i.uri && 0 !== i.uri.indexOf("data:") && (a = i.uri || a);
                        else c.M.isValidNumber(null == i ? void 0 : i.bufferView) || console.error("Texture has no uri and no bufferView either!");
                        var n = new d.c;
                        n.signals.load.addOnce(this.onImageLoaded), n.setUrlSource(r);
                        const o = this.getSampler(t.sampler),
                            l = new ee.a({
                                minFilter: o.minFilter,
                                magFilter: o.magFilter,
                                wrapS: o.wrapS,
                                wrapT: o.wrapT
                            }),
                            h = new d.x(n, l);
                        return h.image.name = a || h.image.name, 0 === h.image.name.indexOf("data:") && (h.image.name = ""), c.M.isValidNumber(i.bufferView) && this._loader.bufferViews[i.bufferView].getData().then(e => {
                            const t = new Blob([e], {
                                    type: i.mimeType
                                }),
                                s = URL.createObjectURL(t),
                                r = new Image;
                            r.onload = () => {
                                h.image.setMediaSource(r), this.onImageLoaded()
                            }, r.src = s
                        }), h
                    }
                    getSampler(e) {
                        var t = {
                            magFilter: a.g.LINEAR,
                            minFilter: a.g.LINEAR_MIPMAP_LINEAR,
                            wrapS: a.g.REPEAT,
                            wrapT: a.g.REPEAT
                        };
                        return c.M.isValidNumber(e) && (e = this._loader.json.samplers[e]) && (e.minFilter && (t.minFilter = e.minFilter), e.magFilter && (t.magFilter = e.magFilter), e.wrapS && (t.wrapS = e.wrapS), e.wrapT) && (t.wrapT = e.wrapT), t
                    }
                }
                var te = t(8244),
                    se = t(5979);
                class re {
                    constructor(e) {
                        this._mainFiles = [], this._filesByName = {}, this._files = e, this.parse()
                    }
                    parse() {
                        this._mainFiles = [], this._filesByName = {};
                        for (let e = 0; e < this._files.length; ++e) {
                            var t = this._files[e],
                                s = i.P.getExtension(t.name);
                            this._filesByName[t.name] = t, -1 < ["glb", "gltf"].indexOf(s) && this._mainFiles.push(t)
                        }
                    }
                    loadFile(e, t) {
                        e && ("glb" === i.P.getExtension(e.name) ? i.P.readAsArraybuffer(e).then(t) : i.P.readAsText(e, t))
                    }
                    getByName(e) {
                        return this._filesByName[e]
                    }
                    get mainFiles() {
                        return this._mainFiles
                    }
                }
                var _ = t(3829);
                class l extends n {
                    static getConfig(e, t) {
                        var s;
                        let r = 0,
                            i = 0;
                        return c.M.isValidNumber(e.bufferView) && (i = null != (s = t.bufferViews[e.bufferView].byteStride) ? s : 0, r = t.bufferViews[e.bufferView].byteOffset), {
                            byteOffset: r,
                            byteStride: i,
                            byteLength: 0,
                            buffer: -1
                        }
                    }
                    constructor(e, t) {
                        super(l.getConfig(e, t), t), this._accessor = e
                    }
                    async getData() {
                        var e = this._accessor,
                            t = e.bufferView,
                            s = _.eE[e.componentType],
                            r = h.s.accessorType2size(e.type),
                            i = c.M.isValidNumber(t) ? new s(await this._loader.bufferViews[t].cloneData()) : new s(e.count * r),
                            t = e.sparse,
                            e = this._loader.bufferViews[t.indices.bufferView],
                            a = await e.getData(),
                            n = new _.eE[t.indices.componentType](a.buffer, e.byteOffset + (t.indices.byteOffset || 0), t.count * h.s.accessorType2size("SCALAR")),
                            a = this._loader.bufferViews[t.values.bufferView],
                            o = new s(await a.getData(), a.byteOffset + (t.values.byteOffset || 0), t.count * r);
                        let l = 0;
                        for (let e = 0; e < n.length; ++e) {
                            let t = n[e] * r;
                            for (let e = 0; e < r; e++) i[t++] = o[l++]
                        }
                        return i
                    }
                }
                var f = t(3960),
                    v = t(6385),
                    b = t(2671),
                    x = t(82);
                class T {
                    constructor(e, t, s) {
                        this._config = e, this._loader = t, this._sampler = s[e.sampler], this._sceneNode = this._loader.sceneNodes[this._config.target.node], this._keyFrameCount = this._loader.json.accessors[this._sampler.config.input].count, this._promise = this._sampler.getBuffers().then(e => {
                            this._inputBuffer = e[0], this._outputBuffer = e[1]
                        })
                    }
                    async onLoad() {
                        return this._promise
                    }
                    validateTime(e) {
                        var t = this.sampler.getTimeRange();
                        return c.M.clamp(e, t[0], t[1])
                    }
                    update(e) {
                        e = this.validateTime(e);
                        var t = this.findKeyframeIndex(e),
                            s = this._inputBuffer[t],
                            r = this._inputBuffer[t + 1],
                            i = this.interpolate(e, s, r);
                        switch (this._config.target.path) {
                            case "rotation":
                                this.updateRotation(t, i);
                                break;
                            case "translation":
                                this.updateTranslation(t, i);
                                break;
                            case "scale":
                                this.updateScale(t, i);
                                break;
                            case "weights":
                                this.updateWeights(t, i)
                        }
                    }
                    interpolate(e, t, s) {
                        return (T.interpolators[this._sampler.config.interpolation] || T.interpolators.LINEAR)(e, t, s)
                    }
                    updateRotation(e, t) {
                        let s = this.getVec4(e);
                        e < this._keyFrameCount - 1 && (e = this.getVec4(e + 1), s = b.g.slerp(b.g.create(), s, e, t)), this._sceneNode.transform.rotation.copyFrom(s)
                    }
                    updateTranslation(e, t) {
                        let s = this.getVec3(e);
                        e < this._keyFrameCount - 1 && (e = this.getVec3(e + 1), s = x.R.lerp(x.R.create(), s, e, t)), this._sceneNode.transform.translation.copyFrom(s)
                    }
                    updateScale(e, t) {
                        let s = this.getVec3(e);
                        e < this._keyFrameCount - 1 && (e = this.getVec3(e + 1), s = x.R.lerp(x.R.create(), s, e, t)), this._sceneNode.transform.scale.copyFrom(s)
                    }
                    updateWeights(t, s) {
                        if (this._sceneNode.morphWeights) {
                            let e = this.getVec(t, this._sceneNode.morphWeights.length);
                            t < this._keyFrameCount - 1 && (t = this.getVec(t + 1, this._sceneNode.morphWeights.length), e = c.M.lerp([], e, t, s)), this._sceneNode.morphWeights = e
                        } else console.warn("Morph weights not found!")
                    }
                    findKeyframeIndex(t) {
                        let s = 0;
                        for (let e = 0; e < this._inputBuffer.length && !(this._inputBuffer[e] > t); ++e) s = e;
                        return s
                    }
                    getVec4(e) {
                        return [this._outputBuffer[4 * e], this._outputBuffer[4 * e + 1], this._outputBuffer[4 * e + 2], this._outputBuffer[4 * e + 3]]
                    }
                    getVec3(e) {
                        return [this._outputBuffer[3 * e], this._outputBuffer[3 * e + 1], this._outputBuffer[3 * e + 2]]
                    }
                    getVec(t, s) {
                        var r = [];
                        for (let e = 0; e < s; ++e) r.push(this._outputBuffer[t * s + e]);
                        return r
                    }
                    get sampler() {
                        return this._sampler
                    }
                }
                T.interpolators = {
                    LINEAR: (e, t, s) => (e - t) / (s - t),
                    STEP: (e, t, s) => s <= e ? s : t,
                    CUBICSPLINE: (e, t, s) => {
                        throw new Error("Not implemented!")
                    }
                };
                class ie {
                    constructor(e, t) {
                        this._config = e, this._loader = t
                    }
                    getBuffers() {
                        var e = this._config,
                            t = (this._loader.json.accessors[this._config.input].componentType !== a.g.FLOAT && console.warn("test this case"), this._loader.animationLoader);
                        return Promise.all(t ? [t.getAccessorData(e.input), t.getAccessorData(e.output)] : [])
                    }
                    getTimeRange() {
                        var e = this._loader.json.accessors[this._config.input];
                        return e.min && e.max ? [e.min[0], e.max[0]] : [0, 0]
                    }
                    get config() {
                        return this._config
                    }
                }
                class ae {
                    constructor(e, t) {
                        this._totalTime = 0, this._name = e.name || "", this._loader = t, this._samplers = [], this._channels = [], this.parse(e)
                    }
                    parse(e) {
                        this.initSamplers(e.samplers), this.initChannels(e.channels)
                    }
                    initSamplers(e) {
                        if (e)
                            for (const t of e) this._samplers.push(new ie(t, this._loader))
                    }
                    initChannels(e) {
                        var t = [];
                        if (e)
                            for (const s of e) {
                                const e = new T(s, this._loader, this._samplers);
                                t.push(e.onLoad()), this._channels.push(e)
                            }
                        Promise.all(t).then(() => {
                            if (this._totalTime = this.calculateTotalTime(), !this._loader.animationEngine) throw new Error("No animation engine found!");
                            this._loader.animationEngine.addAnimation(this)
                        })
                    }
                    calculateTotalTime() {
                        let e = 0;
                        for (const s of this._channels) {
                            var t = s.sampler.getTimeRange();
                            t[1] > e && (e = t[1])
                        }
                        return e
                    }
                    update(e) {
                        for (const t of this._channels) t.update(e)
                    }
                    serialize() {
                        return {
                            channels: [],
                            samplers: []
                        }
                    }
                    get channels() {
                        return this._channels
                    }
                    get totalTime() {
                        return this._totalTime
                    }
                    get name() {
                        return this._name
                    }
                }
                var ne = t(1022),
                    oe = t(9720);
                class le {
                    constructor() {
                        this.signals = {
                            change: oe.M.create()
                        }, this._currentTime = 0, this._isPlaying = !1, this._animations = [], this._currentAnimationIndex = 0, this.onUpdate = () => {
                            var e = this._updater.time / 1e3;
                            e === this.totalTime ? this._currentTime = e : this._currentTime = c.M.mod(e, this.totalTime) || 0, null != (e = this.currentAnimation) && e.update(this._currentTime), this.signals.change.dispatch()
                        }, this._updater = new ne.F, this.init()
                    }
                    init() {
                        this._updater.init(this.onUpdate), this._isPlaying = !0
                    }
                    addAnimation(e) {
                        this._animations.push(e)
                    }
                    play() {
                        this.isPlaying() || (this._isPlaying = !0, this._updater.start(), this.signals.change.dispatch())
                    }
                    pause() {
                        this.isPlaying() && (this._isPlaying = !1, this._updater.stop(), this.signals.change.dispatch())
                    }
                    togglePlay() {
                        this.isPlaying() ? this.pause() : this.play()
                    }
                    seekTo(e) {
                        this._updater.seek(1e3 * e), this.signals.change.dispatch()
                    }
                    set speed(e) {
                        this._updater.speed !== e && (this._updater.speed = e, this.signals.change.dispatch())
                    }
                    set currentAnimation(e) {
                        e = this._animations.indexOf(e); - 1 !== e && (this._currentAnimationIndex = e)
                    }
                    get currentAnimation() {
                        return this._animations[this._currentAnimationIndex]
                    }
                    get animations() {
                        return this._animations
                    }
                    get speed() {
                        return this._updater.speed
                    }
                    isPlaying() {
                        return this._isPlaying
                    }
                    get totalTime() {
                        var e;
                        return (null == (e = this.currentAnimation) ? void 0 : e.totalTime) || 0
                    }
                    get currentTime() {
                        return this._currentTime
                    }
                }
                class he {
                    constructor(e) {
                        this._animations = [], this._accessors = {}, this._loader = e, this._engine = new le
                    }
                    parse() {
                        var e = this._loader.json.animations;
                        if (e)
                            for (const t of e) this._animations.push(new ae(t, this._loader))
                    }
                    async getAccessorData(n) {
                        return new Promise(async e => {
                            if (!this._accessors[n] && !this._accessors[n]) {
                                const e = this._loader.json.accessors[n],
                                    t = e.byteOffset || 0,
                                    s = h.s.accessorType2size(e.type),
                                    r = e.count * s,
                                    i = this._loader.getBufferView(n),
                                    a = _.oY.getClassForType(e.componentType);
                                if (i) {
                                    const e = await i.getData();
                                    this._accessors[n] = new a(e.buffer, e.byteOffset + t, r)
                                } else this._accessors[n] = new a(e.count)
                            }
                            e(this._accessors[n])
                        })
                    }
                    get engine() {
                        return this._engine
                    }
                }
                var w = t(3205),
                    E = t(8987),
                    C = t(6504),
                    y = t(4108),
                    A = t(503),
                    M = t(7375),
                    R = t(6040),
                    S = t(433),
                    N = t(3707),
                    I = t(4815);
                class P {}
                P.ID = "EXT_texture_webp";
                class F {}
                F.ID = "KHR_texture_basisu";
                var L = t(5396);
                class D extends e.a {
                    constructor(e = {}) {
                        super(e), this._baseUrl = "", this._json = void 0, this._bufferLoaders = [], this._bufferViews = [], this._sparseBufferViews = [], this._sceneNodes = [], this._files = null, this._promises = {
                            meshes: [],
                            textures: []
                        }, this.primitiveParserCache = {}, this._defaultFileName = "", this.onGLBLoaded = e => {
                            this.parse(e.jsonString)
                        }, this._factory = e.factory || new q(this), this._textureFactory = new o(this)
                    }
                    async loadFile(e, t) {
                        return new Promise(e => {
                            this.signals.loaded.addOnce(e), this._files = new re(t);
                            for (const e of this._files.mainFiles) this._defaultFileName = i.P.removeExtension(e.name), this.initBaseUrl(e.name), this._files.loadFile(e, e => {
                                e instanceof ArrayBuffer ? (this._glbLoader = new s.K, this._glbLoader.parse(e), this._glbLoader.failed ? this.completeLoad() : this.onGLBLoaded(this._glbLoader)) : this.parse(e)
                            })
                        })
                    }
                    load(e) {
                        return this._defaultFileName = i.P.removeExtension(i.P.getFileNameWithExtension(e)), this._files = null, this.initBaseUrl(e), super.load(e)
                    }
                    innerLoad(e) {
                        "glb" === i.P.getExtension(e) ? this.loadGLB(e) : super.innerLoad(e)
                    }
                    getFileUrl(e) {
                        return this.getUrl(decodeURI(e))
                    }
                    getUrl(e) {
                        return this._baseUrl ? this._baseUrl + "/" + e : e
                    }
                    loadGLB(e) {
                        this._glbLoader = new s.K, this._glbLoader.load(e, this.onGLBLoaded)
                    }
                    initBaseUrl(e) {
                        e = e.split("/");
                        e.pop(), this._baseUrl = e.join("/")
                    }
                    onXHRLoaded(e) {
                        this.parse(e.result)
                    }
                    parse(e) {
                        try {
                            this._json = JSON.parse(e)
                        } catch (e) {
                            return console.warn(e), void this.completeLoad()
                        }
                        this._textureFactory = new o(this), this._json.asset.version < "2.0" && console.warn("gltf 1.0 is not supported!"), this.parseExtensions(), this.parseBuffers(), this.parseBufferViews(), this.parseScenes(), this.parseAnimations(), this._defaultCamera && (this._scene.camera = this._defaultCamera), this.onAllMeshesLoaded().then(() => {
                            this.completeLoad()
                        })
                    }
                    async onAllMeshesLoaded() {
                        return Promise.all(this._promises.meshes)
                    }
                    parseExtensions() {
                        if (this._json.extensionsUsed)
                            for (const e of this._json.extensionsUsed) D.supportedExtensions[e] || console.warn("extension not supported:", e);
                        if (this._json.extensionsRequired)
                            for (const t of this._json.extensionsRequired) D.supportedExtensions[t] || console.error("extension not supported:", t)
                    }
                    parseBuffers() {
                        var t = this._json.buffers;
                        if (t)
                            for (let e = 0; e < t.length; ++e) this._bufferLoaders[e] = new Z(t[e], this)
                    }
                    parseBufferViews() {
                        var t = this._json.bufferViews;
                        if (t)
                            for (let e = 0; e < t.length; ++e) this._bufferViews[e] = new n(t[e], this)
                    }
                    createCamera(e) {
                        var t;
                        return "perspective" === e.type ? new te.c({
                            aspect: null == (t = e.perspective) ? void 0 : t.aspectRatio,
                            fovY: null == (t = e.perspective) ? void 0 : t.yfov,
                            near: null == (t = e.perspective) ? void 0 : t.znear,
                            far: null == (t = e.perspective) ? void 0 : t.zfar
                        }) : "orthographic" === e.type ? new se.i({
                            left: -1,
                            right: 1,
                            bottom: -1,
                            top: 1,
                            aspect: (null != (t = null == (t = e.orthographic) ? void 0 : t.xmag) ? t : 1) / (null != (t = null == (t = e.orthographic) ? void 0 : t.ymag) ? t : 1),
                            near: null == (t = e.orthographic) ? void 0 : t.znear,
                            far: null == (t = e.orthographic) ? void 0 : t.zfar
                        }) : void console.warn("Unknown camera type:", e)
                    }
                    parseScenes() {
                        var t = this._json.scenes;
                        for (let e = 0; e < t.length; ++e) {
                            var s = this.parseScene(t[e]);
                            s.name = s.name || this._defaultFileName || "Scene " + (e + 1), this._scenes[e] = s
                        }
                        var e = this._json.scene || 0;
                        this._scene = this._scenes[e]
                    }
                    parseScene(e) {
                        var t = new Q.x;
                        if (t.name = e.name || "", e.nodes)
                            for (const s of e.nodes) {
                                const e = this.getSceneNode(s);
                                t.add(e)
                            }
                        return t
                    }
                    parseAnimations() {
                        this._json.animations && (this._animationLoader = new he(this), this._animationLoader.parse())
                    }
                    getSceneNode(e) {
                        if (!this._sceneNodes[e]) {
                            var {
                                sceneNode: t,
                                meshPromise: s
                            } = this._factory.createSceneNode(e), s = (s && this._promises.meshes.push(s), this._sceneNodes[e] = t, this._json.nodes[e]);
                            if (s.children)
                                for (const e of s.children) {
                                    var r = this.getSceneNode(e);
                                    t.add(r)
                                }
                            if (c.M.isPositiveOrZero(s.camera)) {
                                const e = this._json.cameras[s.camera],
                                    i = this.createCamera(e);
                                i && (i.name = i.name || "Camera", t.add(i), this._defaultCamera = i)
                            }
                        }
                        return this._sceneNodes[e]
                    }
                    get bufferLoaders() {
                        return this._bufferLoaders
                    }
                    getBufferView(e) {
                        var t = this._json.accessors[e];
                        return (0, $.RW)(t) ? (this._sparseBufferViews[e] || (this._sparseBufferViews[e] = new l(t, this)), this._sparseBufferViews[e]) : c.M.isPositiveOrZero(t.bufferView) ? this._bufferViews[t.bufferView] : void 0
                    }
                    async getDracoLoader() {
                        var e;
                        return this._dracoLoader || (this._dracoLoaderModule || (this._dracoLoaderModule = t.e(849).then(t.bind(t, 4011))), e = await this._dracoLoaderModule, this._dracoLoader) || (this._dracoLoader = new e.DracoLoader), this._dracoLoader
                    }
                    get textureFactory() {
                        return this._textureFactory
                    }
                    get bufferViews() {
                        return this._bufferViews
                    }
                    get sceneNodes() {
                        return this._sceneNodes
                    }
                    get json() {
                        return this._json
                    }
                    get glbLoader() {
                        return this._glbLoader
                    }
                    get animationLoader() {
                        return this._animationLoader
                    }
                    get animationEngine() {
                        return this._animationLoader ? this._animationLoader.engine : null
                    }
                    get files() {
                        return this._files
                    }
                    get copyright() {
                        return this._json.asset
                    }
                }
                D.supportedExtensions = {
                    [f.j.ID]: f.j,
                    [g.W.ID]: g.W,
                    [v.T.ID]: v.T,
                    [w.X.ID]: w.X,
                    [L.V.ID]: L.V,
                    [E.O.ID]: E.O,
                    [C._.ID]: C._,
                    [y.I.ID]: y.I,
                    [A.H.ID]: A.H,
                    [M.q.ID]: M.q,
                    [R.o.ID]: R.o,
                    [S.n.ID]: S.n,
                    [N.j.ID]: N.j,
                    [I.w.ID]: I.w,
                    [P.ID]: P,
                    [F.ID]: F
                }
            },
            8396: (e, t, s) => {
                s.d(t, {
                    s: () => n
                });
                var r = s(540),
                    i = s(7934);
                class a {
                    constructor(e) {
                        this._material = -1, this._loader = e
                    }
                    async parse(e) {
                        var t;
                        return this._material = null != (t = e.material) ? t : -1, await this.parsePrimitiveCached(e), this.geometry
                    }
                    async parsePrimitiveCached(e) {
                        var t = this.getParserCacheKey(e);
                        this._loader.primitiveParserCache[t] ? (this._parser = this._loader.primitiveParserCache[t], await this._parser.onParsed()) : (this._parser = new r.J(this._loader), this._loader.primitiveParserCache[t] = this._parser, await this._parser.parse(e))
                    }
                    getParserCacheKey(e) {
                        var t, s = i.g.cloneViaJson(e);
                        for (const e in s.attributes) {
                            const r = s.attributes[e],
                                i = JSON.stringify(null == (t = this._loader.json.accessors) ? void 0 : t[r]);
                            s.attributes[e] = i, s.material = 0
                        }
                        return JSON.stringify(s)
                    }
                    get geometry() {
                        var e;
                        return null == (e = this._parser) ? void 0 : e.geometry
                    }
                    get material() {
                        return this._material
                    }
                    get boundingBox() {
                        var e;
                        return null == (e = this._parser) ? void 0 : e.boundingBox
                    }
                }
                class n {
                    constructor(e, t) {
                        this._primitives = [], this._promises = [], this._config = e, this._loader = t, this.init()
                    }
                    init() {
                        for (const e of this._config.primitives) this._promises.push(this.parsePrimitive(e))
                    }
                    async onLoaded() {
                        await Promise.all(this._promises)
                    }
                    async parsePrimitive(e) {
                        var t = new a(this._loader);
                        await t.parse(e) && this._primitives.push(t)
                    }
                    get primitives() {
                        return this._primitives
                    }
                    get name() {
                        return this._config.name
                    }
                    get weights() {
                        return this._config.weights
                    }
                    static accessorSize2type(e) {
                        if (1 === e) return "SCALAR";
                        if (2 === e) return "VEC2";
                        if (3 === e) return "VEC3";
                        if (4 === e) return "VEC4";
                        if (9 === e) return "MAT3";
                        if (16 === e) return "MAT4";
                        throw new Error("Unknown accessor size: " + e)
                    }
                    static accessorType2size(e) {
                        let t = 1;
                        return -1 < e.indexOf("VEC") ? t = Number(e.substr(3, 1)) : -1 < e.indexOf("MAT") && (e = Number(e.substr(3, 1)), t = e * e), t
                    }
                }
            },
            540: (e, t, s) => {
                s.d(t, {
                    J: () => _
                });
                var r = s(1695),
                    i = s(5216),
                    l = s(604),
                    a = s(8396),
                    h = s(6407),
                    n = s(82),
                    o = s(387),
                    c = s(6385),
                    d = s(4735),
                    u = s(9720),
                    p = s(1201),
                    m = s(428),
                    g = s(3829);
                class _ {
                    static createAttribute(e, t, s) {
                        return {
                            byteOffset: e.byteOffset || 0,
                            byteStride: s.byteStride,
                            size: a.s.accessorType2size(e.type),
                            sizeY: 1,
                            componentType: e.componentType,
                            semantic: t,
                            count: e.count,
                            normalized: null != (t = e.normalized) && t,
                            name: e.name || "",
                            buffer: s
                        }
                    }
                    constructor(e) {
                        this.signals = {
                            parsed: u.M.create()
                        }, this._parsed = !1, this._count = 0, this._attributedBufferConfigs = new Map, this._loader = e
                    }
                    async onParsed() {
                        return new Promise(e => {
                            this._parsed ? e() : this.signals.parsed.addOnce(() => {
                                e()
                            })
                        })
                    }
                    async parse(t) {
                        const s = t.extensions && t.extensions[c.T.ID];
                        if (s) this._geometry = await this.parseDracoGeometry(s);
                        else {
                            this._count = 0, this._attributedBufferConfigs = new Map;
                            const s = [];
                            for (const n in t.attributes) {
                                var r = t.attributes[n],
                                    r = this.parseAttribute(r, n);
                                s.push(r)
                            }
                            if (t.targets)
                                for (let e = 0; e < t.targets.length; ++e) {
                                    var i = t.targets[e];
                                    for (const t in i) {
                                        const o = i[t],
                                            l = d.p.getMorph(t, e);
                                        s.push(this.parseAttribute(o, l))
                                    }
                                }
                            let e;
                            await Promise.all(s), h.M.isValidNumber(t.indices) && (e = await this.createIndexBuffer(t.indices)) && (this._count = e.count);
                            var a = this.createAttributedBuffers();
                            this._geometry = new l.Z({
                                indexBuffer: e,
                                buffers: a,
                                mode: t.mode,
                                start: 0,
                                count: this._count
                            })
                        }
                        return this._parsed = !0, this.signals.parsed.dispatch(), this._geometry
                    }
                    async parseAttribute(t, s) {
                        var r = null == (r = this._loader.json.accessors) ? void 0 : r[t];
                        if (r) {
                            if (0 < this._count && r.count !== this._count) throw new Error("Count is not the same for each accessor in Mesh!");
                            this._count = r.count;
                            var i = this._loader.getBufferView(t);
                            if (i) {
                                let e = this._attributedBufferConfigs.get(i);
                                if (!e) {
                                    const t = await i.getBuffer();
                                    (e = this._attributedBufferConfigs.get(i)) || (e = {
                                        buffer: t,
                                        attributes: []
                                    }, this._attributedBufferConfigs.set(i, e))
                                }
                                i.byteOffset % 4 != 0 && console.warn("byteOffset should be aligned to 4-byte!");
                                i = _.createAttribute(r, s, e.buffer);
                                e.attributes.push(i), s === d.p.POSITION && this.updateBoundingBox(r)
                            } else console.warn("undefined bufferview not implemented: " + t)
                        } else console.warn("Accessor not found for id: " + t)
                    }
                    async parseDracoGeometry(e) {
                        var t = this._loader.json.bufferViews[e.bufferView],
                            s = await this._loader.bufferLoaders[t.buffer].getArraybuffer(),
                            s = new Int8Array(s, t.byteOffset, t.byteLength);
                        return (await this._loader.getDracoLoader()).decodeBuffer(e, s)
                    }
                    createAttributedBuffers() {
                        return Array.from(this._attributedBufferConfigs.values()).map(e => new r.t(e))
                    }
                    async createIndexBuffer(t) {
                        var s = null == (s = this._loader.json.accessors) ? void 0 : s[t];
                        if (s) {
                            var r = this._loader.getBufferView(t);
                            let e = await (null == r ? void 0 : r.getBuffer(p.g.ELEMENT_ARRAY_BUFFER));
                            if (!e) {
                                const t = g.oY.getClassForType(s.componentType);
                                e = new m.f({
                                    name: s.name,
                                    data: new t(s.count),
                                    byteStride: 0,
                                    target: p.g.ELEMENT_ARRAY_BUFFER
                                })
                            }
                            return new i.Y({
                                buffer: e,
                                componentType: s.componentType,
                                byteOffset: s.byteOffset,
                                count: s.count
                            })
                        }
                        console.warn("Accessor not found for id: " + t)
                    }
                    updateBoundingBox(e) {
                        var t, s;
                        e.min && e.max && (t = n.R.copy(n.R.create(), e.min), s = n.R.copy(n.R.create(), e.max), "VEC2" === e.type && (t[2] = 0, s[2] = 0), this._boundingBox = new o.x(t, s))
                    }
                    get geometry() {
                        return this._geometry
                    }
                    get boundingBox() {
                        return this._boundingBox
                    }
                }
            },
            8766: (e, t, s) => {
                s.d(t, {
                    K: () => n
                });
                var r = s(1668),
                    a = s(5081);
                class n {
                    constructor() {
                        this._arraybuffer = new ArrayBuffer(0), this._header = {
                            magic: 0,
                            version: 0,
                            length: 0
                        }, this._jsonString = "", this._buffer = new ArrayBuffer(0), this._failed = !1, this.onComplete = e => {
                            e.successful ? this.parse(e.xhr.response) : this.fail("Couldn't load buffer: " + e.result), null != (e = this._onLoaded) && e.call(this, this)
                        }
                    }
                    load(e, t) {
                        this._onLoaded = t, r.i.load({
                            url: e,
                            responseType: "arraybuffer",
                            onComplete: this.onComplete
                        })
                    }
                    parse(e) {
                        this._arraybuffer = e, this._header = this.parseHeader(), this._header.magic === n.HEADER_MAGIC ? this._header.version < 2 ? this.fail("glTF 1 not supported!") : this.parseChunks() : this.fail("Wrong header in .glb file! Magic doesn't match.")
                    }
                    parseHeader() {
                        var e = new DataView(this._arraybuffer, 0, n.HEADER_LENGTH);
                        return {
                            magic: e.getUint32(0, !0),
                            version: e.getUint32(4, !0),
                            length: e.getUint32(8, !0)
                        }
                    }
                    parseChunks() {
                        const e = new DataView(this._arraybuffer, n.HEADER_LENGTH),
                            t = this._header.length - n.HEADER_LENGTH;
                        t !== e.byteLength && console.warn("length mismatch?");
                        let s = 0;
                        for (; s < t;) {
                            const t = e.getUint32(s, !0);
                            s += 4;
                            var r = e.getUint32(s, !0),
                                i = (s += 4, n.HEADER_LENGTH + s);
                            if (r === n.CHUNKTYPE_JSON) {
                                const e = new Uint8Array(this._arraybuffer, i, t);
                                this._jsonString = a.W.arraybuffer2string(e)
                            } else r === n.CHUNKTYPE_BIN && (this._buffer = this._arraybuffer.slice(i, i + t));
                            s += t
                        }
                    }
                    fail(e) {
                        this._failed = !0, console.error(e)
                    }
                    get failed() {
                        return this._failed
                    }
                    get jsonString() {
                        return this._jsonString
                    }
                    get buffer() {
                        return this._buffer
                    }
                }
                n.HEADER_LENGTH = 12, n.HEADER_MAGIC = 1179937895, n.CHUNKTYPE_JSON = 1313821514, n.CHUNKTYPE_BIN = 5130562, n.CHUNK_PREFIX_LENGTH = 8
            },
            4427: (e, t, s) => {
                s.d(t, {
                    J: () => i,
                    W: () => r
                });
                const r = 80,
                    i = "model/stl"
            },
            9866: (e, t, s) => {
                s.d(t, {
                    F: () => o,
                    N: () => r
                });
                var r, i = s(7054),
                    a = s(6407),
                    n = s(6039);
                (t = r = r || {})[t.FRONT = 0] = "FRONT", t[t.BACK = 1] = "BACK", t[t.DOUBLE = 2] = "DOUBLE";
                class o {
                    constructor(e) {
                        var t;
                        this.id = ++o.highestId, this._wireframe = !1, this._equalsKey = "", this.onTextureChange = () => {
                            this._equalsKey = ""
                        }, this._side = null != (t = e.side) ? t : r.FRONT, this._configM = e, this._name = e.name || "", this._alphaMode = null != (t = e.alphaMode) ? t : i.mM.OPAQUE, this._alphaCutoff = null != (t = e.alphaCutoff) ? t : .5, this._ior = null != (t = e.ior) ? t : 1.5, this._emissiveTexture = null != (t = e.emissiveTexture) ? t : new n.l, this._emissiveFactor = a.M.isPositiveOrZero(e.emissiveFactor) ? e.emissiveFactor : 0, this._emissiveStrength = null != (t = e.emissiveStrength) ? t : 1, this._occlusionTexture = null != (t = e.occlusionTexture) ? t : new n.l, this._occlusionStrength = a.M.isPositiveOrZero(e.occlusionStrength) ? e.occlusionStrength : 1, this._normalTexture = null != (t = e.normalTexture) ? t : new n.l, this._normalScale = a.M.isPositiveOrZero(e.normalScale) ? e.normalScale : 1, this._transmissionFactor = null != (t = e.transmissionFactor) ? t : 0, this._transmissionTexture = null != (t = e.transmissionTexture) ? t : new n.l, this._sheenColorFactor = null != (t = e.sheenColorFactor) ? t : 0, this._sheenColorTexture = null != (t = e.sheenColorTexture) ? t : new n.l, this._sheenRoughnessFactor = null != (t = e.sheenRoughnessFactor) ? t : 0, this._sheenRoughnessTexture = null != (t = e.sheenRoughnessTexture) ? t : new n.l, this._clearcoatFactor = null != (t = e.clearcoatFactor) ? t : 0, this._clearcoatTexture = null != (t = e.clearcoatTexture) ? t : new n.l, this._clearcoatRoughnessFactor = null != (t = e.clearcoatRoughnessFactor) ? t : 0, this._clearcoatRoughnessTexture = null != (t = e.clearcoatRoughnessTexture) ? t : new n.l, this._clearcoatNormalTexture = null != (t = e.clearcoatNormalTexture) ? t : new n.l, this._clearcoatNormalScale = a.M.isPositiveOrZero(e.normalScale) ? e.normalScale : 1, this._thicknessFactor = null != (t = e.thicknessFactor) ? t : 0, this._thicknessTexture = null != (t = e.thicknessTexture) ? t : new n.l, this._attenuationDistance = null != (t = e.attenuationDistance) ? t : 1 / 0, this._attenuationColor = null != (t = e.attenuationColor) ? t : 16777215, this._anisotropyStrength = null != (t = e.anisotropyStrength) ? t : 0, this._anisotropyRotation = null != (t = e.anisotropyStrength) ? t : 0, this._anisotropyTexture = null != (t = e.anisotropyTexture) ? t : new n.l, this._specularFactor = null != (t = e.specularFactor) ? t : 1, this._specularTexture = null != (t = e.specularTexture) ? t : new n.l, this._specularColorFactor = null != (t = e.specularColorFactor) ? t : 16777215, this._specularColorTexture = null != (t = e.specularColorTexture) ? t : new n.l, this._emissiveTexture.change.add(this.onTextureChange), this._occlusionTexture.change.add(this.onTextureChange), this._normalTexture.change.add(this.onTextureChange), this._transmissionTexture.change.add(this.onTextureChange), this._sheenColorTexture.change.add(this.onTextureChange), this._sheenRoughnessTexture.change.add(this.onTextureChange), this._clearcoatTexture.change.add(this.onTextureChange), this._clearcoatRoughnessTexture.change.add(this.onTextureChange), this._clearcoatNormalTexture.change.add(this.onTextureChange), this._thicknessTexture.change.add(this.onTextureChange), this._anisotropyTexture.change.add(this.onTextureChange), this._specularTexture.change.add(this.onTextureChange), this._specularColorTexture.change.add(this.onTextureChange)
                    }
                    cloneConfig() {
                        return {
                            name: this.name,
                            side: this.side,
                            alphaMode: this.alphaMode,
                            alphaCutoff: this.alphaCutoff,
                            ior: this.ior,
                            normalTexture: this._normalTexture.clone(),
                            normalScale: this.normalScale,
                            occlusionTexture: this._occlusionTexture.clone(),
                            occlusionStrength: this.occlusionStrength,
                            emissiveTexture: this._emissiveTexture.clone(),
                            emissiveFactor: this.emissiveFactor,
                            emissiveStrength: this.emissiveStrength,
                            transmissionFactor: this.transmissionFactor,
                            transmissionTexture: this._transmissionTexture.clone(),
                            sheenColorFactor: this._sheenColorFactor,
                            sheenColorTexture: this._sheenColorTexture.clone(),
                            sheenRoughnessFactor: this.sheenRoughnessFactor,
                            sheenRoughnessTexture: this._sheenRoughnessTexture.clone(),
                            clearcoatFactor: this._clearcoatFactor,
                            clearcoatTexture: this._clearcoatTexture.clone(),
                            clearcoatRoughnessFactor: this._clearcoatRoughnessFactor,
                            clearcoatRoughnessTexture: this._clearcoatRoughnessTexture.clone(),
                            clearcoatNormalTexture: this._clearcoatNormalTexture.clone(),
                            thicknessFactor: this._thicknessFactor,
                            thicknessTexture: this._thicknessTexture.clone(),
                            attenuationDistance: this._attenuationDistance,
                            attenuationColor: this._attenuationColor,
                            anisotropyStrength: this._anisotropyStrength,
                            anisotropyRotation: this._anisotropyRotation,
                            anisotropyTexture: this._anisotropyTexture.clone(),
                            specularFactor: this._specularFactor,
                            specularTexture: this._specularTexture.clone(),
                            specularColorFactor: this._specularColorFactor,
                            specularColorTexture: this._specularColorTexture.clone()
                        }
                    }
                    get transparent() {
                        return this.alphaMode === i.mM.BLEND
                    }
                    set alphaMode(e) {
                        e !== this._alphaMode && (this._alphaMode = e, this._equalsKey = "")
                    }
                    get alphaMode() {
                        return this._alphaMode
                    }
                    set alphaCutoff(e) {
                        e !== this._alphaCutoff && (this._alphaCutoff = e, this._equalsKey = "")
                    }
                    get alphaCutoff() {
                        return this._alphaCutoff
                    }
                    set ior(e) {
                        e !== this._ior && (this._ior = e, this._equalsKey = "")
                    }
                    get ior() {
                        return this._ior
                    }
                    set side(e) {
                        e !== this._side && (this._side = e, this._equalsKey = "")
                    }
                    get side() {
                        return this._side
                    }
                    set name(e) {
                        this._name = e
                    }
                    get name() {
                        return this._name
                    }
                    get doubleSided() {
                        return this.side === r.DOUBLE
                    }
                    get transmissionTextureInfo() {
                        return this._transmissionTexture
                    }
                    set transmissionFactor(e) {
                        e !== this._transmissionFactor && (this._transmissionFactor = e, this._equalsKey = "")
                    }
                    get transmissionFactor() {
                        return this._transmissionFactor
                    }
                    set specularFactor(e) {
                        e !== this._specularFactor && (this._specularFactor = e, this._equalsKey = "")
                    }
                    get specularFactor() {
                        return this._specularFactor
                    }
                    set specularColorFactor(e) {
                        e !== this._specularColorFactor && (this._specularColorFactor = e, this._equalsKey = "")
                    }
                    get specularColorFactor() {
                        return this._specularColorFactor
                    }
                    get specularTextureInfo() {
                        return this._specularTexture
                    }
                    get specularColorTextureInfo() {
                        return this._specularColorTexture
                    }
                    set sheenColorFactor(e) {
                        e !== this._sheenColorFactor && (this._sheenColorFactor = e, this._equalsKey = "")
                    }
                    get sheenColorFactor() {
                        return this._sheenColorFactor
                    }
                    set sheenRoughnessFactor(e) {
                        e !== this._sheenRoughnessFactor && (this._sheenRoughnessFactor = e, this._equalsKey = "")
                    }
                    get sheenRoughnessFactor() {
                        return this._sheenRoughnessFactor
                    }
                    get sheenColorTextureInfo() {
                        return this._sheenColorTexture
                    }
                    get sheenRoughnessTextureInfo() {
                        return this._sheenRoughnessTexture
                    }
                    set clearcoatFactor(e) {
                        e !== this._clearcoatFactor && (this._clearcoatFactor = e, this._equalsKey = "")
                    }
                    get clearcoatFactor() {
                        return this._clearcoatFactor
                    }
                    get clearcoatTextureInfo() {
                        return this._clearcoatTexture
                    }
                    set clearcoatRoughnessFactor(e) {
                        e !== this._clearcoatRoughnessFactor && (this._clearcoatRoughnessFactor = e, this._equalsKey = "")
                    }
                    get clearcoatRoughnessFactor() {
                        return this._clearcoatRoughnessFactor
                    }
                    get clearcoatRoughnessTextureInfo() {
                        return this._clearcoatRoughnessTexture
                    }
                    get clearcoatNormalTextureInfo() {
                        return this._clearcoatNormalTexture
                    }
                    set clearcoatNormalScale(e) {
                        e !== this._normalScale && (this._clearcoatNormalScale = e, this._equalsKey = "")
                    }
                    get clearcoatNormalScale() {
                        return this._clearcoatNormalScale
                    }
                    get thicknessTextureInfo() {
                        return this._thicknessTexture
                    }
                    set thicknessFactor(e) {
                        e !== this._thicknessFactor && (this._thicknessFactor = e, this._equalsKey = "")
                    }
                    get thicknessFactor() {
                        return this._thicknessFactor
                    }
                    set attenuationDistance(e) {
                        e !== this._attenuationDistance && (this._attenuationDistance = e, this._equalsKey = "")
                    }
                    get attenuationDistance() {
                        return this._attenuationDistance
                    }
                    set attenuationColor(e) {
                        e !== this._attenuationColor && (this._attenuationColor = e, this._equalsKey = "")
                    }
                    get attenuationColor() {
                        return this._attenuationColor
                    }
                    get anisotropyTextureInfo() {
                        return this._anisotropyTexture
                    }
                    set anisotropyStrength(e) {
                        e !== this._anisotropyStrength && (this._anisotropyStrength = e, this._equalsKey = "")
                    }
                    get anisotropyStrength() {
                        return this._anisotropyStrength
                    }
                    set anisotropyRotation(e) {
                        e !== this._anisotropyRotation && (this._anisotropyRotation = e, this._equalsKey = "")
                    }
                    get anisotropyRotation() {
                        return this._anisotropyRotation
                    }
                    get emissiveTextureInfo() {
                        return this._emissiveTexture
                    }
                    set emissiveFactor(e) {
                        e !== this._emissiveFactor && (this._emissiveFactor = e, this._equalsKey = "")
                    }
                    get emissiveFactor() {
                        return this._emissiveFactor
                    }
                    get emissiveStrength() {
                        return this._emissiveStrength
                    }
                    set emissiveStrength(e) {
                        e !== this._emissiveStrength && (this._emissiveStrength = e, this._equalsKey = "")
                    }
                    set occlusionStrength(e) {
                        e !== this._occlusionStrength && (this._occlusionStrength = e, this._equalsKey = "")
                    }
                    get occlusionTextureInfo() {
                        return this._occlusionTexture
                    }
                    get occlusionStrength() {
                        return this._occlusionStrength
                    }
                    get normalTextureInfo() {
                        return this._normalTexture
                    }
                    set normalScale(e) {
                        e !== this._normalScale && (this._normalScale = e, this._equalsKey = "")
                    }
                    get normalScale() {
                        return this._normalScale
                    }
                    set wireframe(e) {
                        e !== this._wireframe && (this._wireframe = e, this._equalsKey = "")
                    }
                    get wireframe() {
                        return this._wireframe
                    }
                    getEqualsKey() {
                        var e = `${this._normalTexture.channel}-${this._occlusionTexture.channel}-${this._emissiveTexture.channel}-` + this._transmissionTexture.channel,
                            t = `${this._normalTexture.transform.getKey()}-${this._occlusionTexture.transform.getKey()}-${this._emissiveTexture.transform.getKey()}-` + this._transmissionTexture.transform.getKey(),
                            s = e + `-${null!=(s=null==(s=this.emissiveTextureInfo.texture)?void 0:s.id)?s:0}-${null!=(s=null==(s=this.normalTextureInfo.texture)?void 0:s.id)?s:0}-${null!=(s=null==(s=this.occlusionTextureInfo.texture)?void 0:s.id)?s:0}-` + (null != (s = null == (s = this.transmissionTextureInfo.texture) ? void 0 : s.id) ? s : 0);
                        return `${this.side}-${this.alphaMode}-${this.alphaCutoff}-${this.ior}-${this.emissiveFactor}-${this.emissiveStrength}-${this.normalScale}-${this.occlusionStrength}-` + this.wireframe + s + e + t
                    }
                }
                o.highestId = 0
            },
            6039: (e, t, s) => {
                s.d(t, {
                    l: () => a
                });
                var r = s(9720),
                    i = s(6438);
                class a {
                    constructor(e = {
                        texture: void 0
                    }) {
                        var t;
                        this.change = r.M.create(), this._texture = e.texture, this._channel = null != (t = e.channel) ? t : 0, this._transform = null != (t = e.transform) ? t : new i.I, this._transform.change.add(this.onTransformChange, this)
                    }
                    onTransformChange() {
                        this.change.dispatch()
                    }
                    clone() {
                        return new a({
                            texture: this.texture,
                            channel: this.channel,
                            transform: this._transform.clone()
                        })
                    }
                    set texture(e) {
                        this._texture !== e && (this._texture = e, this.change.dispatch())
                    }
                    get texture() {
                        return this._texture
                    }
                    hasTexture() {
                        return void 0 !== this._texture
                    }
                    set channel(e) {
                        this._channel !== e && (this._channel = e, this.change.dispatch())
                    }
                    get channel() {
                        return this._channel
                    }
                    get transform() {
                        return this._transform
                    }
                }
            },
            6646: (e, t, s) => {
                s.d(t, {
                    q: () => n
                });
                var t = s(9866),
                    r = s(6407),
                    i = s(6039),
                    a = s(7054);
                class n extends t.F {
                    constructor(e = {}) {
                        var t, s = r.M.isPositiveOrZero(e.baseColorAlpha) ? e.baseColorAlpha : 1;
                        !e.alphaMode && s < 1 && (e.alphaMode = a.mM.BLEND), super(e), this._baseColorTexture = null != (t = e.baseColorTexture) ? t : new i.l, this._metallicRoughnessTexture = null != (t = e.metallicRoughnessTexture) ? t : new i.l, this._baseColorFactor = r.M.isPositiveOrZero(e.baseColorFactor) ? e.baseColorFactor : 16777215, this._baseColorAlpha = s, this._metallicFactor = r.M.isPositiveOrZero(e.metallicFactor) ? e.metallicFactor : 1, this._roughnessFactor = r.M.isPositiveOrZero(e.roughnessFactor) ? e.roughnessFactor : 1, this._baseColorTexture.change.add(this.onTextureChange), this._metallicRoughnessTexture.change.add(this.onTextureChange)
                    }
                    clone(e = 0) {
                        return new n({ ...this.cloneConfig(),
                            baseColorAlpha: this.baseColorAlpha,
                            baseColorFactor: this.baseColorFactor,
                            baseColorTexture: this._baseColorTexture.clone(),
                            metallicFactor: this.metallicFactor,
                            roughnessFactor: this.roughnessFactor,
                            metallicRoughnessTexture: this._metallicRoughnessTexture.clone()
                        })
                    }
                    get baseColorTextureInfo() {
                        return this._baseColorTexture
                    }
                    get metallicRoughnessTextureInfo() {
                        return this._metallicRoughnessTexture
                    }
                    set baseColorFactor(e) {
                        e !== this._baseColorFactor && (this._baseColorFactor = e, this._equalsKey = "")
                    }
                    get baseColorFactor() {
                        return this._baseColorFactor
                    }
                    set baseColorAlpha(e) {
                        e !== this._baseColorAlpha && (this._baseColorAlpha = e, this._equalsKey = "")
                    }
                    get baseColorAlpha() {
                        return this._baseColorAlpha
                    }
                    set metallicFactor(e) {
                        e !== this._metallicFactor && (this._metallicFactor = e, this._equalsKey = "")
                    }
                    get metallicFactor() {
                        return this._metallicFactor
                    }
                    set roughnessFactor(e) {
                        e !== this._roughnessFactor && (this._roughnessFactor = e, this._equalsKey = "")
                    }
                    get roughnessFactor() {
                        return this._roughnessFactor
                    }
                    getEqualsKey() {
                        var e, t, s, r;
                        return this._equalsKey || (e = this._baseColorTexture.channel + "-" + this._metallicRoughnessTexture.channel, t = this._baseColorTexture.transform.getKey() + "-" + this._metallicRoughnessTexture.transform.getKey(), s = `${null!=(s=null==(s=this._baseColorTexture.texture)?void 0:s.id)?s:0}-${e}-` + (null != (s = null == (s = this._metallicRoughnessTexture.texture) ? void 0 : s.id) ? s : 0), r = `${this._baseColorAlpha}-${this._baseColorFactor.toString(16)}-${this._metallicFactor}-` + this.roughnessFactor, this._equalsKey = super.getEqualsKey() + `-${r}-${s}-${e}-` + t), this._equalsKey
                    }
                }
            },
            9894: (e, t, s) => {
                s.d(t, {
                    z: () => i
                });
                var t = s(9866),
                    r = s(6039);
                class i extends t.F {
                    constructor(e = {}) {
                        var t;
                        super(e), this._baseColorTexture = null != (t = e.baseColorTexture) ? t : new r.l, this._baseColorFactor = null != (t = e.baseColorFactor) ? t : 16777215, this._baseColorAlpha = null != (t = e.baseColorAlpha) ? t : 1, this.baseColorTextureInfo.transform.change.add(this.onTextureChange)
                    }
                    clone() {
                        return new i({ ...this.cloneConfig(),
                            baseColorAlpha: this.baseColorAlpha,
                            baseColorFactor: this.baseColorFactor,
                            baseColorTexture: this._baseColorTexture.clone()
                        })
                    }
                    get baseColorTextureInfo() {
                        return this._baseColorTexture
                    }
                    set baseColorFactor(e) {
                        this._baseColorFactor = e
                    }
                    get baseColorFactor() {
                        return this._baseColorFactor
                    }
                    set baseColorAlpha(e) {
                        this._baseColorAlpha = e
                    }
                    get baseColorAlpha() {
                        return this._baseColorAlpha
                    }
                    getEqualsKey() {
                        var e = "" + this._baseColorTexture.channel,
                            t = "" + this._baseColorTexture.transform.getKey(),
                            s = `${null!=(s=null==(s=this._baseColorTexture.texture)?void 0:s.id)?s:0}-` + e,
                            r = this._baseColorAlpha + "-" + this._baseColorFactor.toString(16);
                        return super.getEqualsKey() + `-${r}-${s}-${e}-` + t
                    }
                }
            },
            651: (e, t, s) => {
                s.d(t, {
                    x: () => n
                });
                var t = s(4955),
                    r = s(9720),
                    i = s(7409),
                    a = s(7723);
                class n extends t.B {
                    invalidateWorldMatrix(e) {
                        const t = this._changedNodeDepths.get(e);
                        if (void 0 !== t && -1 < t && t !== e.depth) {
                            const s = this._changedNodesByDepth.get(t);
                            s && s.delete(e)
                        }
                        let s = this._changedNodesByDepth.get(e.depth);
                        s || (s = new Set, this._changedNodesByDepth.set(e.depth, s)), s.add(e), this._changedNodeDepths.set(e, e.depth);
                        for (const t of e.children) this.invalidateWorldMatrix(t)
                    }
                    updateWorldMatrices() {
                        const e = Array.from(this._changedNodesByDepth.keys()).sort((e, t) => e - t);
                        for (const t of e) {
                            const e = this._changedNodesByDepth.get(t);
                            if (e)
                                for (const s of e) this.updateWorldMatrix(s)
                        }
                        this._changedNodesByDepth.clear(), this._changedNodeDepths.clear()
                    }
                    updateWorldMatrix(e) {
                        var t = e.worldMatrix,
                            s = e.getParent();
                        s ? s.worldMatrix ? a._.multiply(t, s.worldMatrix, e.transform.mat) : (a._.copy(t, e.transform.mat), console.warn("Parent world matrix not found.")) : a._.copy(t, e.transform.mat)
                    }
                    allocateBuffers() {
                        for (const e of this._changedNodesByDepth.values())
                            for (const t of e) t.renderNodes.length
                    }
                    constructor(e = "") {
                        super({
                            name: e
                        }), this.signals = {
                            change: r.M.create(),
                            tree: r.M.create(),
                            select: r.M.create()
                        }, this._lights = {
                            sun: {
                                direction: new Float32Array([1, 1, 1]),
                                color: 16777215,
                                intensity: 1
                            },
                            ambient: {
                                color: 16777215,
                                intensity: 0
                            },
                            ibl: {
                                intensity: 1
                            }
                        }, this._instanceMatrices = new Map, this._changedNodesByDepth = new Map, this._changedNodeDepths = new Map, this.onTreeChange = () => {
                            this.signals.change.dispatch()
                        }, this.name = e, this.background = new i.$, this.signals.tree.add(this.onTreeChange), this._scene = this
                    }
                    set camera(e) {
                        this._camera = e
                    }
                    get camera() {
                        return this._camera
                    }
                    set scene(e) {
                        console.warn("Scene.scene is always 'this'.")
                    }
                    get scene() {
                        return this
                    }
                    get depth() {
                        return 0
                    }
                    get lights() {
                        return this._lights
                    }
                    clone(t = !1, s = !1) {
                        const r = new n(this.name);
                        return this.renderNodes.map(e => e.clone(t, s)).forEach(e => r.addRenderNode(e)), this.children.map(e => e.clone(t, s)).forEach(e => r.add(e)), r
                    }
                    dispose(e = 0) {
                        console.warn("Scene dispose not implemented.")
                    }
                }
            },
            7409: (e, t, s) => {
                s.d(t, {
                    $: () => r
                });
                class r {
                    constructor(e = 1579032) {
                        this._color = e
                    }
                    set color(e) {
                        this._color = e
                    }
                    get color() {
                        return this._color
                    }
                }
            },
            4375: (e, t, s) => {
                s.d(t, {
                    h: () => l
                });
                var r = s(82),
                    i = s(7723);
                class a {
                    constructor(e, t = !0) {
                        this.source = e, this.dirty = t
                    }
                    setValue(e) {
                        this.source !== e && (this.source = e, this.dirty = !0)
                    }
                }
                var t = s(4955),
                    n = s(4740),
                    o = s(7734);
                class l extends t.B {
                    constructor(e) {
                        super({
                            type: n.p.INVISIBLE
                        }), this.ignoreInBoundingBox = !0, this._viewMatrix = new a(i._.create()), this._projectionMatrix = new a(i._.create()), this._viewProjectionMatrix = new a(i._.create()), this._inverseViewProjectionMatrix = new a(i._.create()), this._viewportWidth = 0, this._viewportHeight = 0, this._aspect = 1, this.lookAt([0, 0, 0], [0, 0, 100], [0, 1, 0]), this._near = e.near || l.defaultConfig.near, this._far = e.far || l.defaultConfig.far, this.aspect = e.aspect || l.defaultConfig.aspect
                    }
                    set near(e) {
                        this._near = e, this.markProjectionDirty()
                    }
                    get near() {
                        return this._near
                    }
                    set far(e) {
                        this._far = e, this.markProjectionDirty()
                    }
                    get far() {
                        return this._far
                    }
                    getViewMatrix() {
                        var e = this._viewMatrix;
                        return e.dirty && (this.calculateViewMatrix(), e.dirty = !1), i._.invert(i._.create(), this.calculateWorldMatrix()) || i._.identity(i._.create())
                    }
                    getEye(e = r.R.create()) {
                        return o.x.getTranslation(this.calculateWorldMatrix(), e)
                    }
                    getProjectionMatrix() {
                        var e = this._projectionMatrix;
                        return e.dirty && (this.calculateProjectionMatrix(), e.dirty = !1), e.source
                    }
                    calculateViewMatrix() {
                        i._.invert(this._viewMatrix.source, this.calculateWorldMatrix())
                    }
                    lookAt(e, t, s) {
                        super.lookAt(e, t, s), this.markViewDirty()
                    }
                    lookAtLocal(e, t, s) {
                        super.lookAtLocal(e, t, s), this.markViewDirty()
                    }
                    getViewProjectionMatrix() {
                        var e = this._viewProjectionMatrix;
                        return e.dirty && (i._.multiply(e.source, this.getProjectionMatrix(), this.getViewMatrix()), e.dirty = !1), e.source
                    }
                    getInverseViewProjectionMatrix() {
                        var e = this._inverseViewProjectionMatrix;
                        return e.dirty && (i._.invert(e.source, this.getViewProjectionMatrix()), e.dirty = !1), e.source
                    }
                    setViewport(e, t) {
                        this._viewportWidth = e, this._viewportHeight = t, this._aspect = this._viewportWidth / this._viewportHeight, this.markProjectionDirty()
                    }
                    get viewportWidth() {
                        return this._viewportWidth
                    }
                    get viewportHeight() {
                        return this._viewportHeight
                    }
                    set aspect(e) {
                        this._aspect = e, this._viewportWidth = 0, this._viewportHeight = 0, this.markProjectionDirty()
                    }
                    get aspect() {
                        return this._aspect
                    }
                    markProjectionDirty() {
                        this._projectionMatrix.dirty = !0, this._viewProjectionMatrix.dirty = !0, this._inverseViewProjectionMatrix.dirty = !0
                    }
                    markViewDirty() {
                        this._viewMatrix.dirty = !0, this._viewProjectionMatrix.dirty = !0, this._inverseViewProjectionMatrix.dirty = !0
                    }
                }
                l.defaultConfig = {
                    near: .1,
                    far: 1e4,
                    aspect: 1
                }
            },
            5979: (e, t, s) => {
                s.d(t, {
                    i: () => a
                });
                var r = s(4233),
                    i = s(7723);
                class a extends s(4375).h {
                    constructor(e = a.defaultConfigOrthographic) {
                        var t;
                        super(e), this._left = null != (t = e.left) ? t : a.defaultConfigOrthographic.left, this._right = null != (t = e.right) ? t : a.defaultConfigOrthographic.right, this._bottom = null != (t = e.bottom) ? t : a.defaultConfigOrthographic.bottom, this._top = null != (t = e.top) ? t : a.defaultConfigOrthographic.top, this._zoom = null != (t = e.zoom) ? t : a.defaultConfigOrthographic.zoom
                    }
                    set left(e) {
                        this._left = e, this.markProjectionDirty()
                    }
                    get left() {
                        return this._left
                    }
                    set right(e) {
                        this._right = e, this.markProjectionDirty()
                    }
                    get right() {
                        return this._right
                    }
                    set bottom(e) {
                        this._bottom = e, this.markProjectionDirty()
                    }
                    get bottom() {
                        return this._bottom
                    }
                    set top(e) {
                        this._top = e, this.markProjectionDirty()
                    }
                    get top() {
                        return this._top
                    }
                    set zoom(e) {
                        this._zoom = e, this.markProjectionDirty()
                    }
                    get zoom() {
                        return this._zoom
                    }
                    setViewport(e, t) {
                        super.setViewport(e, t), this.left = -1 * this.aspect / 2, this.right = +this.aspect / 2, this.bottom = -.5, this.top = .5
                    }
                    calculateProjectionMatrix() {
                        var e = (this.right + this.left) / 2,
                            t = (this.bottom + this.top) / 2,
                            s = (this.right - this.left) / (2 * this.zoom),
                            r = (this.top - this.bottom) / (2 * this.zoom);
                        i._.ortho(this._projectionMatrix.source, e - s, e + s, t - r, t + r, this.near, this.far)
                    }
                    clone() {
                        return new a({
                            left: this.left,
                            right: this.right,
                            bottom: this.bottom,
                            top: this.top,
                            near: this.near,
                            far: this.far,
                            zoom: this.zoom
                        })
                    }
                    createRectangle() {
                        return r.A.createFromEdges(this.left, this.right, this.bottom, this.top)
                    }
                }
                a.defaultConfigOrthographic = {
                    left: -1,
                    right: 1,
                    bottom: -1,
                    top: 1,
                    near: .1,
                    far: 1e3,
                    aspect: 1,
                    zoom: 1
                }
            },
            8244: (e, t, s) => {
                s.d(t, {
                    c: () => a
                });
                var t = s(4375),
                    r = s(6407),
                    i = s(7723);
                class a extends t.h {
                    constructor(e = {}) {
                        super(e), this._fovY = e.fovY || a.defaultConfigPerspective.fovY, this._near = e.near || a.defaultConfigPerspective.near, this._far = e.far || a.defaultConfigPerspective.far
                    }
                    setProjection(e) {
                        this._fovY = e.fov || this._fovY, this._near = e.near || this._near, this._far = e.far || this.far, e.viewportWidth && e.viewportHeight ? this.setViewport(e.viewportWidth, e.viewportHeight) : void 0 !== e.aspect && (this.aspect = e.aspect)
                    }
                    set fovY(e) {
                        this._fovY = e, this.markProjectionDirty()
                    }
                    get fovY() {
                        return this._fovY
                    }
                    get fovX() {
                        return this._fovY * this.aspect
                    }
                    calculateProjectionMatrix() {
                        i._.perspective(this._projectionMatrix.source, this._fovY, this._aspect, this._near, this._far)
                    }
                    clone(e = 0, t) {
                        var s = new a({
                            fovY: this._fovY,
                            near: this._near,
                            far: this._far
                        });
                        return s.setViewport(this.viewportWidth, this.viewportHeight), s
                    }
                }
                a.defaultConfigPerspective = {
                    fovY: 60 * r.M.DEG2RAD,
                    near: .1,
                    far: 1e4
                }
            },
            4740: (e, t, s) => {
                var r;
                s.d(t, {
                    p: () => r
                }), (s = r = r || {}).DYNAMIC = "dynamic", s.STATIC = "static", s.BACKGROUND = "background", s.INVISIBLE = "invisible"
            },
            1644: (e, t, s) => {
                s.d(t, {
                    a: () => i
                });
                class i {
                    constructor(e, t) {
                        this.visible = !0;
                        var s = i.defaultConfig,
                            r = t,
                            t = { ...s,
                                ...t,
                                spot: {
                                    innerConeAngle: null != (t = null == (t = r.spot) ? void 0 : t.innerConeAngle) ? t : s.spot.innerConeAngle,
                                    outerConeAngle: null != (r = null == (t = r.spot) ? void 0 : t.outerConeAngle) ? r : s.spot.outerConeAngle
                                }
                            };
                        this._data = t, this._node = e
                    }
                    getIntensityUnit() {
                        return "directional" === this.type ? "lux (lm/m2)" : "candela (lm/sr)"
                    }
                    set type(e) {
                        this._data.type = e
                    }
                    get type() {
                        return this._data.type
                    }
                    set name(e) {
                        this._data.name = e
                    }
                    get name() {
                        return this._data.name || ""
                    }
                    get node() {
                        return this._node
                    }
                    get data() {
                        return this._data
                    }
                }
                i.defaultConfig = {
                    name: "",
                    color: [1, 1, 1],
                    intensity: 1,
                    range: void 0,
                    spot: {
                        innerConeAngle: 0,
                        outerConeAngle: Math.PI / 4
                    }
                }
            },
            2263: (e, t, s) => {
                s.d(t, {
                    j: () => l
                });
                var r = s(387),
                    i = s(4955),
                    a = s(82),
                    n = s(4735),
                    o = s(4155);
                class l {
                    constructor(e) {
                        this.id = ++l.highestId, this._name = "", this._boundingBoxVersion = -1, this._material = e.material, this._geometry = e.geometry, this._node = e.node, this._boundingBox = e.boundingBox, this._skin = e.skin, this._name = e.name || ""
                    }
                    detach() {
                        this._node instanceof i.B && this._node.removeRenderNode(this)
                    }
                    setMaterial(e) {
                        this._material !== e && (this._material = e)
                    }
                    setGeometry(e) {
                        this._geometry !== e && (this._geometry = e, this._boundingBox = void 0)
                    }
                    calculateBoundingBox() {
                        var e = this.geometry.getAttribute(n.p.POSITION);
                        return e ? o.g.calculateMinMax(e, this.geometry) : new r.x(a.R.fromValues(0, 0, 0), a.R.fromValues(0, 0, 0))
                    }
                    clone(e = !1, t = !1) {
                        return new l({
                            geometry: t ? this.geometry.clone() : this.geometry,
                            material: e ? this.material.clone() : this.material,
                            skin: this.skin,
                            boundingBox: this.getBoundingBox(),
                            node: this.node,
                            name: this.name
                        })
                    }
                    set name(e) {
                        this._name = e
                    }
                    get name() {
                        return this._name || this._material.name || `mesh (${this.id})`
                    }
                    get geometry() {
                        return this._geometry
                    }
                    get transparent() {
                        return this.material.transparent
                    }
                    set node(e) {
                        this._node = e
                    }
                    get node() {
                        return this._node
                    }
                    get material() {
                        return this._material
                    }
                    getBoundingBox() {
                        return this._geometry.dataVersion > this._boundingBoxVersion && (this._boundingBox = void 0), this._boundingBox || (this._boundingBox = this.calculateBoundingBox(), this._boundingBoxVersion = this._geometry.dataVersion), this._boundingBox
                    }
                    getBoundingBoxWorld() {
                        var e = this.getBoundingBox();
                        return r.x.transform(e, this.node.calculateWorldMatrix())
                    }
                    get skin() {
                        return this._skin
                    }
                }
                l.highestId = 0
            },
            4955: (e, t, s) => {
                s.d(t, {
                    B: () => d
                });
                var n = s(7723),
                    r = s(4740),
                    i = s(9959),
                    a = s(651),
                    o = s(9816),
                    l = s(82),
                    h = s(387),
                    c = s(2263);
                class d {
                    static create(e, t, s = "") {
                        return new d({
                            name: s,
                            renderNodes: [new c.j({
                                geometry: e,
                                material: t
                            })]
                        })
                    }
                    constructor(e = {}) {
                        if (this.id = ++d.highestId, this._depth = 0, this.ignoreInBoundingBox = !1, this._name = "", this.worldMatrix = n._.create(), this.worldMatrixAutoUpdate = !0, this._visible = !0, this.gltf = {
                                nodeId: -1
                            }, this.invalidateTransform = () => {
                                var e;
                                this.worldMatrixAutoUpdate && null != (e = this.scene) && e.invalidateWorldMatrix(this)
                            }, this._name = e.name || "", this._transform = e.transform || new i.j, this._children = [], this._type = e.type || r.p.DYNAMIC, this._renderNodes = [], this._transform.onChange = this.invalidateTransform, e.renderNodes)
                            for (const t of e.renderNodes) this.addRenderNode(t)
                    }
                    add(e) {
                        e.setParent(this)
                    }
                    removeAll() {
                        for (const e of this._children) e.detach()
                    }
                    detach() {
                        this.setParent(void 0)
                    }
                    setParent(e) {
                        if (e !== this._parent) {
                            if (this._parent) {
                                const e = this._parent._children.indexOf(this); - 1 < e && this._parent._children.splice(e, 1)
                            }
                            this._parent = e, this._parent && this._parent._children.push(this), this.updateAfterMove(), null != (e = this.scene) && e.signals.tree.dispatch()
                        }
                    }
                    updateAfterMove() {
                        var e;
                        this._depth = this._parent ? this._parent.depth + 1 : 0, this._scene = this._parent ? this._parent.scene : void 0, null != (e = this._scene) && e.invalidateWorldMatrix(this);
                        for (const e of this._children) e.updateAfterMove()
                    }
                    get scene() {
                        return this._scene
                    }
                    isRealSceneNode() {
                        return !(this instanceof a.x)
                    }
                    get depth() {
                        return this._depth
                    }
                    getParent() {
                        return this._parent
                    }
                    calculateWorldMatrix() {
                        var e = n._.clone(this._transform.mat),
                            t = this.getParent();
                        return t && 0 < t.depth && n._.mul(e, t.calculateWorldMatrix(), e), e
                    }
                    getNegativeScaleCount() {
                        var e = this.transform.getNegativeScaleCount();
                        return this._parent ? e + this._parent.getNegativeScaleCount() : e
                    }
                    isMirrored() {
                        return this.getNegativeScaleCount() % 2 == 1
                    }
                    lookAt(e, t, s = [0, 1, 0]) {
                        var r, i, a;
                        this._parent ? (a = this._parent.calculateWorldMatrix(), (a = n._.invert(n._.create(), a)) && (t = t || n._.getTranslation(l.R.create(), this.calculateWorldMatrix()), r = l.R.transformMat4(l.R.create(), e, a), i = l.R.transformMat4(l.R.create(), t, a), s = o.v.fromVec3(s, 0), a = o.v.transformMat4(o.v.create(), s, a), this.lookAtLocal(r, i, a))) : this.lookAtLocal(e, t, s)
                    }
                    lookAtLocal(e, t, s = [0, 1, 0]) {
                        t = t || l.R.clone(this.transform.translation.vec);
                        t = n._.lookAt(n._.create(), t, e, s), s = n._.invert(n._.create(), t);
                        if (s) {
                            const e = l.R.clone(this.transform.scale.vec);
                            this.transform.setFromMatrix(s), this.transform.scale.copyFrom(e)
                        }
                    }
                    get transform() {
                        return this._transform
                    }
                    get children() {
                        return this._children
                    }
                    get renderNodes() {
                        return this._renderNodes
                    }
                    addRenderNode(e) {
                        (e.node = this)._renderNodes.push(e)
                    }
                    removeRenderNode(e) {
                        e = this._renderNodes.indexOf(e); - 1 < e && this._renderNodes.splice(e, 1)
                    }
                    clone(t = !1, s = !1) {
                        var e = this.children.map(e => e.clone(t, s)),
                            r = this.renderNodes.map(e => e.clone(t, s)),
                            i = new d({
                                name: this.name,
                                type: this.type,
                                transform: this.transform.clone(),
                                renderNodes: r
                            });
                        for (const t of e) i.add(t);
                        return i
                    }
                    getAABBWorld(e = !0) {
                        e = this.getAABBLocal(e);
                        return e ? h.x.transform(e, this.calculateWorldMatrix()) : null
                    }
                    getAABBLocal(e = !0) {
                        var t, s;
                        let r = null == (t = this._renderNodes[0]) ? void 0 : t.getBoundingBox();
                        if (!this.ignoreInBoundingBox)
                            for (let e = 1; e < this._renderNodes.length; ++e) {
                                const t = this._renderNodes[e].getBoundingBox();
                                r = r ? h.x.union(r, r, t) : t
                            }
                        if (e)
                            for (const e of this._children)
                                if (!e.ignoreInBoundingBox) {
                                    const t = e.getAABBLocal();
                                    t && (s = h.x.transform(t, e.transform.mat), r = r ? h.x.union(r, r, s) : s)
                                }
                        return r || null
                    }
                    getAABBParent() {
                        var e = this.getAABBLocal();
                        return e ? h.x.transform(e, this.transform.mat) : null
                    }
                    set visible(e) {
                        this._visible = e
                    }
                    get visible() {
                        return this._visible
                    }
                    set morphWeights(e) {
                        this._morphWeights = e
                    }
                    get morphWeights() {
                        return this._morphWeights
                    }
                    set name(e) {
                        this._name !== e && (this._name = e || "", e = this.scene) && e.signals.change.dispatch()
                    }
                    get name() {
                        return this._name
                    }
                    set light(e) {
                        this._light = e
                    }
                    get light() {
                        return this._light
                    }
                    get type() {
                        return this._type
                    }
                }
                d.highestId = 0
            },
            7734: (e, t, s) => {
                s.d(t, {
                    x: () => o
                });
                var a = s(7723),
                    r = s(82),
                    i = s(9816),
                    n = s(3790);
                class o {
                    static matrix_world2local(e, t, s = a._.create()) {
                        var r = t.getParent();
                        if (r) {
                            const t = r.calculateWorldMatrix(),
                                i = a._.invert(a._.create(), t);
                            i ? a._.mul(s, i, e) : a._.copy(s, e)
                        } else a._.copy(s, e);
                        return s
                    }
                    static getTranslation(e, t = r.R.create()) {
                        return a._.getTranslation(t, e)
                    }
                    static getNormalMatrix(e) {
                        return e.hasUniformScale() ? e.mat : this.getNormalMat(e.mat)
                    }
                    static getNormalMat(e, t = a._.create()) {
                        var s = n.w.fromMat4(n.w.create(), e),
                            s = n.w.invert(n.w.create(), s);
                        if (s) {
                            const e = n.w.transpose(s, s);
                            return a._.clone([e[0], e[1], e[2], 0, e[3], e[4], e[5], 0, e[6], e[7], e[8], 0, 0, 0, 0, 1])
                        }
                        return a._.copy(t, e)
                    }
                    static calculateViewZ(e, t) {
                        e = e.calculateWorldMatrix(), e = a._.getTranslation([0, 0, 0, 1], e), t = t.getViewProjectionMatrix(), e = i.v.transformMat4([], e, t);
                        return e[2] / e[3]
                    }
                }
            },
            6780: (e, t, s) => {
                s.d(t, {
                    c: () => l,
                    x: () => o
                });
                var r = s(9720),
                    i = s(2841),
                    a = s(8227),
                    n = s(7068);
                class o {
                    static from(e) {
                        var t = new l,
                            s = (e.onLoad && t.signals.load.addOnce(e.onLoad), "string" == typeof e.source ? t.setUrlSource(e.source) : (0, n.JZ)(e.source) ? t.setMediaSource(e.source) : t.setDataSource(e.source || null, e.width || 0, e.height || 0), t.name = null != (s = e.name) ? s : t.name, new a.a),
                            r = (s.wrapS = null != (r = e.wrapS) ? r : s.wrapS, s.wrapT = null != (r = e.wrapT) ? r : s.wrapT, s.minFilter = null != (r = e.minFilter) ? r : s.minFilter, s.magFilter = null != (r = e.magFilter) ? r : s.magFilter, new o(t, s));
                        return r._flipY = null != (t = e.flipY) && t, r
                    }
                    constructor(e, t) {
                        this.id = ++o.highestId, this._flipY = !1, this._image = e, this._sampler = t || new a.a
                    }
                    clone(e) {
                        return new o(new l(e), this._sampler.clone())
                    }
                    get image() {
                        return this._image
                    }
                    get sampler() {
                        return this._sampler
                    }
                    get flipY() {
                        return this._flipY
                    }
                }
                o.highestId = 0;
                class l {
                    constructor(e) {
                        this._name = "", this.signals = {
                            load: r.M.create()
                        }, this._loaded = !1, this._width = 0, this._height = 0, this.onImageLoaded = e => {
                            null != (e = e.currentTarget) && e.removeEventListener("load", this.onImageLoaded), this.onSourceLoaded(), this.updateSize(), this.signals.load.dispatch(this)
                        }, e && this.setMediaSource(e)
                    }
                    setDataSource(e, t, s) {
                        this.clearCurrentLoading(), this._source = e, this._width = t, this._height = s, this.onSourceLoaded(), this.signals.load.dispatch(this)
                    }
                    setUrlSource(e) {
                        this.clearCurrentLoading(), this.name = e;
                        var t = new Image;
                        (this._source = t).addEventListener("load", this.onImageLoaded), t.src = e
                    }
                    setMediaSource(e) {
                        this.clearCurrentLoading(), this._source = e, this.updateSize(), e instanceof HTMLImageElement && !e.complete ? (this.name = e.src, e.addEventListener("load", this.onImageLoaded)) : (this.onSourceLoaded(), this.signals.load.dispatch(this))
                    }
                    clearCurrentLoading() {
                        this._source instanceof HTMLImageElement && this._source.removeEventListener("load", this.onImageLoaded)
                    }
                    updateSize() {
                        var e = this._source;
                        [this._width, this._height] = n.O.getSourceSize(e)
                    }
                    onSourceLoaded() {
                        var e, t, s;
                        this._loaded = !0, (this._source || null === this._source) && (0, n.JZ)(this._source) && (e = 16384, [t, s] = n.O.getSourceSize(this._source), e < t || e < s) && (this._source instanceof HTMLImageElement ? (this._width = Math.min(this._source.width, e), this._height = Math.min(this._source.height, e), this._source = i.P.resizeImage(this._source, this._width, this._height)) : console.warn("Unimplemented! Texture will not load."))
                    }
                    set name(e) {
                        this._name = e || ""
                    }
                    get name() {
                        return this._name
                    }
                    get source() {
                        return this._source
                    }
                    get width() {
                        return this._width
                    }
                    get height() {
                        return this._height
                    }
                    isLoaded() {
                        return this._loaded
                    }
                }
            },
            8227: (e, t, s) => {
                s.d(t, {
                    a: () => i
                });
                var r = s(1201);
                class i {
                    constructor(e = {}) {
                        var t;
                        this.needUpdate = !1, this._wrapS = r.g.CLAMP_TO_EDGE, this._wrapT = r.g.CLAMP_TO_EDGE, this._minFilter = r.g.LINEAR_MIPMAP_LINEAR, this._magFilter = r.g.LINEAR, this.maxAnisotropy = 1, this._wrapS = null != (t = e.wrapS) ? t : this._wrapS, this._wrapT = null != (t = e.wrapT) ? t : this._wrapT, this._minFilter = null != (t = e.minFilter) ? t : this._minFilter, this._magFilter = null != (t = e.magFilter) ? t : this._magFilter
                    }
                    clone() {
                        return new i({
                            wrapS: this.wrapS,
                            wrapT: this.wrapT,
                            minFilter: this.minFilter,
                            magFilter: this.magFilter
                        })
                    }
                    get wrapS() {
                        return this._wrapS
                    }
                    set wrapS(e) {
                        this._wrapS !== e && (this._wrapS = e, this.needUpdate = !0)
                    }
                    get wrapT() {
                        return this._wrapT
                    }
                    set wrapT(e) {
                        this._wrapT !== e && (this._wrapT = e, this.needUpdate = !0)
                    }
                    get minFilter() {
                        return this._minFilter
                    }
                    set minFilter(e) {
                        this._minFilter !== e && (this._minFilter = e, this.needUpdate = !0)
                    }
                    get magFilter() {
                        return this._magFilter
                    }
                    set magFilter(e) {
                        this._magFilter !== e && (this._magFilter = e, this.needUpdate = !0)
                    }
                }
            },
            7068: (e, t, s) => {
                s.d(t, {
                    JZ: () => function(e) {
                        return !(null == e || !e.nodeName)
                    },
                    O: () => o
                });
                var i = s(999),
                    a = s(5433),
                    n = s(1201);
                const r = {
                    mimeType: "image/png",
                    extension: "png",
                    quality: void 0
                };
                class o {
                    static async loadImageBitmap(e, t = {
                        colorSpaceConversion: "none"
                    }) {
                        e = await (await fetch(e)).blob();
                        return createImageBitmap(e, t)
                    }
                    static getSourceSize(e) {
                        return h(e) ? [e.displayWidth, e.displayHeight] : [e.width, e.height]
                    }
                    static getPreviewUrl(e, t) {
                        const s = e.texture.image.source;
                        s instanceof HTMLCanvasElement ? s.toBlob(e => {
                            e && t(URL.createObjectURL(e), !0)
                        }, "image/png") : s instanceof HTMLImageElement || s instanceof HTMLVideoElement ? setTimeout(() => {
                            t(s.src, !1)
                        }, 0) : o.readIntoBlob(e, r).then(e => {
                            t(URL.createObjectURL(e), !0)
                        })
                    }
                    static async readIntoArraybuffer(r, i) {
                        return ArrayBuffer.isView(r.image.source) ? r.image.source.buffer : new Promise(async (e, t) => {
                            var s = await o.readIntoBlob({
                                texture: r
                            }, i);
                            e(await a.P.readAsArraybuffer(s))
                        })
                    }
                    static async readIntoBlob(s, {
                        mimeType: r,
                        quality: i
                    }) {
                        return new Promise((t, e) => {
                            o.readIntoCanvas(s).toBlob(e => {
                                e ? t(e) : console.warn("Failed to read into blob")
                            }, r, i)
                        })
                    }
                    static getCanvas(e, t) {
                        var s = e.texture.image.source;
                        if (s instanceof HTMLCanvasElement) return s;
                        if (l(s)) {
                            t = t || document.createElement("canvas");
                            const [e, r] = o.getSourceSize(s);
                            return t.width = e, t.height = r, t.getContext("2d").drawImage(s, 0, 0), t
                        }
                    }
                    static readIntoCanvas(e, t) {
                        var s = e.texture.image.source;
                        return ((t = t || document.createElement("canvas")).width = e.texture.image.width, t.height = e.texture.image.height, l(s)) ? t.getContext("2d").drawImage(s, 0, 0) : s instanceof ImageData ? t.getContext("2d").putImageData(s, 0, 0) : ArrayBuffer.isView(s) ? s instanceof Uint8ClampedArray ? (s = new ImageData(new Uint8ClampedArray(s.buffer), e.texture.image.width, e.texture.image.height), t.getContext("2d").putImageData(s, 0, 0)) : console.warn("Unhandled ArrayBuffer type when reading texture?") : console.log("Unhandled case when reading texture?"), t
                    }
                    static readPixels(e) {
                        return new Uint8Array(e.texture.image.width * e.texture.image.height * 4)
                    }
                    static readPixelsWebGL(e) {
                        var {
                            texture: e,
                            format: t,
                            type: s,
                            rect: r,
                            data: i
                        } = e, a = e.context.gl;
                        return e.initFramebuffer().bind(), t = t || a.RGBA, s = s || a.UNSIGNED_BYTE, r = r || [0, 0, e.width, e.height], i = i || o.createArray(s, t, r[2], r[3]), a.readPixels(r[0], r[1], r[2], r[3], t, s, i), e.initFramebuffer().unbind(), i
                    }
                    static createImageDataWebGL(e, t = !1) {
                        var s = e.width,
                            r = e.height,
                            e = o.readPixelsWebGL({
                                texture: e
                            }),
                            t = (t && i.P.inst.flipDataArray(e, s, r), i.P.inst.ctx.createImageData(s, r));
                        return t.data.set(e), t
                    }
                    static createArray(e, t, s, r) {
                        let i;
                        switch (e) {
                            case n.g.UNSIGNED_BYTE:
                                i = Uint8Array;
                                break;
                            case n.g.FLOAT:
                                i = Float32Array;
                                break;
                            case n.g.UNSIGNED_SHORT_5_6_5:
                            case n.g.UNSIGNED_SHORT_4_4_4_4:
                            case n.g.UNSIGNED_SHORT_5_5_5_1:
                                i = Uint16Array;
                                break;
                            default:
                                i = Uint8Array, console.warn("Wrong type for Texture.readPixels / createArray: " + e)
                        }
                        let a = 4;
                        switch (t) {
                            case n.g.RGBA:
                                a = 4;
                                break;
                            case n.g.RGB:
                                a = 3;
                                break;
                            case n.g.ALPHA:
                                a = 1;
                                break;
                            default:
                                console.warn("Wrong format for Texture.readPixels / createArray: " + t)
                        }
                        return new i(s * r * a)
                    }
                    static debugTexture(e) {
                        e = o.readIntoCanvas({
                            texture: e,
                            flip: !0
                        }, document.createElement("canvas"));
                        e.style.opacity = "0.6", e.style.pointerEvents = "none", e.style.position = "absolute", e.style.left = "0", e.style.right = "0", e.style.width = "100%", e.style.height = "100%", document.body.appendChild(e)
                    }
                    static downloadTexture(e) {
                        o.readIntoCanvas({
                            texture: e,
                            flip: !0
                        }, document.createElement("canvas")).toBlob(e => {
                            a.P.downloadFile(e)
                        })
                    }
                }

                function l(e) {
                    return e instanceof HTMLImageElement || e instanceof SVGImageElement || e instanceof HTMLVideoElement || e instanceof HTMLCanvasElement || e instanceof ImageBitmap || e instanceof OffscreenCanvas || h(e)
                }

                function h(e) {
                    return "undefined" != typeof VideoFrame && e instanceof VideoFrame
                }
            },
            999: (e, t, s) => {
                s.d(t, {
                    P: () => p
                });
                var a = s(3629),
                    u = s(9816);
                class p {
                    static get inst() {
                        return p._inst || (p._inst = new p)
                    }
                    get canvas() {
                        return this._canvas || (this._canvas = document.createElement("canvas")), this._canvas
                    }
                    get ctx() {
                        var e;
                        return this._ctx || (e = this.canvas, this._ctx = e.getContext("2d")), this._ctx
                    }
                    setSize(e) {
                        var t = this.canvas;
                        t.width = e[0], t.height = e[1]
                    }
                    flipDataArray(s, r, i) {
                        var a = [0, 0, 0, 0],
                            e = Math.floor(i / 2);
                        for (let t = 0; t < e; ++t)
                            for (let e = 0; e < r; ++e) {
                                var n = 4 * (t * r + e),
                                    o = (a[0] = s[0 + n], a[1] = s[1 + n], a[2] = s[2 + n], a[3] = s[3 + n], 4 * ((i - 1 - t) * r + e));
                                s[0 + n] = s[0 + o], s[1 + n] = s[1 + o], s[2 + n] = s[2 + o], s[3 + n] = s[3 + o], s[0 + o] = a[0], s[1 + o] = a[1], s[2 + o] = a[2], s[3 + o] = a[3]
                            }
                    }
                    createCircle(e, t, s = 1) {
                        const r = p.createCanvas(2 * e, 2 * e),
                            i = r.getContext("2d");
                        if (i) {
                            i.beginPath(), i.arc(e, e, e, 0, 2 * Math.PI, !1);
                            const r = a.I.decompose(t);
                            i.fillStyle = `rgba(${r[0]},${r[1]},${r[2]},${s})`, i.fill()
                        } else console.warn("CanvasUtils.createCircle: no context found!");
                        return r
                    }
                    static createCanvas(e, t) {
                        var s = document.createElement("canvas");
                        return s.width = e, s.height = t, s
                    }
                    static createCanvasFromData(e, t, s) {
                        var s = this.createCanvas(t, s),
                            r = s.getContext("2d");
                        if (r) {
                            const t = new ImageData(e, s.width, s.height);
                            r.putImageData(t, 0, 0)
                        } else console.warn("CanvasUtils.createCanvasFromData: no context found!");
                        return s
                    }
                    static mapPixels(e, s) {
                        var t = e.getContext("2d");
                        if (t) {
                            var r = t.getImageData(0, 0, e.width, e.height).data,
                                i = e.width,
                                a = e.height,
                                t = e.width * e.height,
                                n = new Uint8ClampedArray(4 * t),
                                o = u.v.create();
                            for (let t = 0; t < a; ++t)
                                for (let e = 0; e < i; ++e) {
                                    const p = 4 * (t * i + e),
                                        l = r[p],
                                        h = r[1 + p],
                                        c = r[2 + p],
                                        d = r[3 + p];
                                    u.v.set(o, l, h, c, d), s(o, e, t), n[0 + p] = o[0], n[1 + p] = o[1], n[2 + p] = o[2], n[3 + p] = o[3]
                                }
                            return p.createCanvasFromData(n, e.width, e.height)
                        }
                    }
                }
            },
            3629: (e, t, s) => {
                s.d(t, {
                    I: () => h
                });
                var r = s(4207);
                class h {
                    static css2hex(e) {
                        e = e.substr(1);
                        return parseInt(e, 16)
                    }
                    static getCSSFromNumber(e) {
                        return h.getHexStringFromNumber(e, !0)
                    }
                    static string2number(e) {
                        return parseInt(e, 16)
                    }
                    static getHexStringFromNumber(e, t = !1) {
                        let s = e.toString(16);
                        return s = r.M.leftPad(s, 6), s = t ? "#" + s : s
                    }
                    static getHueTopFromColor(e) {
                        e = h.getHueFromColor(e);
                        return h.hsb2rgb(e, 1, 1)
                    }
                    static getHueFromColor(e) {
                        return new h(e, 1).h
                    }
                    static vec3_to_hex(e) {
                        var t = Math.round(255 * e[0]),
                            s = Math.round(255 * e[1]),
                            e = Math.round(255 * e[2]);
                        return this.rgb2hex(t, s, e)
                    }
                    static vec4_to_hex(e) {
                        var t = Math.round(255 * e[0]),
                            s = Math.round(255 * e[1]),
                            r = Math.round(255 * e[2]),
                            e = Math.round(255 * e[3]);
                        return this.rgba2hex(t, s, r, e)
                    }
                    static rgb2hsb(e) {
                        var t, s, r, i, e = h.decompose(e),
                            a = e.sort((e, t) => e - t),
                            n = e[0],
                            o = e[1],
                            e = e[2],
                            l = a[0],
                            a = a[2];
                        return 0 == (t = 0 !== a ? (a - l) / a : 0) ? i = 0 : (s = (a - n) / (a - l), r = (a - o) / (a - l), e = (a - e) / (a - l), i = n === a ? e - r : o === a ? 2 + s - e : 4 + r - s, (i /= 6) < 0 && (i += 1)), [i, t, a / 255]
                    }
                    static hsb2rgb(e, t, s) {
                        var r = 0,
                            i = 0,
                            a = 0;
                        if (0 === t) r = i = a = Math.round(255 * s);
                        else {
                            var e = 6 * (e - Math.floor(e)),
                                n = e - Math.floor(e),
                                o = s * (1 - t),
                                l = s * (1 - t * n),
                                h = s * (1 - t * (1 - n));
                            switch (Math.floor(e)) {
                                case 0:
                                    r = Math.round(255 * s), i = Math.round(255 * h), a = Math.round(255 * o);
                                    break;
                                case 1:
                                    r = Math.round(255 * l), i = Math.round(255 * s), a = Math.round(255 * o);
                                    break;
                                case 2:
                                    r = Math.round(255 * o), i = Math.round(255 * s), a = Math.round(255 * h);
                                    break;
                                case 3:
                                    r = Math.round(255 * o), i = Math.round(255 * l), a = Math.round(255 * s);
                                    break;
                                case 4:
                                    r = Math.round(255 * h), i = Math.round(255 * o), a = Math.round(255 * s);
                                    break;
                                case 5:
                                    r = Math.round(255 * s), i = Math.round(255 * o), a = Math.round(255 * l)
                            }
                        }
                        return 0 | r << 16 | i << 8 | a << 0
                    }
                    static rgb2hex(e, t, s) {
                        return e << 16 | t << 8 | s
                    }
                    static rgba2hex(e, t, s, r) {
                        return e * 2 ** 24 + (t << 16) + (s << 8) + r
                    }
                    static decompose(e) {
                        return [e >> 16, e >> 8 & 255, 255 & e]
                    }
                    static hexRGBA2array(e) {
                        return [e >> 24, e >> 16, e >> 8 & 255, 255 & e]
                    }
                    static hexRGBA2arrayNormalized(e) {
                        return [e >> 24 / 255, e >> 16 / 255, e >> 8 & 1, 1 & e]
                    }
                    static decomposeAndNormalizeRGB(e) {
                        return [(e >> 16) / 255, (e >> 8 & 255) / 255, (255 & e) / 255]
                    }
                    static decomposeAndNormalizeRGBA(e, t = 1) {
                        return this.decomposeAndNormalizeRGB(e).concat(t)
                    }
                    static decomposeAndNormalizeToObjRGB(e) {
                        return {
                            r: (e >> 16) / 255,
                            g: (e >> 8 & 255) / 255,
                            b: (255 & e) / 255
                        }
                    }
                    static decomposeAndNormalizeToObjRGBA(e, t = 1) {
                        return {
                            r: (e >> 16) / 255,
                            g: (e >> 8 & 255) / 255,
                            b: (255 & e) / 255,
                            a: t
                        }
                    }
                    static appendAlpha(e, t) {
                        return (e << 8 | Math.round(255 * t)) >>> 0
                    }
                    static removeAlpha(e) {
                        return e >> 8
                    }
                    static changeRGB(e, t) {
                        e = this.getAlpha(e);
                        return this.appendAlpha(t, e)
                    }
                    static getAlpha(e) {
                        return (255 & e) / 255
                    }
                    static hueToRGB(e, t, s) {
                        return s < 0 && (s += 1), 1 < s && --s, s < 1 / 6 ? e + 6 * (t - e) * s : s < .5 ? t : s < 2 / 3 ? e + (t - e) * (2 / 3 - s) * 6 : e
                    }
                    static interpolate(e, t, s) {
                        var r = e >> 16,
                            i = e >> 8 & 255,
                            e = 255 & e;
                        return r + ((t >> 16) - r) * s << 16 | i + ((t >> 8 & 255) - i) * s << 8 | e + ((255 & t) - e) * s
                    }
                    constructor(e = 0, t = 1, s = "") {
                        this.name = "", this.r = 0, this.g = 0, this.b = 0, this.a = 0, this.h = 0, this.s = 0, this.l = 0, this.hex = e, this.a = t, this.name = s
                    }
                    copyFrom(e) {
                        this.hex = e.hex, this.a = e.a, this.name = e.name
                    }
                    setHSL(e = 0, t = 0, s = 0) {
                        this.h = e, this.s = t, this.l = s;
                        var r = 0,
                            i = 0,
                            a = 0;
                        0 == this.s ? r = i = a = s : (t = 2 * s - (s = s < .5 ? s * (1 + t) : s + t - s * t), r = h.hueToRGB(t, s, e + 1 / 3), i = h.hueToRGB(t, s, e), a = h.hueToRGB(t, s, e - 1 / 3)), this.r = r, this.g = i, this.b = a
                    }
                    setRGB(e, t, s) {
                        this.r = e, this.g = t, this.b = s;
                        var r = Math.max(e, t, s),
                            i = Math.min(e, t, s),
                            a = 0,
                            n = 0,
                            o = (r + i) / 2;
                        if (r != i) {
                            var l = r - i,
                                n = .5 < o ? l / (2 - r - i) : l / (r + i);
                            switch (r) {
                                case e:
                                    a = (t - s) / l + (t < s ? 6 : 0);
                                    break;
                                case t:
                                    a = (s - e) / l + 2;
                                    break;
                                case s:
                                    a = (e - t) / l + 4
                            }
                            a /= 6
                        }
                        this.h = a, this.s = n, this.l = o
                    }
                    get hex() {
                        return Math.round(255 * this.r) << 16 | Math.round(255 * this.g) << 8 | Math.round(255 * this.b)
                    }
                    set hex(e) {
                        this.setRGB((e >> 16) / 255, (e >> 8 & 255) / 255, (255 & e) / 255)
                    }
                }
            },
            7934: (e, t, s) => {
                s.d(t, {
                    g: () => n
                });
                class n {
                    static clone(e, t = !1) {
                        if ("object" != typeof e || null === e) return e;
                        if (Array.isArray(e)) {
                            var s = [];
                            for (const i of e) s.push(t ? n.clone(i, t) : i);
                            return s
                        }
                        var r = {};
                        for (const a in e) r[a] = t ? n.clone(e[a], !0) : e[a];
                        return r
                    }
                    static cloneViaJson(e) {
                        return JSON.parse(JSON.stringify(e))
                    }
                    static apply(e, t) {
                        for (const s in t) e[s] = t[s]
                    }
                    static mergeConfig(e = {}, t = {}, s) {
                        var r = Object.create(e || {});
                        for (const e in t) r[e] = t[e];
                        return r
                    }
                    static parseById(s, r = -1) {
                        for (const e in s) {
                            var i = s[e];
                            if (Array.isArray(i) && "_a" === e.substr(-2)) {
                                const s = {};
                                for (let e = 0, t = i.length; e < t; e++) {
                                    var a = i[e];
                                    "object" == typeof a && a.id && (s[a.id] = a, --r) && n.parseById(a, r)
                                }
                                Object.keys(s).length && (i[e + "_o"] = s)
                            }
                        }
                    }
                    static compare(s, r) {
                        if (s !== r) {
                            var e = typeof s;
                            if (e != typeof r) return !1;
                            if ("object" != e) return !1;
                            const i = Object.keys(s),
                                a = Object.keys(r);
                            if (i.length !== a.length) return !1;
                            i.sort(), a.sort();
                            for (let e = 0, t = i.length; e < t; ++e)
                                if (i[e] !== a[e]) return !1;
                            for (let e = 0, t = i.length; e < t; ++e) {
                                const a = i[e];
                                if (!n.compare(s[a], r[a])) return !1
                            }
                        }
                        return !0
                    }
                }
            },
            6017: (e, t, s) => {
                s.d(t, {
                    B: () => r
                });
                class r {
                    static keys2array(e) {
                        return Object.keys(e)
                    }
                    static values2array(e) {
                        var t = [];
                        for (const s in e) t.push(e[s]);
                        return t
                    }
                    static equals(t, s) {
                        if (t !== s) {
                            if (t.length !== s.length) return !1;
                            for (let e = 0; e < t.length; ++e)
                                if (t[e] !== s[e]) return !1
                        }
                        return !0
                    }
                    static isEmpty(t, s = 0) {
                        for (let e = 0; e < t.length; ++e)
                            if (Math.abs(t[e]) > s) return !1;
                        return !0
                    }
                    static copy(t, s) {
                        for (let e = 0; e < s.length; ++e) t[e] = s[e]
                    }
                    static forEach(e = [], t) {
                        var s = e.slice(0);
                        for (let e = 0; e < s.length; ++e) t(s[e], e)
                    }
                    static forEachPair(s, r) {
                        for (let t = 0; t < s.length; t++)
                            for (let e = t + 1; e < s.length; e++)
                                if (r(s[t], s[e])) return !0;
                        return !1
                    }
                    static filter(t, s) {
                        var r = [];
                        for (let e = 0; e < t.length; ++e) {
                            var i = t[e];
                            s(i, e) && r.push(i)
                        }
                        return r
                    }
                    static push(e, t) {
                        return Array.prototype.push.apply(e, t), e
                    }
                    static addMutable(e, t) {
                        return e.includes(t) || e.push(t), e
                    }
                    static removeMutable(e, t) {
                        t = e.indexOf(t);
                        return -1 !== t && e.splice(t, 1), e
                    }
                    static replaceMutable(e, t, ...s) {
                        t = e.indexOf(t); - 1 !== t && e.splice(t, 1, ...s)
                    }
                    static loopMap(t, s, r) {
                        var i = [];
                        for (let e = t; e < s; ++e) i.push(r(e));
                        return i
                    }
                    static at(e, t) {
                        t %= e.length;
                        return e[t < 0 ? t + e.length : t]
                    }
                }
            },
            5081: (e, t, s) => {
                s.d(t, {
                    W: () => i
                });
                var r = s(4755);
                class i {
                    static string2arraybuffer(t) {
                        if (void 0 !== window.TextEncoder) return (new TextEncoder).encode(t).buffer;
                        var s = new Uint8Array(new ArrayBuffer(t.length));
                        for (let e = 0; e < t.length; ++e) {
                            var r = t.charCodeAt(e);
                            s[e] = 255 < r ? 32 : r
                        }
                        return s.buffer
                    }
                    static arraybuffer2string(s) {
                        if (void 0 !== window.TextDecoder) return this.decoder = this.decoder || new TextDecoder, this.decoder.decode(s); {
                            if (s instanceof ArrayBuffer) throw new Error("Can't polyfill this buffer (not implemented): " + s);
                            if (s instanceof DataView) throw new Error("Can't polyfill this buffer (not implemented): " + s);
                            let t = "";
                            for (let e = 0; e < s.length; ++e) t += String.fromCharCode(s[e]);
                            return decodeURIComponent(escape(t))
                        }
                    }
                    static arraybuffer2base64(e) {
                        let t = "";
                        var s = new Uint8Array(e),
                            r = s.byteLength;
                        for (let e = 0; e < r; ++e) t += String.fromCharCode(s[e]);
                        return window.btoa(t)
                    }
                    static arraybuffer2base64uri(e) {
                        return this.prefixBase64(this.arraybuffer2base64(e))
                    }
                    static prefixBase64(e) {
                        return "data:application/octet-stream;base64," + e
                    }
                    static concat(e) {
                        let t = 0;
                        for (const s of e) t += s.byteLength;
                        const s = new ArrayBuffer(t),
                            r = new Uint8Array(s);
                        let i = 0;
                        for (const t of e) {
                            const e = new Uint8Array(t);
                            r.set(e, i), i += t.byteLength
                        }
                        return s
                    }
                    static getPaddedArrayBuffer(t, s = 0) {
                        s = s || 0;
                        var r = this.getPaddedBufferSize(t.byteLength);
                        if (r === t.byteLength) return t;
                        var i = new Uint8Array(r);
                        if (i.set(new Uint8Array(t)), 0 !== s)
                            for (let e = t.byteLength; e < r; ++e) i[e] = s;
                        return i.buffer
                    }
                    static getPaddedBufferSize(e) {
                        return 4 * Math.ceil(e / 4)
                    }
                    static newTypedArray(e, t) {
                        return new(r.h.getClass(e))(t)
                    }
                }
            },
            4707: (e, t, s) => {
                s.d(t, {
                    U: () => i
                });
                class r {
                    static buildQueryString(s, e = "#") {
                        let r = e;
                        for (let t = 0; t < s.length; t += 2) {
                            0 < t && (r += "&");
                            var i = s[t];
                            let e = s[t + 1];
                            "number" == typeof e && (e = e.toString()), r += encodeURIComponent(i) + "=" + encodeURIComponent(e)
                        }
                        return r
                    }
                    static htmlEncode(t, s = "#") {
                        let r = s,
                            i = !0;
                        for (const s in t) {
                            i ? i = !1 : r += "&";
                            let e = t[s];
                            "number" == typeof e && (e = e.toString()), r += encodeURIComponent(s) + "=" + encodeURIComponent(e)
                        }
                        return r
                    }
                    static htmlDecode(e, r = !0) {
                        if (!e) return null;
                        if (!r || (e = e.substr(1))) {
                            var i = e.split("&"),
                                a = {};
                            for (let s = 0, e = i.length; s < e; ++s) {
                                const r = i[s].split("=");
                                let e = r[0],
                                    t = r[1];
                                e = e.split("+").join("%20"), t = t ? t.split("+").join("%20") : "", e = decodeURIComponent(e), t = decodeURIComponent(t), a[e] = t
                            }
                            return a
                        }
                    }
                }
                class i {
                    static inBrowser() {
                        return !i.onNode()
                    }
                    static onNode() {
                        return "undefined" == typeof window
                    }
                    static getURLPathWithoutQuery() {
                        return location.protocol + "//" + location.host + location.pathname
                    }
                    static isDesktop() {
                        return void 0 === i._isDesktop && (i._isDesktop = !navigator.userAgent.match(/(iPhone|iPod|iPad|Android|BlackBerry|IEMobile)/)), i._isDesktop
                    }
                    static isIE() {
                        return !!navigator.userAgent.match(/Trident/)
                    }
                    static isEdge() {
                        return /Edge\/\d./i.test(navigator.userAgent)
                    }
                    static isMS() {
                        return this.isIE() || this.isEdge()
                    }
                    static isSafari() {
                        return /^((?!chrome|android).)*safari/i.test(navigator.userAgent)
                    }
                    static isMacLike() {
                        return /(Mac|iPhone|iPod|iPad)/i.test(navigator.platform)
                    }
                    static isIOS() {
                        return /iPad|iPhone|iPod/.test(navigator.userAgent)
                    }
                    static getQueryParams() {
                        return i.inBrowser() && r.htmlDecode(window.location.search) || {}
                    }
                    static getScrollX() {
                        return window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft || 0
                    }
                    static getScrollY() {
                        return window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0
                    }
                    static clearSelection() {
                        var e;
                        window.getSelection ? null != (e = window.getSelection()) && e.empty ? e.empty() : null != e && e.removeAllRanges && e.removeAllRanges() : document.selection && document.selection.empty()
                    }
                    static copyToClipboard(e) {
                        var t = document.createElement("textarea");
                        t.value = e, document.body.appendChild(t), t.select();
                        try {
                            const e = document.execCommand("copy") ? "successful" : "unsuccessful";
                            console.log("Copying text command was " + e)
                        } catch (e) {
                            console.log("Error: unable to copy")
                        }
                        document.body.removeChild(t)
                    }
                    static detectWebGL(e) {
                        if (window.WebGLRenderingContext) {
                            e = e || document.createElement("canvas");
                            var t;
                            for (const s of ["webgl", "experimental-webgl", "moz-webgl", "webkit-3d"]) try {
                                if ((t = e.getContext(s)) && "function" == typeof t.getParameter) return {
                                    name: s,
                                    gl: t
                                }
                            } catch (e) {}
                        }
                        return null
                    }
                    static getSystemInfo() {
                        var e = {},
                            t = (i.addProperties(e, window.navigator, "", ["appCodeName", "appName", "appVersion", "cookieEnabled", "doNotTrack", "hardwareConcurrency", "language", "maxTouchPoints", "platform", "product", "productSub", "userAgent", "vendor", "vendorSub"]), i.addProperties(e, window.screen, "screen_", ["width", "height", "availHeight", "availWidth", "availTop", "availLeft", "colorDepth"]), window.screen && window.screen.orientation);
                        return t && (e.orientation_angle = t.angle, e.orientation_type = t.type), e.screenX = window.screenX, e.screenY = window.screenY, e.WebGL = !!i.detectWebGL(), e
                    }
                    static addProperties(e, t, s, r) {
                        if (t)
                            for (const i of r) e[s + i] = t[i]
                    }
                    static redirectToURL(e) {
                        window.location.href = e
                    }
                    static open(e, t, s) {
                        return window.open(e, t, s)
                    }
                }
                i._isDesktop = void 0
            },
            5433: (e, t, s) => {
                s.d(t, {
                    P: () => r
                });
                class r {
                    static openFileDialogue(e = !1, t = null, s, r = window.document) {
                        const i = r.createElement("input");
                        i.type = "file", i.style.display = "none", r.body.appendChild(i), e && (i.multiple = !0), t && (i.accept = t.join(",")), i.onchange = e => {
                            var t;
                            null != (t = i.parentNode) && t.removeChild(i), i.onchange = null, i.files && s(i.files)
                        }, i.click()
                    }
                    static downloadTextFile(e, t) {
                        e = new Blob([e], {
                            type: "text/plain"
                        });
                        r.downloadFile(e, t)
                    }
                    static downloadFile(e, t = "", s = window.document) {
                        e = window.URL.createObjectURL(e);
                        return r.downloadFileFromUrl(e, t, s)
                    }
                    static downloadFileFromUrl(e, t, s = window.document) {
                        var r = s.createElement("a");
                        r.href = e, r.setAttribute("download", t), r.download = t, r.style.display = "none", s.body.appendChild(r), r.click(), s.body.removeChild(r)
                    }
                    static loadImageFile(e, t) {
                        const s = new Image;
                        return t && (s.onload = () => {
                            t(s)
                        }), s.src = URL.createObjectURL(e), s
                    }
                    static async readAsArraybuffer(s) {
                        return new Promise(e => {
                            const t = new FileReader;
                            t.onload = () => {
                                t.onload = null, e(t.result)
                            }, t.readAsArrayBuffer(s)
                        })
                    }
                    static readAsText(e, t) {
                        const s = new FileReader;
                        s.onload = () => {
                            s.onload = null, t(s.result)
                        }, s.readAsText(e)
                    }
                    static isVideo(e) {
                        return this.matches(e, /video.*/)
                    }
                    static isImageFile(e) {
                        return this.matches(e, /image.*/)
                    }
                    static matches(e, t) {
                        e = e.type || this.getExtension(e.name);
                        return !e || e.match(t)
                    }
                    static iterate(t, s) {
                        for (let e = 0; e < t.length; ++e) s(t[e], e)
                    }
                    static getMimeType(e) {
                        switch (e) {
                            case "png":
                                return "image/png";
                            case "jpg":
                            case "jpeg":
                                return "image/jpeg";
                            case "gif":
                                return "image/gif";
                            case "webp":
                                return "image/webp";
                            case "svg":
                                return "image/svg+xml";
                            case "mp3":
                                return "audio/mpeg";
                            case "mp4":
                                return "video/mp4";
                            case "webm":
                                return "video/webm";
                            case "ogg":
                                return "video/ogg"
                        }
                        return ""
                    }
                    static getFileNameWithExtension(e) {
                        return e && e.split("/").pop() || e
                    }
                    static getFileName(e) {
                        return e && this.getFileNameWithExtension(e).split(".").shift() || e
                    }
                    static getExtension(e) {
                        return ((e = e || "").split(".").pop() || e).toLowerCase().split("?")[0]
                    }
                    static ensureExtension(e, t) {
                        return r.getExtension(e) !== t && (e += "." + t), e
                    }
                    static changeExtension(e, t) {
                        return r.getExtension(e) !== t && (e = r.removeExtension(e), e += "." + t), e
                    }
                    static removeExtension(e) {
                        return e.replace(/\.[^/.]+$/, "")
                    }
                }
            },
            4207: (e, t, s) => {
                s.d(t, {
                    M: () => r
                });
                class r {
                    static leftPad(e, t, s = "0") {
                        e += "";
                        return t <= e.length ? e : new Array(t - e.length + 1).join(s) + e
                    }
                    static trim(e) {
                        return (e = e || "").trim ? e.trim() : e
                    }
                    static splitByWhiteSpace(e) {
                        return (e = e || "").split(/\s+/)
                    }
                    static equalsIgnoreCase(e, t) {
                        return t = t || "", !!(e = e || "").toLowerCase && !!t.toLowerCase && (e = e.toLowerCase()) === t.toLowerCase()
                    }
                    static containsIgnoreCase(e, t) {
                        return t = t || "", !!(e = e || "").toLowerCase && !!t.toLowerCase && (e = e.toLowerCase(), t = t.toLowerCase(), e.includes(t))
                    }
                    static sortIgnoreCase(e, t) {
                        return t = t || "", (e = e || "").toLowerCase && t.toLowerCase ? (e = e.toLowerCase()) < t.toLowerCase() ? -1 : 1 : 0
                    }
                }
            },
            2841: (e, t, s) => {
                s.d(t, {
                    P: () => l
                });
                var o = s(6407);
                class l {
                    static get canvas() {
                        return l._canvas || (l._canvas = document.createElement("canvas")), l._canvas
                    }
                    static get ctx() {
                        return l._ctx || (l._ctx = l.canvas.getContext("2d")), l._ctx
                    }
                    static resizeImage(e, t, s) {
                        var r = document.createElement("canvas");
                        return r.width = t, r.height = s, r.getContext("2d").drawImage(e, 0, 0, r.width, r.height), r
                    }
                    static resizeToClosestPOT(e) {
                        var t = e.width,
                            s = e.height,
                            r = o.M.nextHighestPowerOfTwo(t),
                            i = o.M.previousHighestPowerOfTwo(t),
                            a = o.M.nextHighestPowerOfTwo(s),
                            n = o.M.previousHighestPowerOfTwo(s),
                            a = a - s < t - n ? a : n;
                        return t !== (n = r - t < t - i ? r : i) || s !== a ? l.resizeImage(e, n, a) : e
                    }
                    static isNPOT(e) {
                        var t = e.width,
                            e = e.height;
                        return !o.M.isPowerOfTwo(t) || !o.M.isPowerOfTwo(e)
                    }
                }
            },
            1668: (e, t, s) => {
                s.d(t, {
                    i: () => a
                });
                var r = s(7934);
                class a {
                    static load(e) {
                        return new a(e)
                    }
                    static encodeParams(e) {
                        var t, s = [];
                        for (t in e) {
                            var r = a.encodeParam(t, e[t]);
                            s.push(r)
                        }
                        return s.join("&")
                    }
                    static encodeParam(e, t) {
                        try {
                            "string" != typeof t && (t = JSON.stringify(t))
                        } catch (e) {
                            console.error(e)
                        }
                        return encodeURIComponent(e) + "=" + encodeURIComponent(t)
                    }
                    static createCORSRequest(e, t, s) {
                        var r = new XMLHttpRequest;
                        return "withCredentials" in r ? (r.open(e, t, s), r) : null
                    }
                    constructor(e) {
                        this._result = "", this._responseText = "", this._success = !1, this.onLoad = s => {
                            if (200 === this._xhr.status)
                                if (this._xhr.responseType && "text" !== this._xhr.responseType || (this._responseText = this._xhr.responseText), this._config.json) {
                                    let t = !0;
                                    try {
                                        this._result = JSON.parse(this._responseText)
                                    } catch (e) {
                                        this.terminate(!1, "Invalid JSON! Check the responseText property to debug!", s), t = !1
                                    }
                                    t && this.terminate(!0, "success", s)
                                } else "arraybuffer" === this._xhr.responseType ? this._result = this._xhr.response : this._result = this._responseText, this.terminate(!0, "success", s);
                            else this.terminate(!1, "Response status is not 200!", s)
                        }, this.onAbort = e => {
                            this.terminate(!1, "aborted", e)
                        }, this.onError = e => {
                            this.terminate(!1, "error", e, !0)
                        }, this.onTimeout = e => {
                            this.terminate(!1, "timeout", e)
                        }, this.retry = () => {
                            this.load()
                        }, this._config = r.g.mergeConfig(a.defaultConfig, e), this._timeStarted = Date.now(), this._timeFinished = -1, this._tryCount = 0, this._resultMessage = "", this._xhr = this.load()
                    }
                    load() {
                        var e;
                        let t = this._config.url;
                        var s = this._config.method || a.defaultConfig.method || a.METHOD_GET,
                            r = this._config.params,
                            i = (this._config.addNoCacheUrl && (r.noCache = Date.now()), s === a.METHOD_GET && 0 < Object.keys(r).length && (t += "?" + a.encodeParams(r)), this._xhr = new XMLHttpRequest, this._config.responseType && (this._xhr.responseType = this._config.responseType), this._config.proxy || t);
                        if (!i) throw new Error("No url specified!");
                        if (this._xhr.open(s, i, null == (e = this._config.async) || e), this.addListeners(), this._tryCount++, this._config.proxy && this._xhr.setRequestHeader("X-Proxy-URL", t), s === a.METHOD_POST) {
                            const e = a.encodeParams(r);
                            this._xhr.setRequestHeader("Content-type", "application/x-www-form-urlencoded"), this._xhr.send(e)
                        } else this._xhr.send();
                        return this._xhr
                    }
                    addListeners() {
                        this._xhr.addEventListener("load", this.onLoad), this._xhr.addEventListener("error", this.onError), this._xhr.addEventListener("timeout", this.onTimeout), this._xhr.addEventListener("abort", this.onAbort)
                    }
                    abort() {
                        this._xhr.abort()
                    }
                    terminate(e, t, s, r) {
                        if (this._success = e, this._resultMessage = t, this._event = s, this._success) null != (t = (e = this._config).onSuccess) && t.call(e, this);
                        else if (r) {
                            const e = this._config.maxTries || 0;
                            this._tryCount < e ? setTimeout(this.retry, this._config.retryDelay) : this.fail()
                        } else this.fail();
                        this._config.onComplete && this._config.onComplete(this)
                    }
                    fail() {
                        this._config.onFail && this._config.onFail(this)
                    }
                    get config() {
                        return this._config
                    }
                    get result() {
                        return this._result
                    }
                    get responseText() {
                        return this._responseText
                    }
                    get successful() {
                        return this._success
                    }
                    get resultMessage() {
                        return this._resultMessage
                    }
                    get xhr() {
                        return this._xhr
                    }
                }
                a.METHOD_POST = "POST", a.METHOD_GET = "GET", a.defaultConfig = {
                    url: "",
                    params: {},
                    method: a.METHOD_GET,
                    async: !0,
                    addNoCacheUrl: !1,
                    json: !1,
                    maxTries: 0,
                    retryDelay: 5e3
                }
            },
            4755: (e, t, s) => {
                s.d(t, {
                    h: () => r
                });
                class r {
                    static getClass(e) {
                        return e.constructor
                    }
                }
            },
            9720: (e, t, s) => {
                s.d(t, {
                    M: () => r
                });
                class r {
                    static create() {
                        return new r
                    }
                    constructor() {
                        this._shouldPropagate = !0, this._bindings = []
                    }
                    add(e, t, s = 0) {
                        this.registerListener(e, !1, t, s)
                    }
                    addAndCall(e, t, s = 0) {
                        this.registerListener(e, !1, t, s), e.call(t = t || this)
                    }
                    addOnce(e, t, s = 0) {
                        this.registerListener(e, !0, t, s)
                    }
                    registerListener(e, t, s, r = 0) {
                        var i = this.indexOfListener(e, s);
                        let a = null;
                        if (-1 !== i) {
                            if ((a = this._bindings[i]).isOnce !== t) throw new Error("You cannot add" + (t ? "" : "Once") + "() then add" + (t ? "Once" : "") + "() the same listener without removing the relationship first.")
                        } else a = {
                            listener: e,
                            context: s,
                            isOnce: t,
                            priority: r
                        }, this.addBinding(a)
                    }
                    addBinding(e) {
                        let t = this._bindings.length;
                        for (; --t, this._bindings[t] && e.priority <= this._bindings[t].priority;);
                        this._bindings.splice(t + 1, 0, e)
                    }
                    indexOfListener(t, s) {
                        for (let e = this._bindings.length - 1; 0 <= e; --e) {
                            var r = this._bindings[e];
                            if (r.listener === t && r.context === s) return e
                        }
                        return -1
                    }
                    has() {}
                    halt() {
                        this._shouldPropagate = !1
                    }
                    remove(e, t) {
                        e = this.indexOfListener(e, t);
                        return -1 !== e && (this._bindings.splice(e, 1), !0)
                    }
                    removeAll() {
                        this._bindings.length = 0
                    }
                    dispatch() {
                        var t = Array.prototype.slice.call(arguments),
                            s = (this._shouldPropagate = !0, this._bindings);
                        for (let e = s.length - 1; 0 <= e && !1 !== s[e].listener.apply(s[e].context, t) && this._shouldPropagate; --e);
                    }
                    dispose() {
                        this.removeAll()
                    }
                }
            },
            1022: (e, t, s) => {
                s.d(t, {
                    F: () => i
                });
                var r = s(9720);
                class i {
                    static getInstance(e) {
                        return i.instance || (i.instance = new i(e))
                    }
                    constructor(e) {
                        this.dt = 0, this.time = 0, this.speed = 1, this._lastTime = 0, this._state = i.STATE_STOPPED, this._requestId = 0, this.onFrame = e => {
                            this._requestId = 0;
                            var t = (e - this._lastTime) * this.speed;
                            this._lastTime = e, this.dt = t, this.time += t, this._requestId = window.requestAnimationFrame(this.onFrame), this.update.dispatch(this)
                        }, this.update = new r.M
                    }
                    init(e, t) {
                        this.update.add(e, t), this.start()
                    }
                    start() {
                        if (this._state === i.STATE_STARTED) return this.now();
                        this._state = i.STATE_STARTED;
                        var e = this.now();
                        return this._lastTime = e, this.cancelFrame(), this._requestId = window.requestAnimationFrame(this.onFrame), e
                    }
                    stop() {
                        this._state !== i.STATE_STOPPED && (this._state = i.STATE_STOPPED, this.cancelFrame())
                    }
                    now() {
                        return (window && window.performance && window.performance.now ? window.performance : Date).now()
                    }
                    seek(e) {
                        this.time !== e && (this._lastTime = e, this.time = e, this.update.dispatch(this))
                    }
                    cancelFrame() {
                        this._requestId && (window.cancelAnimationFrame(this._requestId), this._requestId = 0)
                    }
                }
                i.STATE_STOPPED = "stopped", i.STATE_STARTED = "started"
            },
            1533: e => {
                e.exports = ReactDOM
            }
        },
        r = {};

    function c(e) {
        var t = r[e];
        return void 0 !== t || (t = r[e] = {
            exports: {}
        }, s[e](t, t.exports, c)), t.exports
    }
    c.m = s, c.amdO = {}, l = Object.getPrototypeOf ? e => Object.getPrototypeOf(e) : e => e.__proto__, c.t = function(t, e) {
        if (1 & e && (t = this(t)), 8 & e) return t;
        if ("object" == typeof t && t) {
            if (4 & e && t.__esModule) return t;
            if (16 & e && "function" == typeof t.then) return t
        }
        var s = Object.create(null),
            r = (c.r(s), {});
        a = a || [null, l({}), l([]), l(l)];
        for (var i = 2 & e && t;
            "object" == typeof i && !~a.indexOf(i); i = l(i)) Object.getOwnPropertyNames(i).forEach(e => r[e] = () => t[e]);
        return r.default = () => t, c.d(s, r), s
    }, c.d = (e, t) => {
        for (var s in t) c.o(t, s) && !c.o(e, s) && Object.defineProperty(e, s, {
            enumerable: !0,
            get: t[s]
        })
    }, c.f = {}, c.e = s => Promise.all(Object.keys(c.f).reduce((e, t) => (c.f[t](s, e), e), [])), c.u = e => ({
        114: "ZipLoader",
        162: "FBXLoader",
        231: "STLLoader",
        297: "IFCImporter",
        542: "fflate",
        578: "jszip",
        651: "USDZLoader",
        849: "DracoLoader",
        857: "PLYLoader",
        877: "ObjLoader"
    }[e] || e) + ".chunk.js", c.g = function() {
        if ("object" == typeof globalThis) return globalThis;
        try {
            return this || new Function("return this")()
        } catch (e) {
            if ("object" == typeof window) return window
        }
    }(), c.o = (e, t) => Object.prototype.hasOwnProperty.call(e, t), L = {}, c.l = (r, e, t, s) => {
        if (L[r]) L[r].push(e);
        else {
            var i, a;
            if (void 0 !== t)
                for (var n = document.getElementsByTagName("script"), o = 0; o < n.length; o++) {
                    var l = n[o];
                    if (l.getAttribute("src") == r) {
                        i = l;
                        break
                    }
                }
            i || (a = !0, (i = document.createElement("script")).charset = "utf-8", i.timeout = 120, c.nc && i.setAttribute("nonce", c.nc), i.src = r), L[r] = [e];
            var t = (e, t) => {
                    i.onerror = i.onload = null, clearTimeout(h);
                    var s = L[r];
                    if (delete L[r], i.parentNode && i.parentNode.removeChild(i), s && s.forEach(e => e(t)), e) return e(t)
                },
                h = setTimeout(t.bind(null, void 0, {
                    type: "timeout",
                    target: i
                }), 12e4);
            i.onerror = t.bind(null, i.onerror), i.onload = t.bind(null, i.onload), a && document.head.appendChild(i)
        }
    }, c.r = e => {
        "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {
            value: "Module"
        }), Object.defineProperty(e, "__esModule", {
            value: !0
        })
    }, c.p = "src/", D = {
        179: 0
    }, c.f.j = (s, e) => {
        var t, r, i = c.o(D, s) ? D[s] : void 0;
        0 !== i && (i ? e.push(i[2]) : (t = new Promise((e, t) => i = D[s] = [e, t]), e.push(i[2] = t), e = c.p + c.u(s), r = new Error, c.l(e, e => {
            var t;
            c.o(D, s) && (0 !== (i = D[s]) && (D[s] = void 0), i) && (t = e && ("load" === e.type ? "missing" : e.type), e = e && e.target && e.target.src, r.message = "Loading chunk " + s + " failed.\n(" + t + ": " + e + ")", r.name = "ChunkLoadError", r.type = t, r.request = e, i[1](r))
        }, "chunk-" + s, s)))
    }, j = (e, t) => {
        var s, r, [i, a, n] = t,
            o = 0;
        if (i.some(e => 0 !== D[e])) {
            for (s in a) c.o(a, s) && (c.m[s] = a[s]);
            n && n(c)
        }
        for (e && e(t); o < i.length; o++) r = i[o], c.o(D, r) && D[r] && D[r][0](), D[r] = 0
    }, (t = self.webpackChunk = self.webpackChunk || []).forEach(j.bind(null, 0)), t.push = j.bind(null, t.push.bind(t));
    var j = {}; {
        c.d(j, {
            g: () => Y
        });
        const u = React;
        var K = c(651),
            n = c(9720),
            p = c(5433),
            t = c(2718),
            q = c(4955),
            T = c(2263),
            o = c(6646),
            $ = c(6039),
            X = c(6780),
            A = c(4735),
            Z = c(604),
            M = c(82),
            b = c(1695),
            J = c(7934),
            x = c(5216),
            w = c(428);
        class ot {
            constructor(e) {
                this.counter = 0, this.array = e
            }
            push(...e) {
                for (const t of e) this.array[this.counter] = t, this.counter++
            }
        }
        class lt {
            static createGeometry(s) {
                var r, i;
                const a = lt.processOptions(s),
                    n = a.indices ? (a.uSteps + 1) * (a.vSteps + 1) : a.uSteps * a.vSteps * 6,
                    o = a.attributes.some(e => e.semantic === A.p.NORMAL),
                    l = a.attributes.some(e => e.semantic === A.p.TEXCOORD_0);
                let h = 3;
                o && (h += 3), l && (h += 2);
                var c = (null == (r = a.target) ? void 0 : r.vertex) || new ot(new Float32Array(n * h));
                let d;
                if (a.indices) {
                    const s = a.uSteps * a.vSteps * 6,
                        r = (null == (i = a.target) ? void 0 : i.index) || new ot(new Uint16Array(s)),
                        n = M.R.create(),
                        h = M.R.create();
                    for (let t = 0; t <= a.vSteps; ++t)
                        for (let e = 0; e <= a.uSteps; ++e) {
                            const d = a.uMin + (a.uMax - a.uMin) * (e / a.uSteps),
                                _ = a.vMin + (a.vMax - a.vMin) * (t / a.vSteps),
                                f = a.surface.getVertexByUV(d, _, n, h);
                            if (c.push(f[0], f[1], f[2]), o && c.push(h[0], h[1], h[2]), l && c.push(d, _), e < a.uSteps && t < a.vSteps) {
                                const n = e + t * (a.uSteps + 1),
                                    o = e + 1 + t * (a.uSteps + 1),
                                    l = e + (t + 1) * (a.uSteps + 1),
                                    h = e + 1 + (t + 1) * (a.uSteps + 1);
                                r.push(n, o, h, n, h, l)
                            }
                        }
                    d = x.Y.fromData(r.array)
                } else {
                    const s = M.R.create(),
                        r = M.R.create(),
                        i = M.R.create(),
                        n = M.R.create();
                    var u = M.R.create(),
                        p = M.R.create(),
                        m = M.R.create(),
                        g = M.R.create();
                    for (let t = a.uMin; t < a.uMax; t += a.uStep)
                        for (let e = a.vMin; e < a.vMax; e += a.vStep) {
                            const M = t + a.uStep,
                                b = e + a.vStep,
                                v = a.surface.getVertexByUV(t, e, s, u),
                                x = a.surface.getVertexByUV(M, e, r, p),
                                w = a.surface.getVertexByUV(M, b, i, m),
                                ot = a.surface.getVertexByUV(t, b, n, g);
                            o && l ? c.push(v[0], v[1], v[2], u[0], u[1], u[2], t, e, x[0], x[1], x[2], p[0], p[1], p[2], M, e, w[0], w[1], w[2], m[0], m[1], m[2], M, b, v[0], v[1], v[2], u[0], u[1], u[2], t, e, w[0], w[1], w[2], m[0], m[1], m[2], M, b, ot[0], ot[1], ot[2], g[0], g[1], g[2], t, b) : o ? c.push(v[0], v[1], v[2], u[0], u[1], u[2], x[0], x[1], x[2], p[0], p[1], p[2], w[0], w[1], w[2], m[0], m[1], m[2], v[0], v[1], v[2], u[0], u[1], u[2], w[0], w[1], w[2], m[0], m[1], m[2], ot[0], ot[1], ot[2], g[0], g[1], g[2]) : l ? c.push(v[0], v[1], v[2], t, e, x[0], x[1], x[2], M, e, w[0], w[1], w[2], M, b, v[0], v[1], v[2], t, e, w[0], w[1], w[2], M, b, ot[0], ot[1], ot[2], t, b) : c.push(v[0], v[1], v[2], x[0], x[1], x[2], w[0], w[1], w[2], v[0], v[1], v[2], w[0], w[1], w[2], ot[0], ot[1], ot[2])
                        }
                }
                return new Z.Z({
                    indexBuffer: d,
                    buffers: [new b.t({
                        buffer: new w.f({
                            data: c.array
                        }),
                        attributes: a.attributes
                    })]
                })
            }
            static processOptions(e) {
                e = J.g.mergeConfig(lt.defaultOptions, e);
                return e.uSteps || (e.uSteps = 10), 0 < e.vSteps || (e.vSteps = e.uSteps), e.uStep = (e.uMax - e.uMin) / e.uSteps, e.vStep = (e.vMax - e.vMin) / e.vSteps, e.attributes.length || (e.attributes = [{
                    size: 3,
                    semantic: A.p.POSITION
                }, {
                    size: 3,
                    semantic: A.p.NORMAL
                }, {
                    size: 2,
                    semantic: A.p.TEXCOORD_0
                }]), e
            }
        }
        lt.defaultOptions = {
            indices: !0,
            interleaved: !0,
            surface: {
                getVertexByUV: (e, t, s, r) => {
                    throw new Error("surface is required")
                }
            },
            uSteps: 10,
            uMin: 0,
            uMax: 1,
            vSteps: 0,
            vMin: 0,
            vMax: 1,
            attributes: []
        };
        var d = c(4233);
        class ht {
            constructor(e = 1, t) {
                this.center = t || M.R.fromValues(0, 0, 0), this.r = e
            }
            contains(e) {
                return M.R.squaredDistance(e, this.center) < this.r * this.r
            }
            getVertexByUV(e, t, s, r) {
                s = s || M.R.create();
                var t = (t - .5) * Math.PI,
                    e = e * Math.PI * 2,
                    i = this.r * Math.sin(t),
                    t = this.r * Math.cos(t),
                    a = t * Math.cos(e),
                    t = -t * Math.sin(e),
                    e = this.center;
                return s[0] = e[0] + a, s[1] = e[1] + i, s[2] = e[2] + t, r && (r[0] = a, r[1] = i, r[2] = t, 1 !== this.r) && M.R.normalize(r, r), s
            }
        }
        var _ = c(1201);
        class ct {
            constructor() {}
            create(e) {
                var t = { ...ct.defaultOptions,
                    ...e
                };
                if ("fan" === t.triangleStrategy) return this.createGeometryFan(t); {
                    const e = this.createVertexDataInterleavedIndexed(t, !1),
                        s = this.createIndexBuffer(t);
                    return new Z.Z({
                        indexBuffer: s,
                        buffers: [new b.t({
                            buffer: new w.f({
                                data: e
                            }),
                            attributes: t.attributes
                        })]
                    })
                }
            }
            createGeometryFan(e) {
                var t = this.createVertexDataInterleavedIndexed(e, !0),
                    s = this.createIndexBufferFan(e);
                return new Z.Z({
                    indexBuffer: s,
                    buffers: [new b.t({
                        buffer: new w.f({
                            data: t
                        }),
                        attributes: e.attributes
                    })]
                })
            }
            createIndexBufferFan(t) {
                var e;
                let s;
                if (t.indices) {
                    var r = 3 * t.segments,
                        i = (null == (e = t.target) ? void 0 : e.index) || new ot(new Uint16Array(r)),
                        a = t.startIndex;
                    for (let e = 1; e <= t.segments; ++e) {
                        const s = e,
                            n = e === t.segments ? 1 : e + 1;
                        i.push(a + 0, a + s, a + n)
                    }
                    s = x.Y.fromData(i.array)
                }
                return s
            }
            createIndexBuffer(e) {
                throw e.indices, new Error("Not implemented")
            }
            createVertexDataInterleavedIndexed(t, e = !1) {
                var s, r = t.segments + (e ? 1 : 0),
                    i = t.attributes.some(e => e.semantic === A.p.NORMAL),
                    a = t.attributes.some(e => e.semantic === A.p.TEXCOORD_0);
                let n = 3;
                i && (n += 3), a && (n += 2);
                var o = (null == (s = t.target) ? void 0 : s.vertex) || new ot(new Float32Array(r * n));
                e && (o.push(0, 0, 0), i && o.push(0, 0, 1), a) && o.push(0, 0);
                for (let e = 0; e < r; ++e) {
                    const s = 2 * Math.PI * (e / (r - 1)),
                        n = t.center[0] + Math.cos(s) * t.radius,
                        l = t.center[1] + Math.sin(s) * t.radius;
                    o.push(n, l, 0), i && o.push(0, 0, 1), a && o.push(0, 0)
                }
                return o.array
            }
        }
        ct.defaultOptions = {
            indices: !0,
            startIndex: 0,
            interleaved: !0,
            radius: 1,
            center: [0, 0],
            segments: 20,
            triangleStrategy: "fan",
            mode: _.g.TRIANGLES,
            attributes: [{
                name: "a_position",
                size: 3,
                semantic: A.p.POSITION
            }, {
                name: "a_normal",
                size: 3,
                semantic: A.p.NORMAL
            }],
            target: void 0
        };
        class dt {
            constructor() {}
            create(e) {
                var t = { ...dt.defaultOptions,
                        ...e
                    },
                    s = t.attributes.some(e => e.semantic === A.p.NORMAL),
                    r = t.attributes.some(e => e.semantic === A.p.TEXCOORD_0);
                let i = 3;
                s && (i += 3), r && (i += 2);
                var a = new ot(new Float32Array(t.numberOfVertices * i));
                for (let e = 0; e < t.numberOfVertices; ++e) {
                    const i = 2 * Math.PI * (e / t.numberOfVertices),
                        n = t.center[0] + Math.cos(i) * t.radius,
                        o = t.center[0] + Math.sin(i) * t.radius;
                    a.push(n, o, 0), s && a.push(0, 0, 0), r && a.push(0, 0)
                }
                return new Z.Z({
                    mode: _.g.LINE_LOOP,
                    buffers: [new b.t({
                        buffer: new w.f({
                            data: a.array
                        }),
                        attributes: t.attributes
                    })]
                })
            }
        }
        dt.defaultOptions = {
            indices: !1,
            interleaved: !0,
            radius: 1,
            center: [0, 0],
            numberOfVertices: 20,
            mode: _.g.LINE_LOOP,
            attributes: [{
                name: "a_position",
                size: 3,
                semantic: A.p.POSITION
            }, {
                name: "a_normal",
                size: 3,
                semantic: A.p.NORMAL
            }]
        };
        class ut {
            static getElementsPerVertex(e) {
                let t = 3;
                return e.attributes.some(e => e.semantic === A.p.NORMAL) && (t += 3), e.attributes.some(e => e.semantic === A.p.TEXCOORD_0) && (t += 2), t
            }
            constructor() {}
            createPlane(e) {
                const t = { ...ut.defaultOptions,
                        ...e
                    },
                    {
                        segmentsW: s,
                        segmentsH: r,
                        ...i
                    } = t;
                return lt.createGeometry({
                    surface: new d.A,
                    uSteps: t.segmentsW,
                    vSteps: t.segmentsH,
                    ...i
                })
            }
            createCube() {
                return new Z.Z({
                    indexBuffer: x.Y.fromData(new Uint16Array([0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11, 12, 13, 14, 12, 14, 15, 16, 17, 18, 16, 18, 19, 20, 21, 22, 20, 22, 23])),
                    buffers: [new b.t({
                        buffer: new w.f({
                            data: new Float32Array([-1, -1, 1, 0, 0, 1, -1, 1, 1, 0, 1, 1, 1, 1, 1, -1, 1, 1, 0, 1, 1, -1, -1, 0, 0, -1, -1, -1, 1, 0, -1, 1, -1, 1, 1, 1, 1, -1, 0, 1, 1, -1, 1, 0, 0, 1, -1, -1, 1, 0, 1, 1, -1, 1, 1, 1, 1, 1, 0, 1, -1, -1, -1, 0, 0, -1, -1, 1, 1, 0, -1, 1, 1, 1, 1, -1, 1, -1, 0, 1, -1, -1, -1, 0, 0, 1, -1, -1, 1, 0, 1, -1, 1, 1, 1, -1, -1, 1, 0, 1, 1, 1, -1, 0, 0, -1, 1, -1, 1, 0, -1, 1, 1, 1, 1, 1, 1, 1, 0, 1])
                        }),
                        attributes: [{
                            size: 3,
                            semantic: A.p.POSITION
                        }, {
                            size: 2,
                            semantic: A.p.TEXCOORD_0
                        }]
                    })]
                })
            }
            createSphere(e) {
                e = { ...ut.defaultOptions,
                    segmentsW: 30,
                    segmentsH: 30,
                    ...e
                };
                return lt.createGeometry({
                    surface: new ht,
                    uSteps: e.segmentsW,
                    vSteps: e.segmentsH,
                    attributes: e.attributes,
                    indices: e.indices,
                    interleaved: e.interleaved
                })
            }
            createCone() {
                throw new Error("Not implemented")
            }
            createDisc() {
                return (new ct).create()
            }
            createCircle() {
                return (new dt).create()
            }
            createCylinder() {
                throw new Error("Not implemented")
            }
        }
        ut.defaultOptions = {
            indices: !0,
            interleaved: !0,
            segmentsW: 1,
            segmentsH: 1,
            attributes: [{
                name: "a_position",
                size: 3,
                semantic: A.p.POSITION
            }, {
                name: "a_normal",
                size: 3,
                semantic: A.p.NORMAL
            }, {
                name: "a_uv",
                size: 2,
                semantic: A.p.TEXCOORD_0
            }],
            target: void 0
        };
        class pt extends t.a {
            constructor() {
                super({})
            }
            loadFile(s, r) {
                return new Promise(async e => {
                    this._scene.name = s.name;
                    var t = r.filter(e => p.P.isImageFile(e)).map(e => this.loadImage(e));
                    for (const s of await Promise.all(t)) this._scene.add(s);
                    e(this)
                })
            }
            loadImage(r) {
                return new Promise(t => {
                    const s = new Image;
                    s.src = URL.createObjectURL(r), s.onload = () => {
                        var e = new q.B({
                            name: r.name,
                            renderNodes: [new T.j({
                                material: new o.q({
                                    metallicFactor: 0,
                                    roughnessFactor: 1,
                                    baseColorTexture: new $.l({
                                        texture: X.x.from({
                                            source: s
                                        })
                                    })
                                }),
                                geometry: (new ut).createPlane()
                            })]
                        });
                        e.transform.scale.set(s.naturalWidth / s.naturalHeight, 1, 1), t(e)
                    }
                })
            }
        }
        class mt {
            static get instance() {
                return mt._instance || (mt._instance = new mt)
            }
            constructor() {}
            async findLoader(e) {
                e = p.P.getExtension(e.name);
                return this.findLoaderByType(e)
            }
            async findLoaderByType(e) {
                switch (e) {
                    case "obj":
                        return new(await c.e(877).then(c.bind(c, 1285))).OBJLoader({});
                    case "zip":
                        return new(await c.e(114).then(c.bind(c, 306))).ZipLoader({});
                    case "stl":
                        return new(await c.e(231).then(c.bind(c, 6010))).STLLoader({});
                    case "ply":
                        return new(await c.e(857).then(c.bind(c, 3547))).PLYLoader({});
                    case "usd":
                    case "usdz":
                    case "usdc":
                    case "usda":
                        return new(await c.e(651).then(c.bind(c, 522))).USDZLoader;
                    case "gltf":
                    case "glb":
                        return new(await Promise.resolve().then(c.bind(c, 8539))).glTFLoader({});
                    case "ifc":
                        return new(await c.e(297).then(c.bind(c, 2853))).IFCImporter("");
                    case "fbx":
                    case "dae":
                    case "blend":
                    case "3ds":
                        return new(await c.e(162).then(c.bind(c, 6745))).AssimpLoader("");
                    case "jpg":
                    case "jpeg":
                    case "png":
                    case "webp":
                    case "gif":
                    case "bmp":
                    case "tiff":
                    case "svg":
                    case "tga":
                        return new pt;
                    default:
                        return console.warn("Loader not found for type: " + e), new(await c.e(162).then(c.bind(c, 6745))).AssimpLoader("")
                }
            }
        }
        mt.mainFileTypes = ["gltf", "glb", "obj", "zip", "stl", "ply", "usd", "usdz", "usdc", "usda", "jpg", "jpeg", "png", "webp", "gif", "bmp", "tiff", "svg", "tga", "fbx", "dae", "blend", "3ds", "ase", "ifc", "xgl", "zgl", "dxf", "lwo", "lws", "lxo", "x", "ac", "ms3d", "cob", "scn"];
        class gt {
            constructor() {
                this.signals = {
                    change: n.M.create(),
                    loaded: n.M.create()
                }, this.onLoaderUpdate = () => {
                    this.signals.change.dispatch()
                }
            }
            async load(e) {
                var t = p.P.getExtension(e),
                    t = await mt.instance.findLoaderByType(t);
                if (t) return t.signals.change.add(this.onLoaderUpdate), t.load(e)
            }
            async loadFiles(e) {
                const t = [];
                let s = this.findMainFiles(e);
                s.every(e => p.P.isImageFile(e)) || (s = s.filter(e => !p.P.isImageFile(e)));
                for (const p of s) {
                    const s = await mt.instance.findLoader(p);
                    if (s) {
                        s.signals.change.add(this.onLoaderUpdate);
                        const r = s.loadFile(p, e);
                        t.push(r)
                    }
                }
                const r = await Promise.all(t),
                    i = [];
                for (const e of r)
                    if (0 < e.zipFiles.length) {
                        const t = await this.loadFiles(e.zipFiles);
                        i.push(...t)
                    } else i.push(e);
                return i
            }
            findMainFiles(e) {
                var t = [];
                for (const s of e) {
                    const e = p.P.getExtension(s.name);
                    mt.mainFileTypes.includes(e) && t.push(s)
                }
                return t
            }
        }
        var Q = c(7409);
        class _t {
            constructor(e) {
                this.signals = {
                    change: n.M.create(),
                    loadStarted: n.M.create(),
                    loadCompleted: n.M.create()
                }, this._assetLoader = new gt, this._asset = {
                    version: _t.defaultVersion,
                    generator: _t.defaultGenerator
                }, this.onLoaderUpdate = () => {
                    this._scene.signals.change.dispatch()
                }, this.onLoaded = async (t, e = !1) => {
                    const s = t.map(e => e.onAllMeshesLoaded());
                    let r;
                    await Promise.all(s);
                    var i = t[0];
                    if (null != i && i.scene) {
                        if (r = i.scene, e)
                            for (const t of i.scene.children) r = t, this._scene.add(t);
                        else this._scene = i.scene, this._scene.name = this._scene.name || "Scene";
                        this.applyParams(this._scene), this._scenes = i.scenes, this._animationEngine = i.animationEngine || void 0, i.copyright && (this._asset = i.copyright, this._asset.generator = this._asset.generator || _t.defaultGenerator, this._asset.version = this._asset.version || _t.defaultVersion);
                        for (let e = 1; e < t.length; ++e) {
                            const s = t[e];
                            for (const t of s.scene.children) this._scene.add(t)
                        }
                        this.signals.change.dispatch(this)
                    }
                    setTimeout(() => {
                        this.signals.loadCompleted.dispatch(r)
                    }, 0)
                }, this._appParams = e, this._scene = this.createScene(), this._scenes = [this._scene]
            }
            async load(e) {
                e && (this._assetLoader.signals.change.add(this.onLoaderUpdate), this.signals.loadStarted.dispatch(), e = await this._assetLoader.load(e)) && this.onLoaded([e])
            }
            async loadFiles(e, t = !1) {
                e && e.length && (this._assetLoader.signals.change.add(this.onLoaderUpdate), this.signals.loadStarted.dispatch(), e = await this._assetLoader.loadFiles(e), await this.onLoaded(e, t))
            }
            setScene(e) {
                this._scene = e, this._scenes = [e], this._animationEngine = void 0
            }
            clear() {
                for (const e of this._scenes) e.dispose();
                this._scene = this.createScene(), this._scenes = [this._scene], this.signals.change.dispatch(this)
            }
            createScene() {
                var e = new K.x;
                return this.applyParams(e), e
            }
            applyParams(e) {
                e.background instanceof Q.$ && (e.background.color = this._appParams.background_color), e.lights.ibl.intensity = this._appParams.ibl_intensity
            }
            get scene() {
                return this._scene
            }
            get scenes() {
                return this._scenes
            }
            get asset() {
                return this._asset
            }
            get animationEngine() {
                return this._animationEngine
            }
        }
        _t.defaultVersion = "2.0", _t.defaultGenerator = "gltfeditor.com";
        var m = c(3629);
        class ft {
            constructor() {}
            static emptyFunction() {}
        }

        function h(e, t) {
            t || (t = e, e = "");
            let s = e || "";
            for (const e in t) e && t[e] && (0 < s.length && (s += " "), s += e);
            return s
        }
        class vt extends u.Component {
            constructor(e) {
                super(e), this.onClick = e => {
                    var t = e.target.getAttribute("data-color");
                    if (t) {
                        const e = parseInt(t, 10);
                        this.props.onChange(e)
                    }
                }
            }
            render() {
                var e = this.props.colors || vt.defaultProps.colors;
                return u.createElement("div", {
                    className: "colorPalette",
                    onClick: this.onClick
                }, e.map(e => {
                    var t = e === this.props.value;
                    return u.createElement("div", {
                        key: e,
                        "data-color": e,
                        className: h("color", {
                            selected: t
                        }),
                        style: {
                            backgroundColor: m.I.getCSSFromNumber(e)
                        }
                    })
                }))
            }
        }
        vt.defaultProps = {
            onChange: ft.emptyFunction,
            value: -1,
            colors: [16777215, 0, 15165535, 15826531, 16300128, 16436270, 15851614, 13162580, 8239459, 5612928, 5872286, 5736347, 5797530, 4939668, 7555728, 12016809]
        };
        var f = c(6407);
        class bt extends u.Component {
            constructor(e) {
                if (super(e), 1 !== u.Children.count(this.props.children)) throw new Error("PointerDetector should receive exactly 1 child!");
                this._child = this.props.children.ref || u.createRef()
            }
            render() {
                return this.props.children.ref ? this.props.children : u.cloneElement(this.props.children, {
                    ref: this._child
                })
            }
            componentDidMount() {
                var e = this._child.current;
                e && this.onChildMounted(e)
            }
            onChildMounted(e) {}
        }
        class xt {
            constructor(e) {
                this.canceled = !1, this.offsetX = 0, this.offsetY = 0, this.dx = 0, this.dy = 0, this.id = e.id, this.startX = e.localX, this.startY = e.localY, this.localX = e.localX, this.localY = e.localY, this.originalEvent = e.originalEvent, this.pointerData = e.pointerData
            }
            clone() {
                return new xt({
                    id: this.id,
                    localX: this.localX,
                    localY: this.localY,
                    originalEvent: this.originalEvent,
                    pointerData: this.pointerData
                })
            }
            get isNormalClick() {
                return this.button <= 0
            }
            get isRightClick() {
                return 2 === this.button
            }
            get isMiddleClick() {
                return 1 === this.button
            }
            get button() {
                var e;
                return !this.isMouse || void 0 === (e = this.originalEvent).button ? -1 : e.button
            }
            get isMouse() {
                return 1 === this.id
            }
            get isTouch() {
                return !this.isMouse
            }
        }
        var ee = c(4707);
        (t = ie = ie || {})[t.IMMEDIATE = 0] = "IMMEDIATE", t[t.REQUEST_ANIMATION_FRAME = 1] = "REQUEST_ANIMATION_FRAME", t[t.MANUAL = 2] = "MANUAL";
        class Tt {
            constructor(e) {
                var t;
                if (this.signals = {
                        down: n.M.create(),
                        move: n.M.create(),
                        up: n.M.create(),
                        hoverMove: n.M.create(),
                        anyUp: n.M.create(),
                        anyMove: n.M.create(),
                        multi: {
                            down: n.M.create(),
                            move: n.M.create(),
                            up: n.M.create()
                        }
                    }, this._touchTargets = [], this._focusLost = !1, this.onHoverMove = e => {
                        e = this.createPointer(1, e, e);
                        this._lastPointer = e, this.signals.hoverMove.dispatch(e, this.signals.hoverMove)
                    }, this.onAnyTouchMove = e => {
                        e = this.createPointer(1, e.changedTouches[0], e);
                        this._lastPointer = e, this.signals.anyMove.dispatch(e, this.signals.anyMove)
                    }, this.onAnyUp = e => {
                        var t = e instanceof TouchEvent ? e.changedTouches[0] : e,
                            t = this.createPointer(1, t, e);
                        this._lastPointer = t, this.signals.anyUp.dispatch(t, this.signals.anyUp)
                    }, this.onContextMenu = e => {
                        e.preventDefault()
                    }, this.onTouchStart = s => {
                        var e;
                        s.preventDefault();
                        const r = this._config.window.document.activeElement;
                        null != (e = null == r ? void 0 : r.blur) && e.call(r);
                        var i = [];
                        for (let e = 0, t = s.changedTouches.length; e < t; ++e) {
                            const r = s.changedTouches[e],
                                a = this.onPointerDown(r.identifier + 2, r, s);
                            a && i.push(a)
                        }
                        i.length && s.target instanceof HTMLElement && this.addTouchTarget(s.target), this._config.dispatchMultiEvents && this.signals.multi.down.dispatch(i, this.signals.multi.down)
                    }, this.onMouseDown = e => {
                        this.allowButton(e) && (this._config.window.document.addEventListener("mousemove", this.onMouseMove), this._config.window.document.addEventListener("mouseup", this.onMouseUp), this.onPointerDown(1, e, e))
                    }, this.onFocusBack = e => {
                        this._config.window.removeEventListener("focus", this.onFocusBack), this._focusLost = !1
                    }, this.onMouseMove = e => {
                        e.preventDefault(), this.onPointerMove(1, e, e)
                    }, this.onTouchMove = s => {
                        s.preventDefault();
                        var r = [];
                        for (let e = 0, t = s.changedTouches.length; e < t; e++) {
                            var i = s.changedTouches[e],
                                i = this.onPointerMove(i.identifier + 2, i, s);
                            i && r.push(i)
                        }
                        this._config.dispatchMultiEvents && this.signals.multi.move.dispatch(r, this.signals.multi.move)
                    }, this.onMouseUp = e => {
                        this.allowButton(e) && (e.preventDefault(), this._config.window.document.removeEventListener("mousemove", this.onMouseMove), this._config.window.document.removeEventListener("mouseup", this.onMouseUp), this.onPointerUp(1, e))
                    }, this.onTouchEnd = e => {
                        this.onTouchFinish(e, !1)
                    }, this.onTouchCancel = e => {
                        this.onTouchFinish(e, !0)
                    }, this.onTouchFinish = (s, r) => {
                        s.preventDefault();
                        var i = [];
                        for (let e = 0, t = s.changedTouches.length; e < t; ++e) {
                            var a = s.changedTouches[e],
                                a = this.onPointerUp(a.identifier + 2, s);
                            a && (a.canceled = r, i.push(a))
                        }
                        this._config.dispatchMultiEvents && this.signals.multi.up.dispatch(i, this.signals.multi.up)
                    }, !e.window) {
                    const n = null == (t = e.element || e.parent) ? void 0 : t.ownerDocument.defaultView;
                    n && (e.window = n)
                }
                this._config = J.g.mergeConfig(Tt.defaultConfig, e), this.pointers = {}, this.pointerArray = [], this._localCoords = [], this._config.autoEnable && this.enable()
            }
            enable() {
                var e = this._config.element;
                e && (e.addEventListener("touchstart", this.onTouchStart), e.addEventListener("mousedown", this.onMouseDown), e.addEventListener("mousemove", this.onHoverMove), e.addEventListener("touchmove", this.onAnyTouchMove), e.addEventListener("mouseup", this.onAnyUp), e.addEventListener("touchend", this.onAnyUp), e.addEventListener("touchcancel", this.onAnyUp), this._config.disableContextMenu) && e.addEventListener("contextmenu", this.onContextMenu)
            }
            disable() {
                var e = this._config.element;
                e && (e.removeEventListener("touchstart", this.onTouchStart), e.removeEventListener("mousedown", this.onMouseDown), e.removeEventListener("mousemove", this.onHoverMove), e.removeEventListener("touchmove", this.onAnyTouchMove), e.removeEventListener("mouseup", this.onAnyUp), e.removeEventListener("touchend", this.onAnyUp), e.removeEventListener("touchcancel", this.onAnyUp), this.removeTouchTargetListeners(), e.removeEventListener("mousemove", this.onMouseMove), this._config.disableContextMenu && e.removeEventListener("contextmenu", this.onContextMenu), this.pointers = {}, this.pointerArray = [])
            }
            removeTouchTargetListeners() {
                for (let e = 0; e < this._touchTargets.length; ++e) {
                    var t = this._touchTargets[e];
                    t.removeEventListener("touchmove", this.onTouchMove), t.removeEventListener("touchend", this.onTouchEnd), t.removeEventListener("touchcancel", this.onTouchCancel)
                }
                this._touchTargets.length = 0
            }
            fakeStart(e) {
                this.onTouchStart(e)
            }
            addTouchTarget(e) {
                -1 === this._touchTargets.indexOf(e) && (this._touchTargets.push(e), e.addEventListener("touchmove", this.onTouchMove), e.addEventListener("touchend", this.onTouchEnd), e.addEventListener("touchcancel", this.onTouchCancel))
            }
            allowButton(e) {
                return !this._config.ignoreRightButton || void 0 === e.button || 0 === e.button
            }
            onPointerDown(e, t, s) {
                this.pointers[e] && this.onPointerUp(e, s);
                var r = this._config.maxPointers || 5;
                return -1 < r && this.pointersLength >= r ? null : (r = this.createPointer(e, t, s), this.pointers[e] = r, this.pointerArray.push(r), this._config.dispatchIndividualEvents && this.signals.down.dispatch(r, this.signals.down), this._lastPointer = r, this.handleFocusLoss(e, t, s), r)
            }
            handleFocusLoss(e, t, s) {
                this._focusLost = !this._config.window.document.hasFocus(), this._focusLost && (this._config.window.addEventListener("focus", this.onFocusBack), this._config.window.document.removeEventListener("mousemove", this.onMouseMove), this._config.window.document.removeEventListener("mouseup", this.onMouseUp), this.onPointerUp(e, s))
            }
            onPointerMove(e, t, s) {
                var r, i, a = this.pointers[e];
                return a ? (r = (i = this.getLocalCoords(t))[0], i = i[1], a.dx = r - a.localX, a.dy = i - a.localY, a.offsetX = r - a.startX, a.offsetY = i - a.startY, a.localX = r, a.localY = i, a.originalEvent = s, a.pointerData = t, this._config.dispatchIndividualEvents && this.signals.move.dispatch(a, this.signals.move), this._lastPointer = a, this.handleFocusLoss(e, t, s), a) : null
            }
            onPointerUp(e, t) {
                var s, r = this.pointers[e];
                return r ? (-1 < (s = this.pointerArray.indexOf(r)) && this.pointerArray.splice(s, 1), delete this.pointers[e], r.originalEvent = t, this._config.dispatchIndividualEvents && this.signals.up.dispatch(r, this.signals.up), this._lastPointer = r) : null
            }
            createPointer(e, t, s) {
                var r = this.getLocalCoords(t);
                return new xt({
                    id: e,
                    localX: r[0],
                    localY: r[1],
                    originalEvent: s,
                    pointerData: t
                })
            }
            getLocalCoords(e) {
                var t = this._config.parent || this._config.element,
                    s = this._config.getBufferSize;
                return s ? (s = s(), Tt.getLocalCoordsInBuffer(e, t, s, this._localCoords)) : Tt.getLocalCoords(e, t, this._localCoords)
            }
            static getLocalCoordsInBuffer(e, t, s, r = []) {
                e = Tt.getLocalCoords(e, t, r);
                return e[0] = e[0] * s[0] / t.clientWidth, e[1] = e[1] * s[1] / t.clientHeight, e
            }
            static getLocalCoords(e, t, s = []) {
                var t = t.getBoundingClientRect(),
                    r = t.left + ee.U.getScrollX(),
                    t = t.top + ee.U.getScrollY();
                return s[0] = e.clientX - r, s[1] = e.clientY - t, s
            }
            get pointersLength() {
                return Object.keys(this.pointers).length
            }
            clonePointerArray() {
                var t = [];
                for (let e = 0; e < this.pointerArray.length; ++e) t.push(this.pointerArray[e].clone());
                return t
            }
            get config() {
                return this._config
            }
            get lastPointer() {
                return this._lastPointer
            }
            dispose() {
                this.disable()
            }
        }
        Tt.defaultConfig = {
            element: null,
            maxPointers: 5,
            dispatchIndividualEvents: !0,
            dispatchMultiEvents: !1,
            autoEnable: !0,
            updateMode: ie.IMMEDIATE,
            disableContextMenu: !1,
            ignoreRightButton: !1,
            getBufferSize: void 0,
            window: window
        };
        class wt extends bt {
            constructor(e) {
                super(e)
            }
            onChildMounted(e) {
                this._pointerDetector = new Tt({ ...this.props,
                    element: e,
                    parent: this.props.parent
                }), this.props.onDown && this._pointerDetector.signals.down.add(this.props.onDown), this.props.onMove && this._pointerDetector.signals.move.add(this.props.onMove), this.props.onUp && this._pointerDetector.signals.up.add(this.props.onUp)
            }
        }
        class Et extends u.Component {
            constructor(e) {
                super(e), this.onUpdate = e => {
                    e = this.validateCirclePos([e.localX, e.localY]), this.setState({
                        circlePos: e
                    }), e = this.getColorFromCirclePos(e);
                    this.props.onChange(e)
                }, this.state = {
                    circlePos: null
                }, this._canvas = u.createRef()
            }
            render() {
                this.drawCanvas();
                let [e, t] = this.getCirclePos();
                return this.state.circlePos && this.getColorFromCirclePos(this.state.circlePos) === this.props.value && ([e, t] = this.state.circlePos), u.createElement("div", {
                    className: "colorPickerGradient"
                }, u.createElement(wt, {
                    onDown: this.onUpdate,
                    onMove: this.onUpdate
                }, u.createElement("canvas", {
                    ref: this._canvas,
                    width: this.props.width,
                    height: this.props.height
                })), u.createElement("div", {
                    style: {
                        transform: `translate(${e}px, ${t}px) translate(-50%, -50%)`
                    },
                    className: "colorPickerCircle"
                }))
            }
            getColorFromCirclePos(e) {
                var t = this.getMax(),
                    s = m.I.getHueFromColor(this.props.value),
                    r = e[0] / t[0],
                    e = 1 - e[1] / t[1];
                return m.I.hsb2rgb(s, r, e)
            }
            getCirclePos() {
                var e = m.I.rgb2hsb(this.props.value),
                    t = e[1],
                    e = e[2],
                    t = this.props.width * t,
                    e = this.props.height * (1 - e);
                return this.validateCirclePos([t, e])
            }
            validateCirclePos(e) {
                var t = this.getMax();
                return e[0] = f.M.clamp(e[0], 0, t[0]), e[1] = f.M.clamp(e[1], 0, t[1]), e
            }
            getMax() {
                return [this.props.width - 1, this.props.height - 1]
            }
            drawCanvas() {
                var t = this._canvas.current;
                if (t) {
                    var s = m.I.getHueTopFromColor(this.props.value),
                        s = m.I.getCSSFromNumber(s);
                    this._ctx = this._ctx || t.getContext("2d");
                    let e = this._ctx.createLinearGradient(.5, 0, t.width - .5, 0);
                    e.addColorStop(0, "#ffffff"), e.addColorStop(1, s), this._ctx.fillStyle = e, this._ctx.fillRect(0, 0, t.width, t.height), (e = this._ctx.createLinearGradient(0, .5, 0, t.height - .5)).addColorStop(0, "rgba(0, 0, 0, 0)"), e.addColorStop(1, "rgba(0, 0, 0, 1)"), this._ctx.fillStyle = e, this._ctx.fillRect(0, 0, t.width, t.height)
                }
            }
        }
        Et.defaultProps = {
            width: 0,
            height: 0,
            value: 0,
            onChange: ft.emptyFunction
        };
        class Ct extends u.Component {
            constructor(e) {
                super(e), this._gradientColors = [16711680, 16776960, 65280, 65535, 255, 16711935, 16711680], this.onUpdate = e => {
                    var t, s;
                    this._canvas.current && (s = (t = Ct.circleRadius) - 1, t = Ct.canvasWidth - t, e = f.M.clamp(e.localX, s, t), s = this.getHueColor(e), console.log("hueColor", s), this.props.onChange(s))
                }, this.state = {}, this._canvas = u.createRef()
            }
            render() {
                this.updateCanvas();
                var e = this.getCirclePos();
                return u.createElement("div", {
                    className: "hueSlider"
                }, u.createElement(wt, {
                    onDown: this.onUpdate,
                    onMove: this.onUpdate
                }, u.createElement("canvas", {
                    ref: this._canvas,
                    width: Ct.canvasWidth,
                    height: 14
                })), u.createElement("div", {
                    style: {
                        transform: `translate(${e}px, 0px) translate(-50%, 0)`
                    },
                    className: "colorPickerCircle"
                }))
            }
            getHueColor(e) {
                var t = this._canvas.current,
                    s = Ct.circleRadius,
                    s = (e = f.M.clamp(e, s - 1, t.width - s - 1 + 1), t.getContext("2d").getImageData(e, 7, 1, 1).data);
                return m.I.rgb2hex(s[0], s[1], s[2])
            }
            getCirclePos() {
                var e = m.I.getHueFromColor(this.props.value),
                    t = Ct.circleRadius,
                    s = t;
                return e * (Ct.canvasWidth - t - s) + s
            }
            updateCanvas() {
                var e = this._canvas.current;
                if (e) {
                    const t = Ct.circleRadius,
                        s = e.getContext("2d"),
                        r = s.createLinearGradient(0, 0, e.width, 0),
                        i = this._gradientColors;
                    for (let e = 0; e < i.length; ++e) {
                        const t = m.I.getCSSFromNumber(i[e]),
                            s = e / (i.length - 1);
                        r.addColorStop(s, t)
                    }
                    s.fillStyle = r, s.fillRect(t, 0, e.width - 2 * t, e.height), s.fillStyle = m.I.getCSSFromNumber(i[0]), s.fillRect(0, 0, t, e.height), s.fillStyle = m.I.getCSSFromNumber(i[0]), s.fillRect(e.width - t, 0, t, e.height)
                }
            }
        }
        Ct.defaultProps = {
            value: 0
        }, Ct.circleRadius = 7, Ct.canvasWidth = 190;
        class yt {
            static translate(e, t = 0, s = 0) {
                this.transform(e, `translate(${t}px, ${s}px)`)
            }
            static transform(e, t) {
                e.style.transform = t, e.style.webkitTransform = t
            }
            static getTransform(e) {
                e = getComputedStyle(e);
                let t = e.transform || e.webkitTransform;
                return t = "none" === t ? "" : t
            }
            static fitToScreen(e, t, s) {
                var r = e.getBoundingClientRect(),
                    r = (t = t || [r.left, r.top], (s = s || window).document.body);
                let i = t[0],
                    a = t[1];
                var s = e.offsetWidth,
                    t = e.offsetHeight,
                    n = r.clientWidth;
                a + t > r.clientHeight && (a -= t), i + s > n && (i = n - s), this.translate(e, i, a)
            }
            static scrollIntoViewIfNeeded(e) {
                e && (e.scrollIntoViewIfNeeded ? e.scrollIntoViewIfNeeded() : e.scrollIntoView())
            }
            static detach(e) {
                return !(null == e || !e.parentNode || (e.parentNode.removeChild(e), 0))
            }
            static up(e, t) {
                return t(e) ? e : e.parentNode instanceof HTMLElement ? this.up(e.parentNode, t) : null
            }
            static hasSelection(e) {
                return (e.selectionEnd || 0) - (e.selectionStart || 0) != 0
            }
            static blur() {
                var e, t;
                null != (t = null == (e = document.activeElement) ? void 0 : e.blur) && t.call(e)
            }
            static isInput(e) {
                return !!e && ("input" === (e = e.nodeName.toLowerCase()) || "textarea" === e || 0 < document.querySelectorAll(":focus").length)
            }
        }
        class At extends u.Component {
            constructor() {
                super(...arguments), this._input = u.createRef(), this.onInput = e => {
                    var t, s;
                    null != (s = (t = this.props).onInput) && s.call(t, e.currentTarget.value)
                }, this.onBlur = e => {
                    var t, s;
                    null != (s = (t = this.props).onChange) && s.call(t, e.currentTarget.value)
                }, this.onKeyDown = e => {
                    var t, s;
                    "Enter" === e.key && null != (t = (s = this.props).onChange) && t.call(s, e.currentTarget.value), null != (s = (t = this.props).onKeyDown) && s.call(t, e)
                }, this.onMouseUp = e => {
                    e = e.currentTarget;
                    yt.hasSelection(e) || e.select()
                }
            }
            componentDidMount() {
                var e;
                this.props.autoFocus && (e = this._input.current) && (e.focus(), e.select())
            }
            render() {
                var {
                    label: e,
                    value: t,
                    type: s,
                    placeholder: r,
                    maxLength: i,
                    spellcheck: a,
                    className: n,
                    disabled: o
                } = this.props, n = n ? " " + n : "";
                return u.createElement("label", {
                    className: "TextField" + n
                }, e && u.createElement("span", {
                    className: "label"
                }, e), u.createElement("input", {
                    ref: this._input,
                    type: s,
                    value: t,
                    placeholder: r,
                    onChange: this.onInput,
                    onBlur: this.onBlur,
                    maxLength: i,
                    onKeyDown: this.onKeyDown,
                    spellCheck: a,
                    onMouseUp: this.onMouseUp,
                    disabled: o
                }))
            }
        }
        At.defaultProps = {
            type: "",
            value: "",
            placeholder: ""
        };
        class Mt extends u.Component {
            constructor(e) {
                super(e), this.onInput = e => {
                    this.setState({
                        stringValue: e
                    })
                }, this.onKeyDown = e => {
                    var t, s;
                    "Enter" === e.key ? null != (t = (s = this.props).onEnter) && t.call(s) : "Escape" === e.key && null != (s = (t = this.props).onEscape) && s.call(t)
                }, this.onChange = e => {
                    this.triggerChange(e)
                }, this.state = {
                    stringValue: this.getStringValue(e.value)
                }
            }
            componentWillReceiveProps(e) {
                f.M.isValidNumber(e.value) && this.setState({
                    stringValue: this.getStringValue(e.value)
                })
            }
            triggerChange(e) {
                this.props.onChange && -1 < (e = this.parseColor(e)) && this.props.onChange(e)
            }
            getStringValue(e) {
                return m.I.getHexStringFromNumber(e)
            }
            parseColor(e) {
                e = parseInt(e, 16);
                return 0 < e || 0 === e ? e : -1
            }
            render() {
                var e = this.state.stringValue;
                return u.createElement("div", {
                    className: "colorTextInput"
                }, u.createElement("span", {
                    className: "hashmark"
                }, "#"), u.createElement(At, {
                    value: e,
                    maxLength: 6,
                    onChange: this.onChange,
                    onInput: this.onInput,
                    onKeyDown: this.onKeyDown,
                    autoFocus: !0,
                    spellcheck: !1
                }))
            }
        }
        Mt.defaultProps = {
            value: 0,
            onChange: () => {}
        };
        class Rt extends u.Component {
            constructor() {
                super(...arguments), this.onClick = e => {
                    this.props.onClick && this.props.onClick(e, this)
                }
            }
            render() {
                return u.createElement("button", {
                    onClick: this.onClick,
                    disabled: this.props.disabled
                }, this.props.label)
            }
        }
        class St extends u.Component {
            constructor(e) {
                super(e), this._node = u.createRef(), this.onColorPickerGradientChange = e => {
                    this.setColor(e)
                }, this.onHueChange = e => {
                    var t = this.props.value,
                        t = m.I.rgb2hsb(t),
                        s = t[1],
                        t = t[2],
                        e = m.I.getHueFromColor(e),
                        e = m.I.hsb2rgb(e, s, t);
                    this.setColor(e)
                }, this.onPaletteChange = e => {
                    this.setColor(e)
                }, this.onColorTextChange = e => {
                    this.setColor(e)
                }, this.onCancel = () => {
                    this.props.onChange(this.state.openedValue), this.props.onClose(!0)
                }, this.onApply = () => {
                    this.props.onClose(!1)
                }, this.onEnter = () => {
                    this.props.onClose(!1)
                }, this.onEscape = () => {
                    this.props.onClose(!0)
                }, this.state = {
                    value: this.props.value,
                    openedValue: this.props.value,
                    x: 0,
                    y: 0
                }
            }
            componentWillReceiveProps(e) {
                this.setState({
                    value: e.value
                })
            }
            componentDidMount() {
                this.setPosition(), this.addListeners()
            }
            componentWillUnmount() {
                this.removeListeners()
            }
            addListeners() {}
            removeListeners() {}
            setPosition() {
                var s = this._node.current,
                    r = this.props.position;
                if (s) {
                    s = s.getBoundingClientRect();
                    let e = r[0] + 2,
                        t = (e + s.width > window.innerWidth && (e = r[0] + r[2] - s.width), r[1] + r[3] + 2);
                    t + s.height > window.innerHeight && (t = r[1] - s.height), this.setState({
                        x: e,
                        y: t
                    })
                }
            }
            setColor(e) {
                this.state.value !== e && (this.setState({
                    value: e
                }), this.props.onChange(e))
            }
            render() {
                var {
                    value: e,
                    x: t,
                    y: s
                } = this.state, r = m.I.getHueTopFromColor(e);
                return u.createElement("div", {
                    ref: this._node,
                    className: "ColorPicker hbox",
                    style: {
                        left: t + "px",
                        top: s + "px"
                    }
                }, u.createElement("div", {
                    className: "vbox"
                }, u.createElement(Et, {
                    value: e,
                    onChange: this.onColorPickerGradientChange,
                    width: 188,
                    height: 150
                }), u.createElement(Ct, {
                    value: r,
                    onChange: this.onHueChange
                }), u.createElement(Mt, {
                    value: e,
                    onChange: this.onColorTextChange,
                    onEnter: this.onEnter,
                    onEscape: this.onEscape
                })), u.createElement("div", {
                    className: "vbox"
                }, u.createElement(vt, {
                    value: e,
                    onChange: this.onPaletteChange
                }), u.createElement("div", {
                    className: "hbox buttons"
                }, u.createElement(Rt, {
                    label: "Cancel",
                    onClick: this.onCancel
                }), u.createElement(Rt, {
                    label: "Ok",
                    onClick: this.onApply
                }))))
            }
        }
        St.defaultProps = {
            value: 16777215,
            onChange: ft.emptyFunction,
            onClose: ft.emptyFunction
        };
        class y {
            static listen(e, t) {
                e && y._detectors.push(new y(e, t))
            }
            static listenPopup(e, t) {
                e && y._detectors.push(new y(e, t, !1))
            }
            static stopListen(e, t) {
                for (const s of y._detectors) s._element !== e || t && s._onFocusLoss !== t || s.dispose()
            }
            constructor(e, t, s = !0) {
                this._onFocusLoss = null, this.onWindowMouseDown = e => {
                    this._element.contains(e.target) || this.loseFocus(e)
                }, this.onWindowBlur = e => {
                    this.loseFocus(e)
                }, this._element = e, this._onFocusLoss = t, this._windowTarget = e.ownerDocument.defaultView || window, this._listenBlur = null == s || s, this.addListeners()
            }
            addListeners() {
                this._windowTarget.addEventListener("mousedown", this.onWindowMouseDown), this._windowTarget.addEventListener("touchstart", this.onWindowMouseDown), this._listenBlur && this._windowTarget.addEventListener("blur", this.onWindowBlur)
            }
            removeListeners() {
                this._windowTarget.removeEventListener("mousedown", this.onWindowMouseDown), this._windowTarget.removeEventListener("touchstart", this.onWindowMouseDown), this._listenBlur && this._windowTarget.removeEventListener("blur", this.onWindowBlur)
            }
            loseFocus(e) {
                var t;
                !1 !== (null == (t = this._onFocusLoss) ? void 0 : t.call(this, e)) && (this.removeListeners(), this._onFocusLoss = null)
            }
            dispose() {
                this.removeListeners()
            }
        }
        y._detectors = [];
        class Nt extends u.Component {
            constructor(e) {
                super(e), this._element = u.createRef(), this.onFocusLoss = () => {
                    this.close()
                }, this.onIconClick = e => {
                    this.setState(e => {
                        const t = !e.open,
                            s = { ...e,
                                open: t
                            };
                        if (t) {
                            const e = this._element.current;
                            if (e) {
                                const t = e.getBoundingClientRect();
                                s.pickerPosition = [t.x, t.y, t.width, t.height]
                            }
                        }
                        return s
                    })
                }, this.onColorPickerChange = e => {
                    this.props.onChange(e)
                }, this.onColorPickerClose = e => {
                    this.close()
                }, this.state = {
                    open: !1,
                    pickerPosition: [0, 0]
                }
            }
            handleFocus() {
                var e = this._element.current;
                e && (this.state.open ? y.listen(e, this.onFocusLoss) : y.stopListen(e, this.onFocusLoss))
            }
            close() {
                this.setState({
                    open: !1
                })
            }
            render() {
                var {
                    open: e,
                    pickerPosition: t
                } = this.state, s = this.props.value, r = m.I.getCSSFromNumber(s);
                return this.handleFocus(), u.createElement("div", {
                    ref: this._element,
                    title: this.props.title || "",
                    className: h("ColorInput", {
                        disabled: !!this.props.disabled
                    })
                }, u.createElement("div", {
                    className: "colorIcon",
                    style: {
                        background: r
                    },
                    onClick: this.onIconClick
                }), e && u.createElement(St, {
                    value: s,
                    onChange: this.onColorPickerChange,
                    onClose: this.onColorPickerClose,
                    position: t
                }))
            }
        }
        Nt.defaultProps = {
            value: 16777215,
            onChange: ft.emptyFunction
        };
        var te = c(4522),
            v = c(7068);
        class It extends u.Component {
            render() {
                var e = this.props["texture"];
                return u.createElement("div", {
                    className: "TextureButtons"
                }, u.createElement("div", {
                    onClick: this.props.onDownload,
                    className: h("btn", {
                        disabled: !e
                    }),
                    title: "Download"
                }), u.createElement("div", {
                    onClick: this.props.onUpload,
                    className: "btn rotated",
                    title: "Upload"
                }), u.createElement("div", {
                    className: "flex_1"
                }), u.createElement("div", {
                    onClick: this.props.onRemove,
                    className: h("btn remove", {
                        disabled: !e
                    }),
                    title: "Remove"
                }))
            }
        }
        class Pt {
            static hasFiles(e) {
                let t = !1;
                return t = -1 < ((null == (e = e.dataTransfer) ? void 0 : e.types) || []).indexOf("Files") ? !0 : t
            }
            constructor(e) {
                this._counter = 0, this._dropping = !1, this.preventDefault = e => {
                    e.preventDefault()
                }, this.onDragEnter = e => {
                    e.stopPropagation(), e.preventDefault(), Pt.hasFiles(e) && (this._counter++, this.onDroppingChange(!0))
                }, this.onDragLeave = e => {
                    e.stopPropagation(), Pt.hasFiles(e) && (this._counter--, 0 === this._counter) && this.onDroppingChange(!1)
                }, this.onDragOverHandler = e => {
                    this.onDragOver(e)
                }, this.onDragEnd = e => {
                    this.onDroppingChange(!1)
                }, this.onDropHandler = e => {
                    this.onDrop(e)
                }, !(this.onDroppingChange = e => {
                    var t;
                    this._dropping !== e && (this._dropping = e, this._dropping ? this.showHighlight() : this.hideHighlight(), null != (t = (e = this._config).onDroppingChange)) && t.call(e, this._dropping)
                }) !== (this._config = e).autoEnable && this.enable()
            }
            enable() {
                var e = this._config.targetElement;
                e.addEventListener("dragenter", this.onDragEnter), e.addEventListener("dragleave", this.onDragLeave), e.addEventListener("dragover", this.onDragOverHandler), e.addEventListener("drop", this.onDropHandler), e.addEventListener("dragend", this.onDragEnd), document.addEventListener("dragover", this.preventDefault), document.addEventListener("drop", this.preventDefault)
            }
            disable() {
                var e = this._config.targetElement;
                e.removeEventListener("dragenter", this.onDragEnter), e.removeEventListener("dragleave", this.onDragLeave), e.removeEventListener("dragover", this.onDragOverHandler), e.removeEventListener("drop", this.onDropHandler), e.removeEventListener("dragend", this.onDragEnd), document.removeEventListener("dragover", this.preventDefault), document.removeEventListener("drop", this.preventDefault)
            }
            onDragOver(e) {
                e.preventDefault(), e.stopPropagation(), this.checkFiles(e) ? (e.dataTransfer && (e.dataTransfer.dropEffect = "move"), this.onDroppingChange(!0)) : (e.dataTransfer && (e.dataTransfer.dropEffect = "none"), this.onDroppingChange(!1))
            }
            checkFiles(e) {
                return !!this._config.onDragOver(e)
            }
            onDrop(e) {
                e.stopPropagation(), e.preventDefault(), this._counter = 0, this.onDroppingChange(!1), this._config.onDrop && this._config.onDrop(e)
            }
            showHighlight() {
                this._config.targetElement.classList.add(Pt.droppingCls)
            }
            hideHighlight() {
                this._config.targetElement.classList.remove(Pt.droppingCls)
            }
        }
        Pt.droppingCls = "dropping_files";
        class Ft extends bt {
            constructor(e) {
                super(e)
            }
            onChildMounted(e) {
                this._dropper = new Pt({
                    targetElement: e,
                    onDragOver: this.props.onDragOver,
                    onDrop: this.props.onDrop,
                    onDroppingChange: this.props.onDroppingChange
                })
            }
        }
        class Lt {
            constructor() {
                this._result = []
            }
            async load(t) {
                this._result = [];
                var s = [];
                for (let e = 0; e < t.length; e++) {
                    var r = t[e].webkitGetAsEntry();
                    r && s.push(r)
                }
                for (var e = []; 0 < s.length;) {
                    const t = s.shift();
                    null != t && t.isFile ? e.push(this.addFileEntry(t)) : null != t && t.isDirectory && s.push(...await this.readAllDirectoryEntries(t.createReader()))
                }
                return await Promise.all(e), this._result
            }
            addFileEntry(r) {
                return new Promise(s => {
                    r.file(e => {
                        var t = r.fullPath.slice(1),
                            t = new File([e], t, {
                                type: e.type
                            });
                        this._result.push(t), s()
                    })
                })
            }
            async readAllDirectoryEntries(e) {
                var t = [];
                let s = await this.readEntries(e);
                for (; 0 < s.length;) t.push(...s), s = await this.readEntries(e);
                return t
            }
            async readEntries(s) {
                try {
                    return await new Promise((e, t) => {
                        s.readEntries(e, t)
                    })
                } catch (s) {
                    console.log(s)
                }
            }
        }
        class Dt {
            constructor(e) {
                this._width = 0, this._height = 0, this._internalFormat = -1, this._ctx = e.context, this._buffer = this._ctx.createRenderBuffer()
            }
            storage(e, t, s) {
                var r = this._ctx.gl;
                this._width = t, this._height = s, this._internalFormat = e, this.bind(), r.renderbufferStorage(r.RENDERBUFFER, e, t, s)
            }
            setSize(e, t) {
                this._width === e && this._height === t || this.storage(this._internalFormat, e, t)
            }
            bind() {
                var e = this._ctx.gl;
                e.bindRenderbuffer(e.RENDERBUFFER, this._buffer)
            }
            unbind() {
                var e = this._ctx.gl;
                e.bindRenderbuffer(e.RENDERBUFFER, null)
            }
            getBuffer() {
                return this._buffer
            }
            get width() {
                return this._width
            }
            get height() {
                return this._height
            }
            dispose() {
                this._ctx.gl.deleteRenderbuffer(this._buffer)
            }
        }
        class Ot {
            constructor(e) {
                this._framebuffer = null, this._attachments = {}, this._clearMask = 0, this._config = e, this._ctx = this._config.context, this._framebuffer = this._ctx.createFramebuffer(), this.bind(), this.initAttachments(), this.checkCompleteness(), this._clearMask = this.getClearMask(), this.unbind()
            }
            getSize() {
                var e = this._config,
                    e = e.color || e.depth;
                return [e.width, e.height]
            }
            initAttachments() {
                var e = this._config,
                    t = this._ctx.gl;
                this._attachments = {}, e.color && this.addAttachment(t.COLOR_ATTACHMENT0, e.color), e.depth && this.addAttachment(t.DEPTH_ATTACHMENT, e.depth), e.stencil && this.addAttachment(t.STENCIL_ATTACHMENT, e.stencil)
            }
            addAttachment(e, t) {
                var s = this._ctx.gl;
                if (t instanceof I) s.framebufferTexture2D(s.FRAMEBUFFER, e, t.getTarget(), t.getTexture(), 0);
                else {
                    if (!(t instanceof Dt)) return void console.error("Error! Unknown attachment type!");
                    s.framebufferRenderbuffer(s.FRAMEBUFFER, e, s.RENDERBUFFER, t.getBuffer())
                }
                this._attachments[e] = t
            }
            getAttachment(e) {
                return this._attachments[e]
            }
            getClearMask() {
                var e = this._ctx.gl;
                let t = 0;
                return this._attachments[e.COLOR_ATTACHMENT0] && (t |= e.COLOR_BUFFER_BIT), this._attachments[e.DEPTH_ATTACHMENT] && (t |= e.DEPTH_BUFFER_BIT), this._attachments[e.STENCIL_ATTACHMENT] && (t |= e.STENCIL_BUFFER_BIT), t
            }
            checkCompleteness() {
                this.bind();
                var e = this._ctx.gl,
                    t = e.checkFramebufferStatus(e.FRAMEBUFFER);
                if (t === e.FRAMEBUFFER_COMPLETE) return !0;
                let s = "";
                switch (t) {
                    case e.FRAMEBUFFER_UNSUPPORTED:
                        s = "The combination of internal formats of the attached images violates an implementation-dependent set of restrictions.";
                        break;
                    case e.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
                        s = "Some of the framebuffer attachment points are framebuffer incomplete.";
                        break;
                    case e.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
                        s = "Not all attached images have the same width and height";
                        break;
                    case e.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
                        s = "There are no images attached to the framebuffer.";
                        break;
                    default:
                        s = "Unknown error."
                }
                return s = "Texture: rendering to this texture is not supported (framebuffer is not texture complete)!\nProblem: " + s, console.warn(s), !1
            }
            clear(e, t = !0) {
                this.bind(), this._ctx.clear(e, this._clearMask, t)
            }
            setAsRenderTarget() {
                this.bind(), this.setViewport()
            }
            setViewport() {
                this.bind();
                var [e, t] = this.getSize();
                this._ctx.viewport([0, 0, e, t])
            }
            bind() {
                this._ctx.bindFramebuffer(this._framebuffer)
            }
            unbind() {
                this._ctx.bindFramebuffer(null)
            }
            dispose(e = !0) {
                var t;
                this._framebuffer && (t = this._ctx.gl, e && (this.bind(), this.disposeAttachment(t.COLOR_ATTACHMENT0), this.disposeAttachment(t.DEPTH_ATTACHMENT), this.disposeAttachment(t.STENCIL_ATTACHMENT)), this._ctx.deleteFramebuffer(this._framebuffer), this._framebuffer = null, this._attachments = {})
            }
            disposeAttachment(e) {
                e = this.detachAttachment(e);
                e && e.dispose()
            }
            detachAttachment(e) {
                var t = this._ctx.gl,
                    s = this._attachments[e];
                return s ? (s instanceof I ? t.framebufferTexture2D(t.FRAMEBUFFER, e, s.getTarget(), null, 0) : t.framebufferRenderbuffer(t.FRAMEBUFFER, e, t.RENDERBUFFER, null), this._attachments[e] = null, s) : null
            }
            getFramebuffer() {
                return this._framebuffer
            }
        }
        var se = c(2841);
        class I {
            static isTexture(e) {
                return e instanceof I
            }
            static isImageSource(e) {
                return !(null == e || !e.nodeName)
            }
            static isNPOT(e, t) {
                return !f.M.isPowerOfTwo(e) || !f.M.isPowerOfTwo(t)
            }
            constructor(e) {
                var t;
                this.signals = {
                    sourceChange: n.M.create()
                }, this.name = "", this.id = ++I.highestId, this._sourceUploaded = !1, this._width = 0, this._height = 0, this._minFilter = 0, this._magFilter = 0, this._wrapS = 0, this._wrapT = 0, this._anisotropy = 0, this._framebuffer = null, this._premultipliedAlpha = !1, this._config = J.g.mergeConfig(I.defaultConfig, e), this._ctx = e.context, this._texture = this._ctx.createTexture(), this._target = e.target || I.defaultConfig.target || _.g.TEXTURE_2D, this._internalformat = e.internalformat || _.g.RGBA, this._format = e.format || this._internalformat, [this._type, this._floatType] = this.initType(), this._premultipliedAlpha = null != (t = this._config.premultipliedAlpha) ? t : this._ctx.premultipliedAlpha, this.initSource(), e.name && (this.name = e.name)
            }
            initSource() {
                var e = this._config.source;
                if ((this._source = e) instanceof HTMLImageElement && !e.complete) throw new Error("Source has to be loaded before creating texture!");
                this.onSourceLoaded()
            }
            onSourceLoaded() {
                var e, t, s, r = this._config;
                I.isImageSource(this._source) && (e = this._ctx.getParameter(this._ctx.gl.MAX_TEXTURE_SIZE), [t, s] = v.O.getSourceSize(this._source), e < t || e < s) && (this._source instanceof HTMLImageElement ? (t = Math.min(this._source.width, e), s = Math.min(this._source.height, e), this._source = se.P.resizeImage(this._source, t, s)) : console.warn("Unimplemented! Texture will not load.")), this.uploadSource(this._source || null, r.width, r.height)
            }
            initType() {
                var e = this._ctx.gl;
                let t = this._config.type || e.UNSIGNED_BYTE,
                    s = t,
                    r = 0;
                if (t !== e.FLOAT && t !== I.TYPE_FLOAT || (this.getFloatExtension(I.TYPE_FLOAT) ? (this._floatType = I.TYPE_FLOAT, s = e.FLOAT) : t = I.TYPE_HALF_FLOAT), t === I.TYPE_HALF_FLOAT) {
                    const t = this.getFloatExtension(I.TYPE_HALF_FLOAT);
                    s = t ? (r = I.TYPE_HALF_FLOAT, t.HALF_FLOAT_OES) : e.UNSIGNED_BYTE
                }
                return this._floatType = r, this._type = s, [this._type, this._floatType]
            }
            getFloatExtension(e) {
                return e === I.TYPE_FLOAT ? this._ctx.getExtension("OES_texture_float") : e === I.TYPE_HALF_FLOAT ? this._ctx.getExtension("OES_texture_half_float") : null
            }
            getFloatLinearExtension(e) {
                return e === I.TYPE_FLOAT ? this._ctx.getExtension("OES_texture_float_linear") : e === I.TYPE_HALF_FLOAT ? this._ctx.getExtension("OES_texture_half_float_linear") : null
            }
            initTexParameters() {
                var e = this._config,
                    t = this._ctx.gl;
                let s = this._source;
                var r = this._floatType;
                let i = this._magFilter || e.magFilter || (r ? t.NEAREST : t.LINEAR),
                    a = this._minFilter || e.minFilter || (r ? t.NEAREST : t.LINEAR);
                if (r) {
                    let e = !1;
                    i === t.NEAREST && a === t.NEAREST || (e = this.getFloatLinearExtension(r)), i === t.NEAREST || e || (i = t.NEAREST), a === t.NEAREST || e || (a = t.NEAREST)
                }
                r = I.isMipmapFilter(a);
                let n = e.wrapS || t.CLAMP_TO_EDGE,
                    o = e.wrapT || t.CLAMP_TO_EDGE;
                this._ctx.is2 || !this.isNPOT || !r && n === t.CLAMP_TO_EDGE && o === t.CLAMP_TO_EDGE || (console.log("Warning! NPOT textures are not supported for min filter:" + a + "and wrap modes: " + n + ", " + o + "!"), n === t.CLAMP_TO_EDGE && o === t.CLAMP_TO_EDGE || (s instanceof HTMLImageElement ? (s = se.P.resizeToClosestPOT(s), this.updateSize(s.width, s.height)) : (n = t.CLAMP_TO_EDGE, o = t.CLAMP_TO_EDGE)), this.isNPOT && r && (a = t.LINEAR)), this.magFilter = i, this.minFilter = a, this.wrapS = n, this.wrapT = o;
                e = this._config.anisotropy;
                return 0 <= e && this.setAnisotropy(e), s
            }
            set minFilter(e) {
                this.bind();
                var t = this._ctx.gl;
                void 0 !== e && e !== this._minFilter && (!this._ctx.is2 && this.isNPOT && I.isMipmapFilter(e) && (e = t.LINEAR), t.texParameteri(this._target, t.TEXTURE_MIN_FILTER, e), this._minFilter = e), this._config.generateMipmap && this.generateMipmap()
            }
            get minFilter() {
                return this._minFilter
            }
            set magFilter(e) {
                this.bind();
                var t = this._ctx.gl;
                void 0 !== e && e !== this._magFilter && (t.texParameteri(this._target, t.TEXTURE_MAG_FILTER, e), this._magFilter = e)
            }
            get magFilter() {
                return this._magFilter
            }
            static isMipmapFilter(e) {
                return e === _.g.LINEAR_MIPMAP_LINEAR || e === _.g.LINEAR_MIPMAP_NEAREST || e === _.g.NEAREST_MIPMAP_LINEAR || e === _.g.NEAREST_MIPMAP_NEAREST
            }
            generateMipmap(e = !0) {
                if (this._sourceUploaded && (!e || I.isMipmapFilter(this._minFilter)) && (this._ctx.is2 || !this.isNPOT)) {
                    const e = this._ctx.gl;
                    this.bind(), e.generateMipmap(this._target)
                }
            }
            set wrapS(e) {
                this.bind();
                var t = this._ctx.gl;
                void 0 !== e && e !== this._wrapS && (t.texParameteri(this._target, t.TEXTURE_WRAP_S, e), this._wrapS = e)
            }
            get wrapS() {
                return this._wrapS
            }
            set wrapT(e) {
                this.bind();
                var t = this._ctx.gl;
                void 0 !== e && e !== this._wrapT && (t.texParameteri(this._target, t.TEXTURE_WRAP_T, e), this._wrapT = e)
            }
            get wrapT() {
                return this._wrapT
            }
            setAnisotropy(e) {
                var t, s;
                this.bind(), this._anisotropy !== e && (t = this._ctx.getExtension("EXT_texture_filter_anisotropic")) && (s = this._ctx.getParameter(t.MAX_TEXTURE_MAX_ANISOTROPY_EXT), this._ctx.gl.texParameterf(this._target, t.TEXTURE_MAX_ANISOTROPY_EXT, e = s < e ? s : e), this._anisotropy = e)
            }
            setSize(e, t) {
                this.uploadSource(null, e, t)
            }
            uploadSource(e, t, s, r, i, a) {
                var n = this._ctx.gl;
                this._source = e, r = r || this._target, a = null != a ? a : this._premultipliedAlpha, this.bind(); {
                    const e = this._source;
                    t = t || (e ? v.O.getSourceSize(e)[0] : 1), s = s || (e ? v.O.getSourceSize(e)[1] : 1), this.updateSize(t, s)
                }
                this._source = this.initTexParameters(), this._ctx.pixelStore.setValue(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL, a);
                s = null != i ? i : this._config.mipLevel;
                if (I.isImageSource(this._source)) {
                    const e = null != (a = this._config.flipY) ? a : I.defaultConfig.flipY,
                        t = this._ctx.pixelStore.getValue(n.UNPACK_FLIP_Y_WEBGL);
                    this._ctx.pixelStore.setValue(n.UNPACK_FLIP_Y_WEBGL, e), n.texImage2D(r, s, this._internalformat, this._format, this._type, this._source), this._ctx.pixelStore.setValue(n.UNPACK_FLIP_Y_WEBGL, t)
                } else {
                    const e = this._source || null;
                    this._ctx.pixelStore.setValue(n.UNPACK_FLIP_Y_WEBGL, !1), n.texImage2D(r, s, this._internalformat, this._width, this._height, 0, this._format, this._type, e)
                }
                this._sourceUploaded = !0, void 0 === i && this._config.generateMipmap && this.generateMipmap(), this.signals.sourceChange.dispatch(this)
            }
            updateSize(e, t) {
                this._width = e, this._height = t
            }
            get isNPOT() {
                return I.isNPOT(this._width, this._height)
            }
            bind() {
                return this._ctx.bindTexture(this)
            }
            bindTo(e, t) {
                this._ctx.bindTextureTo(this, e, t)
            }
            bindToActiveUnit() {
                this.bindTo(this._ctx.getActiveTextureUnit())
            }
            initFramebuffer(t = !1) {
                var s = this._ctx.gl;
                if (!this._framebuffer) {
                    let e;
                    t && (e = new Dt({
                        context: this._ctx
                    })).storage(s.DEPTH_COMPONENT16, this.width, this.height), this._framebuffer = new Ot({
                        context: this._ctx,
                        color: this,
                        depth: e
                    })
                }
                t = this._framebuffer.getAttachment(s.DEPTH_ATTACHMENT);
                return t && t.setSize(this.width, this.height), this._framebuffer
            }
            dispose() {
                var e;
                this._texture && (this._texture = null, (e = this._framebuffer) && (this._framebuffer = null, e.dispose(!0)), this._ctx.deleteTexture(this))
            }
            clone(e) {
                return new I({ ...this._config,
                    source: void 0,
                    ...e
                })
            }
            getTarget() {
                return this._target
            }
            getTexture() {
                return this._texture
            }
            get resource() {
                return this
            }
            get source() {
                return this._source
            }
            get width() {
                return this._width
            }
            get height() {
                return this._height
            }
            get context() {
                return this._ctx
            }
        }
        I.TYPE_FLOAT = -1, I.TYPE_HALF_FLOAT = -2, I.defaultConfig = {
            target: _.g.TEXTURE_2D,
            mipLevel: 0,
            flipY: !1,
            wrapS: _.g.CLAMP_TO_EDGE,
            wrapT: _.g.CLAMP_TO_EDGE,
            minFilter: _.g.LINEAR,
            magFilter: _.g.LINEAR,
            anisotropy: 0,
            type: _.g.UNSIGNED_BYTE,
            format: _.g.RGBA,
            internalformat: _.g.RGBA,
            generateMipmap: !0,
            premultipliedAlpha: void 0
        }, I.highestId = 0;
        class Bt {
            constructor(e, t, s, r, i, a) {
                if (this._rectangle = new d.A, this._parent = null, this._adapter = e, this.i = r, this.j = i, this._parent = a, this._oRect = s.clone(), this._rectangleFull = s, this.updateRectangle(), t instanceof HTMLImageElement || t instanceof HTMLCanvasElement) this._texture = this.setTextureFromImage(t);
                else if (t instanceof I) this._texture = t;
                else {
                    const e = this.initMinFilterAndSize();
                    this._texture = new I({
                        context: this._adapter.context,
                        source: null,
                        width: this._rectangleFull.width,
                        height: this._rectangleFull.height,
                        minFilter: e,
                        magFilter: null == (r = this._parent) ? void 0 : r.magFilter
                    })
                }
                this.updateRectangle()
            }
            onParentChange() {
                this.updateRectangle()
            }
            set parent(e) {
                this._parent = e, this.updateRectangle()
            }
            get oRect() {
                return this._oRect
            }
            updateRectangle() {
                var e = this._oRect,
                    t = this._parent;
                let s = e.width,
                    r = e.height,
                    i = [1, 1],
                    a = [0, 0];
                t && (e.right > t.width && (s = t.width - e.left), e.top > t.height && (r = t.height - e.bottom), i = t.scale, a = t.pos), this._rectangle = d.A.createFromEdges(a[0] + e.left * i[0], a[0] + (e.left + s) * i[0], a[1] + e.bottom * i[1], a[1] + (e.bottom + r) * i[1]), this._rectangleFull = d.A.createFromEdges(a[0] + e.left * i[0], a[0] + e.right * i[0], a[1] + e.bottom * i[1], a[1] + e.top * i[1])
            }
            initMinFilterAndSize() {
                var e, t = (null == (e = this._parent) ? void 0 : e.minFilter) || _.g.LINEAR_MIPMAP_LINEAR;
                if (I.isMipmapFilter(t)) {
                    const e = this._rectangleFull.width,
                        s = this._rectangleFull.height;
                    return f.M.isPowerOfTwo(e) && f.M.isPowerOfTwo(s) ? t : _.g.LINEAR
                }
                return t
            }
            sliceImage(e) {
                if (!Bt.canvas) {
                    Bt.canvas = document.createElement("canvas");
                    const e = Bt.canvas.getContext("2d");
                    if (!e) throw new Error("Could not get 2d context from canvas!");
                    Bt.ctx = e
                }
                var t = Bt.canvas,
                    s = Bt.ctx,
                    r = (t.width = this.width, t.height = this.height, this._rectangle.width),
                    i = this._rectangle.height;
                let a = 0;
                var n = this._rectangleFull.left;
                let o = this._rectangleFull.top;
                return i < this._rectangleFull.height && (a = this._rectangleFull.height - i, o = e.height), o = e.height - o, s.drawImage(e, n, o, r, i, 0, a, r, i), t
            }
            setTextureFromImage(e) {
                var t = this.initMinFilterAndSize(),
                    e = this.sliceImage(e);
                return this._texture = new I({
                    context: this._adapter.context,
                    source: e,
                    internalformat: null != (e = this._parent) && e.transparent ? _.g.RGBA : _.g.RGB,
                    format: void 0,
                    minFilter: t,
                    magFilter: null == (e = this._parent) ? void 0 : e.magFilter,
                    flipY: !0
                }), this._texture
            }
            clone(e = !0) {
                var t = new I({
                        context: this._adapter.context,
                        source: null,
                        width: this.texture.width,
                        height: this.texture.height,
                        magFilter: this.texture.magFilter,
                        minFilter: this.texture.minFilter
                    }),
                    t = new Bt(this._adapter, t, this.rectangle.clone(), this.i, this.j, this._parent || null);
                return e && console.log("Error to be implemented!"), t
            }
            fillEmptySpace(e) {
                var t, s;
                this._rectangle.width === this._rectangleFull.width && this._rectangle.height === this._rectangleFull.height || (t = this.texture.minFilter, s = this.texture.magFilter, this.texture.minFilter = _.g.NEAREST, this.texture.magFilter = _.g.NEAREST, this.drawEmptySpace(e), this.texture.minFilter = t, this.texture.magFilter = s)
            }
            drawEmptySpace(e) {
                var t, s = this._adapter.getRectangleRenderer(),
                    r = this._rectangle.width,
                    i = this._rectangle.height;
                r < this.width && (s.render({
                    srcRect: d.A.createFromEdges(t = r - .5, t, 0, i),
                    dstRect: d.A.createFromEdges(0, 1, 0, i),
                    srcTexture: this.texture,
                    dstTexture: e
                }), s.render({
                    srcRect: d.A.createFromEdges(.5, .5, 0, i),
                    dstRect: d.A.createFromEdges(r, this.width, 0, i),
                    srcTexture: e,
                    dstTexture: this.texture
                })), i < this.height && (s.render({
                    srcRect: d.A.createFromEdges(0, r, t = i - .5, t),
                    dstRect: d.A.createFromEdges(0, r, 0, 1),
                    srcTexture: this.texture,
                    dstTexture: e
                }), s.render({
                    srcRect: d.A.createFromEdges(0, r, .5, .5),
                    dstRect: d.A.createFromEdges(0, r, i, this.height),
                    srcTexture: e,
                    dstTexture: this.texture
                })), r < this.width && i < this.height && (s.render({
                    srcRect: d.A.createFromEdges(t = r - .5, t, t = i - .5, t),
                    dstRect: d.A.createFromEdges(0, 1, 0, 1),
                    srcTexture: this.texture,
                    dstTexture: e
                }), s.render({
                    srcRect: d.A.createFromEdges(.5, .5, .5, .5),
                    dstRect: d.A.createFromEdges(r, this.width, i, this.height),
                    srcTexture: e,
                    dstTexture: this.texture
                }))
            }
            render(e) {
                return this._adapter.getRectangleRenderer().renderUnion({
                    srcRect: this.rectangle,
                    textureRect: this._rectangleFull,
                    dstRect: e.rectangle,
                    srcTexture: this.texture,
                    dstTexture: e.texture
                })
            }
            dispose() {
                this._texture.dispose()
            }
            get width() {
                return this._rectangleFull.width
            }
            get height() {
                return this._rectangleFull.height
            }
            get rectangle() {
                return this._rectangle
            }
            get rectangleFull() {
                return this._rectangleFull
            }
            get texture() {
                return this._texture
            }
            get adapter() {
                return this._adapter
            }
        }
        class Ut {
            static create() {
                var e = new Ut.ARRAY_TYPE(6);
                return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 1, e[4] = 0, e[5] = 0, e
            }
            static clone(e) {
                var t = new Ut.ARRAY_TYPE(6);
                return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4], t[5] = e[5], t
            }
            static copy(e, t) {
                return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5], e
            }
            static identity(e) {
                return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 1, e[4] = 0, e[5] = 0, e
            }
            static invert(e, t) {
                var s = t[0],
                    r = t[1],
                    i = t[2],
                    a = t[3],
                    n = t[4],
                    t = t[5],
                    o = s * a - r * i;
                return o ? (e[0] = a * (o = 1 / o), e[1] = -r * o, e[2] = -i * o, e[3] = s * o, e[4] = (i * t - a * n) * o, e[5] = (r * n - s * t) * o, e) : null
            }
            static determinant(e) {
                return e[0] * e[3] - e[1] * e[2]
            }
            static multiply(e, t, s) {
                var r = t[0],
                    i = t[1],
                    a = t[2],
                    n = t[3],
                    o = t[4],
                    t = t[5],
                    l = s[0],
                    h = s[1],
                    c = s[2],
                    d = s[3],
                    u = s[4],
                    s = s[5];
                return e[0] = r * l + a * h, e[1] = i * l + n * h, e[2] = r * c + a * d, e[3] = i * c + n * d, e[4] = r * u + a * s + o, e[5] = i * u + n * s + t, e
            }
            static rotate(e, t, s) {
                var r = t[0],
                    i = t[1],
                    a = t[2],
                    n = t[3],
                    o = t[4],
                    t = t[5],
                    l = Math.sin(s),
                    s = Math.cos(s);
                return e[0] = r * s + a * l, e[1] = i * s + n * l, e[2] = r * -l + a * s, e[3] = i * -l + n * s, e[4] = o, e[5] = t, e
            }
            static scale(e, t, s) {
                var r = t[0],
                    i = t[1],
                    a = t[2],
                    n = t[3],
                    o = t[4],
                    t = t[5],
                    l = s[0],
                    s = s[1];
                return e[0] = r * l, e[1] = i * l, e[2] = a * s, e[3] = n * s, e[4] = o, e[5] = t, e
            }
            static translate(e, t, s) {
                var r = t[0],
                    i = t[1],
                    a = t[2],
                    n = t[3],
                    o = t[4],
                    t = t[5],
                    l = s[0],
                    s = s[1];
                return e[0] = r, e[1] = i, e[2] = a, e[3] = n, e[4] = r * l + a * s + o, e[5] = i * l + n * s + t, e
            }
            static fromRotation(e, t) {
                var s = Math.sin(t),
                    t = Math.cos(t);
                return e[0] = t, e[1] = s, e[2] = -s, e[3] = t, e[4] = 0, e[5] = 0, e
            }
            static fromScaling(e, t) {
                return e[0] = t[0], e[1] = 0, e[2] = 0, e[3] = t[1], e[4] = 0, e[5] = 0, e
            }
            static fromTranslation(e, t) {
                return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 1, e[4] = t[0], e[5] = t[1], e
            }
            static str(e) {
                return "mat2d(" + e[0] + ", " + e[1] + ", " + e[2] + ", " + e[3] + ", " + e[4] + ", " + e[5] + ")"
            }
            static frob(e) {
                return Math.sqrt(Math.pow(e[0], 2) + Math.pow(e[1], 2) + Math.pow(e[2], 2) + Math.pow(e[3], 2) + Math.pow(e[4], 2) + Math.pow(e[5], 2) + 1)
            }
        }
        Ut.ARRAY_TYPE = Float32Array, Ut.mul = Ut.multiply;
        var re = c(889),
            R = c(3790);
        class kt {
            constructor(e) {
                this._width = 0, this._height = 0, this._transparent = !1, this._tiles = [], this._scale = [1, 1], this._pos = [0, 0], this.horizontalFlipRender = (e, t) => {
                    var s = this._adapter.getRectangleRenderer(),
                        r = e.rectangle.clone();
                    r.x = this.width - r.x;
                    const i = e.rectangle.width / e.rectangleFull.width;
                    s.renderUnion({
                        srcRect: r,
                        textureRect: e.rectangleFull,
                        dstRect: t.rectangle,
                        srcTexture: e.texture,
                        dstTexture: t.texture,
                        processUV: t => {
                            for (let e = 0; e < t.length; e += 2) t[e] = i - t[e]
                        }
                    })
                }, this.verticalFlipRender = (e, t) => {
                    var s = this._adapter.getRectangleRenderer(),
                        r = e.rectangle.clone();
                    r.y = this.height - r.y;
                    const i = e.rectangle.height / e.rectangleFull.height;
                    s.renderUnion({
                        srcRect: r,
                        textureRect: e.rectangleFull,
                        dstRect: t.rectangle,
                        srcTexture: e.texture,
                        dstTexture: t.texture,
                        processUV: t => {
                            for (let e = 1; e < t.length; e += 2) t[e] = i - t[e]
                        }
                    })
                }, this.rotateCWRender = (e, t) => {
                    this.rotateRender(e, t, !0)
                }, this.rotateCCWRender = (e, t) => {
                    this.rotateRender(e, t, !1)
                }, this.rotateRender = (e, t, s) => {
                    var r = this._adapter.getRectangleRenderer(),
                        i = s ? 1 : -1,
                        a = e.rectangle.clone(),
                        n = Ut.fromRotation(Ut.create(), i * -Math.PI / 2),
                        n = re.K.transformMat2d(re.K.create(), re.K.fromValues(a.x, a.y), n),
                        n = (s ? n[1] += this.width : n[0] += this.height, a.x = n[0], a.y = n[1], a.width),
                        n = (a.width = a.height, a.height = n, R.w.create()),
                        s = (s ? R.w.translate(n, n, [-(1 - e.rectangle.width / e.rectangleFull.width), 0]) : R.w.translate(n, n, [0, -(1 - e.rectangle.height / e.rectangleFull.height)]), R.w.translate(n, n, [.5, .5]), R.w.rotate(n, n, i * Math.PI / 2), R.w.translate(n, n, [-.5, -.5]), e.rectangleFull.clone()),
                        i = s.width;
                    s.width = s.height, s.height = i, r.renderUnion({
                        srcRect: a,
                        textureRect: s,
                        dstRect: t.rectangle,
                        srcTexture: e.texture,
                        dstTexture: t.texture,
                        uvTransform: n
                    })
                }, this._adapter = e.adapter, this._config = J.g.mergeConfig(kt.defaultConfig, e), this.initThreshold(), this._minFilter = this._config.minFilter, this._magFilter = this._config.magFilter, this.init()
            }
            initThreshold() {
                var e = this._adapter.context;
                void 0 !== this._config.tilingThreshold && -1 !== this._config.tilingThreshold || (this._config.tilingThreshold = this._adapter.context.getParameter(e.gl.MAX_TEXTURE_SIZE)), this._config.tilingThreshold = Math.min(this._config.tilingThreshold, e.getParameter(e.gl.MAX_TEXTURE_SIZE))
            }
            init() {
                var e;
                this._config.source ? this._config.source instanceof HTMLImageElement ? (this._width = this._config.source.naturalWidth, this._height = this._config.source.naturalHeight) : this._config.source instanceof HTMLCanvasElement ? (this._width = this._config.source.width, this._height = this._config.source.height) : console.warn("Unhandled scenario!") : (this._width = this._config.width, this._height = this._config.height), this._transparent = null != (e = this._config.transparent) ? e : this._transparent, this._config.file, this.createTiles(), this._config.source && this.updateStructure()
            }
            createTiles() {
                const e = this._config,
                    s = e.source;
                if (this._tiles = [], this.width > e.tilingThreshold || this.height > e.tilingThreshold) {
                    var r = e.tileWidth,
                        i = e.tileHeight,
                        a = Math.ceil(this.height / i),
                        n = Math.ceil(this.width / r);
                    for (let t = 0; t < a; t++) {
                        this._tiles[t] = [];
                        for (let e = 0; e < n; e++) {
                            var o = e * r,
                                l = t * i,
                                o = d.A.createFromEdges(o, o + r, l, l + i);
                            this._tiles[t][e] = new Bt(this._adapter, s, o, t, e, this)
                        }
                    }
                } else {
                    const e = d.A.createFromEdges(0, this.width, 0, this.height);
                    this._tiles = [
                        [new Bt(this._adapter, s, e, 0, 0, this)]
                    ]
                }
            }
            uploadSource(h) {
                const c = this.tiles[0][0].rectangleFull.width,
                    d = this.tiles[0][0].rectangleFull.height;
                this.eachTile((e, s, r) => {
                    const i = e.rectangle.width,
                        a = e.rectangle.height,
                        n = new Uint8Array(c * d * 4);
                    for (let t = 0; t < i; ++t)
                        for (let e = 0; e < a; ++e) {
                            const a = r * c + t,
                                o = 4 * ((s * d + e) * this.width + a),
                                l = 4 * (e * c + t);
                            n[l] = h[o], n[1 + l] = h[1 + o], n[2 + l] = h[2 + o], n[3 + l] = h[3 + o]
                        }
                    e.texture.uploadSource(n, c, d)
                }), this.updateStructure()
            }
            setFilters(t, s) {
                this._magFilter = t, this._minFilter = s, this.eachTile(e => {
                    e.texture.minFilter = s, e.texture.magFilter = t
                })
            }
            getFilters() {
                return [this._magFilter, this._minFilter]
            }
            resize(e) {
                var t = this.getFilters(),
                    e = (e.resample ? this.setFilters(_.g.LINEAR, _.g.LINEAR_MIPMAP_LINEAR) : this.setFilters(_.g.NEAREST, _.g.NEAREST), new kt({
                        adapter: this._adapter,
                        source: null,
                        width: e.width,
                        height: e.height,
                        transparent: this.transparent
                    }));
                return this.setScale(e.width / this.width, e.height / this.height), this.renderToTiledTexture(e), e.updateStructure(), this.setScale(1, 1), this.setFilters(t[0], t[1]), e
            }
            crop(e) {
                var e = e.rectangle,
                    t = new kt({
                        adapter: this._adapter,
                        source: null,
                        width: e[2],
                        height: e[3],
                        transparent: this.transparent
                    });
                return t.setPos(e[0], e[1]), this.renderToTiledTexture(t), t.updateStructure(), t.setPos(0, 0), t
            }
            flip(e) {
                var t = this.clone(!1);
                return e ? this.customRender(t, this.horizontalFlipRender) : this.customRender(t, this.verticalFlipRender), t.updateStructure(), t
            }
            rotate90(e = !1) {
                var t = new kt({
                    adapter: this._adapter,
                    width: this.height,
                    height: this.width,
                    source: null,
                    transparent: this.transparent
                });
                return e ? this.customRender(t, this.rotateCWRender) : this.customRender(t, this.rotateCCWRender), t.updateStructure(), t
            }
            clone(e) {
                return new kt({
                    adapter: this._adapter,
                    source: null,
                    width: this.width,
                    height: this.height,
                    transparent: this.transparent,
                    minFilter: this.minFilter,
                    magFilter: this.magFilter
                })
            }
            updateStructure() {
                this.fillEmptySpace(), this.generateMipmap()
            }
            fillEmptySpace() {
                var t = this.createTempTexture(),
                    s = (t.generateMipmap(!1), this.rows),
                    r = this.cols;
                for (let e = 0; e < s; e++) this.tiles[e][r - 1].fillEmptySpace(t);
                for (let e = 0; e < r - 1; e++) this.tiles[s - 1][e].fillEmptySpace(t);
                t.dispose()
            }
            createTempTexture() {
                let e = this.width,
                    t = this.height;
                return (1 < this.rows || 1 < this.cols) && (e = this._config.tileWidth, t = this._config.tileHeight), new I({
                    context: this._adapter.context,
                    source: null,
                    width: e,
                    height: t,
                    minFilter: _.g.NEAREST,
                    magFilter: _.g.NEAREST
                })
            }
            generateMipmap(t) {
                this.eachTile(e => {
                    e.texture.generateMipmap(t)
                })
            }
            renderToTiledTexture(e) {
                e.eachTile(e => {
                    this.renderToTile(e)
                })
            }
            renderToTile(t) {
                this.eachTile(e => {
                    e.render(t)
                })
            }
            customRender(e, s) {
                this.eachTile(t => {
                    e.eachTile(e => {
                        s(t, e)
                    })
                })
            }
            clear(t) {
                this.eachTile(e => {
                    e.texture.initFramebuffer().clear(t)
                }), this.updateStructure()
            }
            readPixels(s = !1, r = !0, i = !1) {
                const a = this.rows,
                    n = this.cols,
                    o = this.tiles,
                    l = this.width,
                    h = this.height,
                    c = s ? 4 : 3,
                    d = new Uint8ClampedArray(l * h * c),
                    u = o[0][0].width,
                    p = o[0][0].height;
                for (let t = 0; t < a; ++t)
                    for (let e = 0; e < n; ++e) {
                        const n = o[t][e],
                            h = n.rectangle.width,
                            m = n.rectangle.height,
                            g = v.O.readPixelsWebGL({
                                texture: n.texture,
                                rect: [0, 0, h, m]
                            }),
                            _ = e * u,
                            f = t * p;
                        for (let t = 0; t < g.length; t += 4) {
                            const a = _ + t / 4 % h;
                            let e = f + Math.floor(t / 4 / h);
                            const o = ((e = i ? this.height - 1 - e : e) * l + a) * c;
                            d[o] = g[t], d[1 + o] = g[t + 1], d[2 + o] = g[t + 2], s && (d[3 + o] = r ? g[t + 3] : 255)
                        }
                    }
                return d
            }
            eachTile(s) {
                const r = this.tiles.length;
                for (let t = 0; t < r; t++) {
                    const r = this.tiles[t].length;
                    for (let e = 0; e < r; e++) s(this.tiles[t][e], t, e)
                }
            }
            dispose() {
                this.eachTile(e => {
                    e.dispose()
                })
            }
            get width() {
                return this._width
            }
            get height() {
                return this._height
            }
            setScale(e, t) {
                this._scale[0] = e, this._scale[1] = t, this.updateTiles()
            }
            setPos(e, t) {
                this._pos[0] = e, this._pos[1] = t, this.updateTiles()
            }
            updateTiles() {
                this.eachTile(e => {
                    e.onParentChange()
                })
            }
            get scale() {
                return this._scale
            }
            get pos() {
                return this._pos
            }
            createRectangle() {
                return d.A.createFromEdges(0, this.width, 0, this.height)
            }
            get rows() {
                return this._tiles.length
            }
            get cols() {
                return this._tiles[0].length
            }
            get tiles() {
                return this._tiles
            }
            get minFilter() {
                return this._minFilter
            }
            get magFilter() {
                return this._magFilter
            }
            get transparent() {
                return this._transparent
            }
            get config() {
                return this._config
            }
            get adapter() {
                return this._adapter
            }
            get name() {
                return this._config.name
            }
        }
        kt.defaultConfig = {
            adapter: void 0,
            source: null,
            tilingThreshold: 2048,
            tileWidth: 512,
            tileHeight: 512,
            minFilter: _.g.LINEAR_MIPMAP_LINEAR,
            magFilter: _.g.NEAREST,
            name: ""
        };
        class zt extends u.Component {
            constructor(e) {
                super(e), this.onClick = e => {
                    this.props.onClick(this.props.tree)
                }, this.onMouseOver = e => {
                    var t, s;
                    null != (s = (t = this.props).onMouseOver) && s.call(t, this.props.tree)
                }, this.onMouseOut = e => {
                    var t, s;
                    null != (s = (t = this.props).onMouseOut) && s.call(t, this.props.tree)
                }, this.state = {
                    collapsed: e.defaultCollapsed || !1
                }
            }
            render() {
                var e, t = this.props.tree;
                if (0 < (null == (e = null == t ? void 0 : t.children) ? void 0 : e.length)) {
                    const e = !this.props.isSelected(t),
                        s = t.children.some(e => !!e.checked);
                    return u.createElement("div", {
                        className: h("TreeNode", {
                            collapsed: e
                        })
                    }, this.renderNode(t), u.createElement("div", {
                        className: "children"
                    }, t.children.map((e, t) => u.createElement(zt, {
                        key: t,
                        tree: e,
                        render: this.props.render,
                        defaultCollapsed: !0,
                        isSelected: this.props.isSelected,
                        onClick: this.props.onClick,
                        onMouseOver: this.props.onMouseOver,
                        onMouseOut: this.props.onMouseOut,
                        addPadding: s
                    }))))
                }
                return u.createElement("div", {
                    className: "TreeNode"
                }, this.renderNode(t))
            }
            renderNode(e) {
                var t = 0 < (null == (t = null == e ? void 0 : e.children) ? void 0 : t.length);
                return e.separator ? u.createElement("div", {
                    className: "separator"
                }) : u.createElement("div", {
                    className: h("label", {
                        selected: this.props.isSelected(e),
                        hasChildren: t,
                        addPadding: this.props.addPadding
                    }),
                    onClick: this.onClick,
                    onMouseOver: this.onMouseOver,
                    onMouseOut: this.onMouseOut
                }, this.props.render(e))
            }
        }
        zt.defaultProps = {
            tree: {}
        };
        class P {
            static getInstance() {
                return P.instance || (P.instance = new P)
            }
            static allowEvent(e) {
                return !yt.isInput(e.target)
            }
            constructor(e, t = !0) {
                this.signals = {
                    down: n.M.create(),
                    up: n.M.create()
                }, this.onKeyDown = e => {
                    this.allow(e) && this.signals.down.dispatch(e)
                }, this.onKeyUp = e => {
                    this.allow(e) && this.signals.up.dispatch(e)
                }, this._domElement = e || document.body, this._disableInputs = t, this.setEnabled(!0)
            }
            setEnabled(e) {
                e ? this.addListeners() : this.removeListeners()
            }
            addListeners() {
                this._domElement.addEventListener("keydown", this.onKeyDown), this._domElement.addEventListener("keyup", this.onKeyUp)
            }
            removeListeners() {
                this._domElement.removeEventListener("keydown", this.onKeyDown), this._domElement.removeEventListener("keyup", this.onKeyUp)
            }
            allow(e) {
                return P.allowEvent(e)
            }
            get element() {
                return this._domElement
            }
            dispose() {
                this.removeListeners()
            }
        }
        P.KEY_DOWN = 40, P.KEY_UP = 38, P.KEY_LEFT = 37, P.KEY_RIGHT = 39, P.KEY_ESCAPE = 27, P.KEY_DELETE = 46, P.KEY_BACKSPACE = 8, P.KEY_ENTER = 13, P.KEY_SPACE = 32, P.KEY_TAB = 9, P.KEY_S = 83, P.KEY_O = 79, P.KEY_N = 78, P.KEY_I = 73, P.KEY_F = 70, P.KEY_D = 68, P.KEY_HOME = 36;
        class Vt {
            constructor(e, t) {
                this._fileMenu = e, this._listener = t || new P
            }
            listen() {
                this._listener.signals.down.add(this.onKeyDown, this, 1)
            }
            stopListening() {
                this._listener.signals.down.remove(this.onKeyDown, this)
            }
            onKeyDown(e) {
                switch (this._listener.signals.down.halt(), e.preventDefault(), e.keyCode) {
                    case P.KEY_DOWN:
                        return;
                    case P.KEY_ESCAPE:
                        return void this.close()
                }
            }
            close() {
                this._fileMenu.select(null)
            }
        }
        class Gt extends u.Component {
            constructor(e) {
                super(e), this._parents = new Map, this.isSelected = e => e === this.state.selected || this.isDescendant(this.state.selected, e), this.onClick = e => {
                    e.children && 0 < e.children.length ? this.isTopLevel(e) && (this.isOpened() ? this.select(null) : this.select(e)) : (this.props.onSelect && this.props.onSelect(e), this.select(null))
                }, this.onMouseOver = e => {
                    this.isTopLevel(e) && !this.isOpened() || this.select(e)
                }, this.onMouseOut = e => {
                    this.isTopLevel(e) || this._parents.get(e)
                }, this.onFocusLoss = () => {
                    this.setState({
                        selected: null
                    })
                }, this.state = {
                    selected: null
                }, this._keyboard = new Vt(this), this._container = u.createRef(), this.updateParents()
            }
            isDescendant(e, t) {
                e = this._parents.get(e);
                return !!e && (e === t || this.isDescendant(e, t))
            }
            select(e) {
                this.setState({
                    selected: e
                }), e ? (this._container.current && y.listen(this._container.current, this.onFocusLoss), this._keyboard.listen()) : this._keyboard.stopListening()
            }
            isOpened() {
                return !!this.state.selected
            }
            isTopLevel(e) {
                return -1 < this.props.tree.indexOf(e)
            }
            updateParents() {
                this._parents.clear(), this.addParents(this.props.tree, null)
            }
            addParents(e, t) {
                if (e)
                    for (const s of e) t && this._parents.set(s, t), this.addParents(s.children, s)
            }
            render() {
                var e = this.props.tree.map((e, t) => u.createElement(zt, {
                    key: t,
                    tree: e,
                    render: this.props.render,
                    defaultCollapsed: !0,
                    onClick: this.onClick,
                    onMouseOver: this.onMouseOver,
                    onMouseOut: this.onMouseOut,
                    isSelected: this.isSelected
                }));
                return u.createElement("div", {
                    ref: this._container,
                    className: "menu"
                }, e)
            }
        }
        Gt.defaultProps = {
            tree: [],
            render: e => e.label
        };
        class Wt extends u.PureComponent {
            constructor() {
                super(...arguments), this.renderFileMenu = e => {
                    var t = this.props.app.commands.findCommand(e.id),
                        s = null != (s = e.hotkey) ? s : this.renderShortcut(t) || "";
                    return u.createElement("span", {
                        className: h({
                            bool: !!e.checked,
                            checked: null == (t = e.checked) ? void 0 : t.call(e)
                        })
                    }, e.label || "", s && u.createElement("span", {
                        className: "hotkey"
                    }, s))
                }, this.onSelectFileMenu = e => {
                    e.onSelect ? e.onSelect(e) : Array.isArray(e.options) ? this.props.app.commands.execute(e.id, ...e.options) : this.props.app.commands.execute(e.id, e.options)
                }
            }
            renderShortcut(e) {
                if (e) return (new Ht).build(e)
            }
            render() {
                return u.createElement(Gt, {
                    tree: this.props.menu,
                    render: this.renderFileMenu,
                    onSelect: this.onSelectFileMenu
                })
            }
        }
        class Ht {
            constructor() {
                this._result = ""
            }
            build(e) {
                this._result = "";
                e = e.hotKeys[0];
                return e && (e.ctrl && this.addPart("Ctrl"), e.meta && this.addPart(""), e.alt && this.addPart(ee.U.isMacLike() ? "" : "Alt"), e.shift && this.addPart(""), e.keyCode) && this.addPart(String.fromCharCode(e.keyCode)), this._result
            }
            addPart(e) {
                this._result && (this._result += " "), this._result += e
            }
        }
        class F extends u.Component {
            static renderLabel(e) {
                return e.label
            }
            constructor(e) {
                super(e), this.onChange = e => {
                    var {
                        options: t,
                        onChange: s
                    } = this.props;
                    this.props.onChange && (t = -1 === (e = e.currentTarget.selectedIndex) ? t[0] : t[e], null != s) && s(t)
                }
            }
            render() {
                const {
                    selected: e,
                    options: t,
                    disabled: s,
                    render: r
                } = this.props, i = t.indexOf(e);
                return u.createElement("select", {
                    value: i,
                    disabled: s,
                    onChange: this.onChange
                }, t.map((e, t) => u.createElement("option", {
                    key: t,
                    value: t
                }, null == r ? void 0 : r(e))))
            }
        }
        F.defaultProps = {
            options: [],
            selected: null,
            disabled: !1,
            render: e => e
        };
        class U extends u.Component {
            constructor(e) {
                super(e), this.onChange = e => {
                    this.triggerChange(e)
                }
            }
            render() {
                return u.createElement("input", {
                    checked: this.props.value,
                    type: this.props.type,
                    onChange: this.onChange,
                    disabled: !this.props.enabled
                })
            }
            triggerChange(e) {
                var t = this.props["onChange"];
                t && t(this.validateValue(e.currentTarget.checked))
            }
            validateValue(e) {
                return !!e
            }
        }
        U.defaultProps = {
            value: !1,
            enabled: !0,
            type: "checkbox"
        };
        class k extends u.Component {
            constructor(e) {
                super(e)
            }
            render() {
                let e = u.createElement("span", {
                        className: "label"
                    }, this.props.label),
                    t = this.props.children;
                return this.reverseChildren() && ([e, t] = [t, e]), u.createElement("div", {
                    className: "Field " + (this.props.className || "")
                }, u.createElement("label", null, e, t))
            }
            reverseChildren() {
                var e;
                return void 0 !== this.props.reverse ? this.props.reverse : (null == (e = this.props.children) ? void 0 : e.type) === U
            }
        }
        k.defaultProps = {
            label: ""
        };
        class z extends class {
            constructor(e) {
                this._configs = [], this._enabled = !0, this.onShortcutActivated = (e, t) => {
                    this.execute(void 0, t)
                }, this._shortcuts = e
            }
            execute(e, t) {}
            addShortcut(e) {
                var t = e;
                t.ctrlMeta && (ee.U.isMacLike() ? t.meta = !0 : t.ctrl = !0), t.handler = this.onShortcutActivated, this._configs.push(e), this._shortcuts.add(t)
            }
            get enabled() {
                return this._enabled
            }
            get hotKeys() {
                return this._configs
            }
        } {
            constructor(e) {
                super(e.shortcuts), this._app = e
            }
        }
        class Yt {
            constructor(e) {
                this._label = "[unnamed exporter]", this._infoText = "", this._id = e, this._mimeId = e, this._extension = e, this._label = "." + e
            }
            downloadAsFile(e, t, s = window.document) {
                e = new File([e], t, {
                    type: this.mimeType,
                    lastModified: Date.now()
                });
                p.P.downloadFile(e, t, s)
            }
            get extension() {
                return this._extension
            }
            get mimeType() {
                return "image/" + this._mimeId
            }
            get infoText() {
                return this._infoText
            }
            get label() {
                return this._label
            }
            get id() {
                return this._id
            }
        }
        var ie, ae, ne, oe, le, he, ce = c(999);
        class jt extends Yt {
            constructor(e) {
                super(e)
            }
            async
            export (e, t) {
                return this.export2DCanvas(e, t)
            }
            export2DCanvas(e, s) {
                const r = ce.P.inst.canvas,
                    i = ce.P.inst.ctx,
                    a = (r.width = e.width, r.height = e.height, e.rows),
                    n = e.cols,
                    o = e.tiles;
                let l = e.height;
                for (let t = 0; t < a; ++t) {
                    for (let e = 0; e < n; ++e) {
                        const r = o[t][e],
                            a = v.O.createImageDataWebGL(r.texture, !0);
                        i.putImageData(a, e * r.texture.width, l - r.height)
                    }
                    l -= o[t][0].height
                }
                return new Promise(t => {
                    r.toBlob(e => {
                        e ? t(e) : console.error("Failed to create blob")
                    }, this.mimeType, s.quality)
                })
            }
        }
        class Kt extends jt {
            constructor() {
                super(Kt.ID), this._infoText = "\n\t\t\t<p>PNG [<b>P</b>ortable <b>N</b>etwork <b>G</b>raphics] is a widely supported format that can compress the image in a lossless way.</p>\n\t\t\t<p>Therefore we recommend using it for anywhere good quality matters, especially for drawings, logos, and icons, basically anything where there are sharp contrasts between adjacent pixels.</p>\n\t\t\t<p>PNG can also store transparent and semi-transparent pixels.<br/>\n\t\t\tIt can support up to 24 bit (16.7 M) color plus 8 bit for the alpha (transparency) channel (a sum of 32 bit).</p>\n\t\t\t"
            }
        }
        Kt.ID = "png";
        class qt extends jt {
            constructor() {
                super(qt.ID), this._mimeId = "jpeg", this._infoText = "\n\t\t\t<p>JPG [or JPEG for <b>J</b>oint <b>P</b>hotographic <b>E</b>xperts <b>G</b>roup] is a widely supported format for lossy compression of images.<br/> \n\t\t\tWe suggest using it for photos.</p>\n\t\t\t<p>It can support up to 24 bit (16.7 M) color without transparency.</p>\n\t\t\t"
            }
        }
        qt.ID = "jpg";
        class $t {
            constructor() {
                this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new Uint16Array(320), this.work = new Uint16Array(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0
            }
        }
        class Xt {
            constructor() {
                this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0
            }
        }
        class Zt {
            constructor() {
                this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = !1
            }
        }
        let s, r, i = !0,
            L = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0],
            D = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78],
            O = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0],
            B = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64],
            e = !0,
            a = !0;
        try {
            String.fromCharCode.apply(null, [0])
        } catch (u) {
            e = !1
        }
        try {
            String.fromCharCode.apply(null, new Uint8Array(1))
        } catch (u) {
            a = !1
        }
        let l = new Uint8Array(256);
        for (let e = 0; e < 256; e++) l[e] = 252 <= e ? 6 : 248 <= e ? 5 : 240 <= e ? 4 : 224 <= e ? 3 : 192 <= e ? 2 : 1;
        l[254] = l[254] = 1;
        class Jt {
            constructor(e) {
                this.err = 0, this.msg = "", this.crcTable = this.makeCrcTable(), this.options = this.assign({
                    chunkSize: 16384,
                    windowBits: 0,
                    to: ""
                });
                var t = this.options,
                    e = (t.raw && 0 <= t.windowBits && t.windowBits < 16 && (t.windowBits = -t.windowBits, 0 === t.windowBits) && (t.windowBits = -15), !(0 <= t.windowBits && t.windowBits < 16) || e && e.windowBits || (t.windowBits += 32), 15 < t.windowBits && t.windowBits < 48 && 0 == (15 & t.windowBits) && (t.windowBits |= 15), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new Xt, this.strm.avail_out = 0, this.inflateInit2(this.strm, t.windowBits));
                if (0 !== e) throw new Error(String(e));
                this.header = new Zt, this.inflateGetHeader(this.strm, this.header)
            }
            makeCrcTable() {
                let t;
                var s = [];
                for (let e = 0; e < 256; e++) {
                    t = e;
                    for (let e = 0; e < 8; e++) t = 1 & t ? 3988292384 ^ t >>> 1 : t >>> 1;
                    s[e] = t
                }
                return s
            }
            crc32(t, s, e, r) {
                var i = this.crcTable,
                    a = r + e;
                t ^= -1;
                for (let e = r; e < a; e++) t = t >>> 8 ^ i[255 & (t ^ s[e])];
                return -1 ^ t
            }
            inflateGetHeader(e, t) {
                return !e || !e.state || 0 == (2 & (e = e.state).wrap) ? -2 : ((e.head = t).done = !1, 0)
            }
            inflateReset2(e, t) {
                let s, r;
                return !e || !e.state || (r = e.state, t < 0 ? (s = 0, t = -t) : (s = 1 + (t >> 4), t < 48 && (t &= 15)), t && (t < 8 || 15 < t)) ? -2 : (null !== r.window && r.wbits !== t && (r.window = null), r.wrap = s, r.wbits = t, this.inflateReset(e))
            }
            inflateReset(e) {
                var t;
                return e && e.state ? ((t = e.state).wsize = 0, t.whave = 0, t.wnext = 0, this.inflateResetKeep(e)) : -2
            }
            inflateResetKeep(e) {
                var t;
                return e && e.state ? (t = e.state, e.total_in = e.total_out = t.total = 0, e.msg = "", t.wrap && (e.adler = 1 & t.wrap), t.mode = 1, t.last = 0, t.havedict = 0, t.dmax = 32768, t.head = null, t.hold = 0, t.bits = 0, t.lencode = t.lendyn = new Int32Array(852), t.distcode = t.distdyn = new Int32Array(592), t.sane = 1, t.back = -1, 0) : -2
            }
            inflateInit2(e, t) {
                var s = this.strm.state;
                return e ? (s = new $t, (e.state = s).window = null, 0 !== (s = this.inflateReset2(e, t)) && (e.state = null), s) : -2
            }
            assign(e) {
                for (var t = Array.prototype.slice.call(arguments, 1); t.length;) {
                    var s = t.shift();
                    if (s) {
                        if ("object" != typeof s) throw new TypeError(s + "must be non-object");
                        for (var r in s) s.hasOwnProperty(r) && (e[r] = s[r])
                    }
                }
                return e
            }
            shrinkBuf(e, t) {
                return e.length === t ? e : e.subarray ? e.subarray(0, t) : (e.length = t, e)
            }
            flattenChunks(e) {
                let t, s, r, i, a, n;
                for (r = 0, t = 0, s = e.length; t < s; t++) r += e[t].length;
                for (n = new Uint8Array(r), i = 0, t = 0, s = e.length; t < s; t++) a = e[t], n.set(a, i), i += a.length;
                return n
            }
            onEnd(e) {
                0 === e && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = this.flattenChunks(this.chunks)), this.chunks = [], this.err = e, this.msg = this.strm.msg
            }
            zswap32(e) {
                return (e >>> 24 & 255) + (e >>> 8 & 65280) + ((65280 & e) << 8) + ((255 & e) << 24)
            }
            inflate_fast(e, t) {
                let s, r, i, a, n, o, l, h, c, d, u, p, m, g, _, f, v, b, x, T, w, E, C, y, A;
                s = e.state, r = e.next_in, y = e.input, i = r + (e.avail_in - 5), a = e.next_out, A = e.output, n = a - (t - e.avail_out), o = a + (e.avail_out - 257), l = s.dmax, h = s.wsize, c = s.whave, d = s.wnext, u = s.window, p = s.hold, m = s.bits, g = s.lencode, _ = s.distcode, f = (1 << s.lenbits) - 1, v = (1 << s.distbits) - 1;
                e: do {
                    for (m < 15 && (p += y[r++] << m, m += 8, p += y[r++] << m, m += 8), b = g[p & f];;) {
                        if (x = b >>> 24, p >>>= x, m -= x, 0 === (x = b >>> 16 & 255)) A[a++] = 65535 & b;
                        else {
                            if (!(16 & x)) {
                                if (0 == (64 & x)) {
                                    b = g[(65535 & b) + (p & (1 << x) - 1)];
                                    continue
                                }
                                if (32 & x) {
                                    s.mode = 12;
                                    break e
                                }
                                e.msg = "invalid literal/length code", s.mode = 30;
                                break e
                            }
                            for (T = 65535 & b, (x &= 15) && (m < x && (p += y[r++] << m, m += 8), T += p & (1 << x) - 1, p >>>= x, m -= x), m < 15 && (p += y[r++] << m, m += 8, p += y[r++] << m, m += 8), b = _[p & v];;) {
                                if (x = b >>> 24, p >>>= x, m -= x, !(16 & (x = b >>> 16 & 255))) {
                                    if (0 == (64 & x)) {
                                        b = _[(65535 & b) + (p & (1 << x) - 1)];
                                        continue
                                    }
                                    e.msg = "invalid distance code", s.mode = 30;
                                    break e
                                }
                                if (w = 65535 & b, x &= 15, m < x && (p += y[r++] << m, (m += 8) < x) && (p += y[r++] << m, m += 8), l < (w += p & (1 << x) - 1)) {
                                    e.msg = "invalid distance too far back", s.mode = 30;
                                    break e
                                }
                                if (p >>>= x, m -= x, w > (x = a - n)) {
                                    if ((x = w - x) > c && s.sane) {
                                        e.msg = "invalid distance too far back", s.mode = 30;
                                        break e
                                    }
                                    if (E = 0, C = u, 0 === d) {
                                        if (E += h - x, x < T) {
                                            for (T -= x; A[a++] = u[E++], --x;);
                                            E = a - w, C = A
                                        }
                                    } else if (d < x) {
                                        if (E += h + d - x, (x -= d) < T) {
                                            for (T -= x; A[a++] = u[E++], --x;);
                                            if (E = 0, d < T) {
                                                for (x = d, T -= x; A[a++] = u[E++], --x;);
                                                E = a - w, C = A
                                            }
                                        }
                                    } else if (E += d - x, x < T) {
                                        for (T -= x; A[a++] = u[E++], --x;);
                                        E = a - w, C = A
                                    }
                                    for (; 2 < T;) A[a++] = C[E++], A[a++] = C[E++], A[a++] = C[E++], T -= 3;
                                    T && (A[a++] = C[E++], 1 < T) && (A[a++] = C[E++])
                                } else {
                                    for (E = a - w; A[a++] = A[E++], A[a++] = A[E++], A[a++] = A[E++], 2 < (T -= 3););
                                    T && (A[a++] = A[E++], 1 < T) && (A[a++] = A[E++])
                                }
                                break
                            }
                        }
                        break
                    }
                } while (r < i && a < o);
                T = m >> 3, r -= T, m -= T << 3, p &= (1 << m) - 1, e.next_in = r, e.next_out = a, e.avail_in = r < i ? i - r + 5 : 5 - (r - i), e.avail_out = a < o ? o - a + 257 : 257 - (a - o), s.hold = p, s.bits = m
            }
            inflate_table(e, t, s, r, i, a, n, o) {
                let l, h, c, d, u, p, m, g, _, f = o.bits,
                    v = 0,
                    b = 0,
                    x = 0,
                    T = 0,
                    w = 0,
                    E = 0,
                    C = 0,
                    y = 0,
                    A = 0,
                    M = 0,
                    R = null,
                    S = 0,
                    N = new Uint16Array(16),
                    I = new Uint16Array(16),
                    P = null,
                    F = 0;
                for (v = 0; v <= 15; v++) N[v] = 0;
                for (b = 0; b < r; b++) N[t[s + b]]++;
                for (w = f, T = 15; 1 <= T && 0 === N[T]; T--);
                if (w > T && (w = T), 0 === T) i[a++] = 20971520, i[a++] = 20971520, o.bits = 1;
                else {
                    for (x = 1; x < T && 0 === N[x]; x++);
                    for (w < x && (w = x), y = 1, v = 1; v <= 15; v++)
                        if ((y = (y <<= 1) - N[v]) < 0) return -1;
                    if (0 < y && (0 === e || 1 !== T)) return -1;
                    for (I[1] = 0, v = 1; v < 15; v++) I[v + 1] = I[v] + N[v];
                    for (b = 0; b < r; b++) 0 !== t[s + b] && (n[I[t[s + b]]++] = b);
                    if (p = 0 === e ? (R = P = n, 19) : 1 === e ? (R = L, S -= 257, P = D, F -= 257, 256) : (R = O, P = B, -1), M = 0, b = 0, v = x, u = a, E = w, C = 0, c = -1, d = (A = 1 << w) - 1, 1 === e && 852 < A || 2 === e && 592 < A) return 1;
                    for (;;) {
                        for (m = v - C, _ = n[b] < p ? (g = 0, n[b]) : n[b] > p ? (g = P[F + n[b]], R[S + n[b]]) : (g = 96, 0), l = 1 << v - C, h = 1 << E, x = h; h -= l, i[u + (M >> C) + h] = m << 24 | g << 16 | _ | 0, 0 !== h;);
                        for (l = 1 << v - 1; M & l;) l >>= 1;
                        if (0 !== l ? M = (M &= l - 1) + l : M = 0, b++, 0 == --N[v]) {
                            if (v === T) break;
                            v = t[s + n[b]]
                        }
                        if (v > w && (M & d) !== c) {
                            for (0 === C && (C = w), u += x, E = v - C, y = 1 << E; E + C < T && !((y -= N[E + C]) <= 0);) E++, y <<= 1;
                            if (A += 1 << E, 1 === e && 852 < A || 2 === e && 592 < A) return 1;
                            i[c = M & d] = w << 24 | E << 16 | u - a | 0
                        }
                    }
                    0 !== M && (i[u + M] = v - C << 24 | 64 << 16 | 0), o.bits = w
                }
                return 0
            }
            adler32(e, t, s, r) {
                let i = 65535 & e | 0,
                    a = e >>> 16 & 65535 | 0,
                    n = 0;
                for (; 0 !== s;) {
                    for (s -= n = 2e3 < s ? 2e3 : s; i = i + t[r++] | 0, a = a + i | 0, --n;);
                    i %= 65521, a %= 65521
                }
                return i | a << 16 | 0
            }
            arraySet(t, s, r, i, a) {
                if (s.subarray && t.subarray) t.set(s.subarray(r, r + i), a);
                else
                    for (let e = 0; e < i; e++) t[a + e] = s[r + e]
            }
            fixedtables(t) {
                if (i) {
                    let e;
                    for (s = new Int32Array(512), r = new Int32Array(32), e = 0; e < 144;) t.lens[e++] = 8;
                    for (; e < 256;) t.lens[e++] = 9;
                    for (; e < 280;) t.lens[e++] = 7;
                    for (; e < 288;) t.lens[e++] = 8;
                    for (this.inflate_table(1, t.lens, 0, 288, s, 0, t.work, {
                            bits: 9
                        }), e = 0; e < 32;) t.lens[e++] = 5;
                    this.inflate_table(2, t.lens, 0, 32, r, 0, t.work, {
                        bits: 5
                    }), i = !1
                }
                t.lencode = s, t.lenbits = 9, t.distcode = r, t.distbits = 5
            }
            zlib_inflate(e, t) {
                let s, r, i, a, n, o, l, h, c, d, u, p, m, g, _, f, v, b, x, T, w, E, C, y, A = 0,
                    M = new Uint8Array(4),
                    R = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
                if (!e || !e.state || !e.output || !e.input && 0 !== e.avail_in) return -2;
                12 === (s = e.state).mode && (s.mode = 13), n = e.next_out, i = e.output, l = e.avail_out, a = e.next_in, r = e.input, o = e.avail_in, h = s.hold, c = s.bits, d = o, u = l, E = 0;
                e: for (;;) switch (s.mode) {
                    case 1:
                        if (0 === s.wrap) s.mode = 13;
                        else {
                            for (; c < 16;) {
                                if (0 === o) break e;
                                o--, h += r[a++] << c, c += 8
                            }
                            if (2 & s.wrap && 35615 === h) s.check = 0, M[0] = 255 & h, M[1] = h >>> 8 & 255, s.check = this.crc32(s.check, M, 2, 0), h = 0, c = 0, s.mode = 2;
                            else if (s.flags = 0, s.head && (s.head.done = !1), !(1 & s.wrap) || (((255 & h) << 8) + (h >> 8)) % 31) e.msg = "incorrect header check", s.mode = 30;
                            else if (8 != (15 & h)) e.msg = "unknown compression method", s.mode = 30;
                            else {
                                if (h >>>= 4, c -= 4, w = 8 + (15 & h), 0 === s.wbits) s.wbits = w;
                                else if (w > s.wbits) {
                                    e.msg = "invalid window size", s.mode = 30;
                                    break
                                }
                                s.dmax = 1 << w, e.adler = s.check = 1, s.mode = 512 & h ? 10 : 12, h = 0, c = 0
                            }
                        }
                        break;
                    case 2:
                        for (; c < 16;) {
                            if (0 === o) break e;
                            o--, h += r[a++] << c, c += 8
                        }
                        if (s.flags = h, 8 != (255 & s.flags)) {
                            e.msg = "unknown compression method", s.mode = 30;
                            break
                        }
                        if (57344 & s.flags) {
                            e.msg = "unknown header flags set", s.mode = 30;
                            break
                        }
                        s.head && (s.head.text = h >> 8 & 1), 512 & s.flags && (M[0] = 255 & h, M[1] = h >>> 8 & 255, s.check = this.crc32(s.check, M, 2, 0)), h = 0, c = 0, s.mode = 3;
                    case 3:
                        for (; c < 32;) {
                            if (0 === o) break e;
                            o--, h += r[a++] << c, c += 8
                        }
                        s.head && (s.head.time = h), 512 & s.flags && (M[0] = 255 & h, M[1] = h >>> 8 & 255, M[2] = h >>> 16 & 255, M[3] = h >>> 24 & 255, s.check = this.crc32(s.check, M, 4, 0)), h = 0, c = 0, s.mode = 4;
                    case 4:
                        for (; c < 16;) {
                            if (0 === o) break e;
                            o--, h += r[a++] << c, c += 8
                        }
                        s.head && (s.head.xflags = 255 & h, s.head.os = h >> 8), 512 & s.flags && (M[0] = 255 & h, M[1] = h >>> 8 & 255, s.check = this.crc32(s.check, M, 2, 0)), h = 0, c = 0, s.mode = 5;
                    case 5:
                        if (1024 & s.flags) {
                            for (; c < 16;) {
                                if (0 === o) break e;
                                o--, h += r[a++] << c, c += 8
                            }
                            s.length = h, s.head && (s.head.extra_len = h), 512 & s.flags && (M[0] = 255 & h, M[1] = h >>> 8 & 255, s.check = this.crc32(s.check, M, 2, 0)), h = 0, c = 0
                        } else s.head && (s.head.extra = null);
                        s.mode = 6;
                    case 6:
                        if (1024 & s.flags && ((p = (p = s.length) > o ? o : p) && (s.head && (w = s.head.extra_len - s.length, s.head.extra || (s.head.extra = new Array(s.head.extra_len)), this.arraySet(s.head.extra, r, a, p, w)), 512 & s.flags && (s.check = this.crc32(s.check, r, p, a)), o -= p, a += p, s.length -= p), s.length)) break e;
                        s.length = 0, s.mode = 7;
                    case 7:
                        if (2048 & s.flags) {
                            if (0 === o) break e;
                            for (p = 0; w = r[a + p++], s.head && w && s.length < 65536 && (s.head.name += String.fromCharCode(w)), w && p < o;);
                            if (512 & s.flags && (s.check = this.crc32(s.check, r, p, a)), o -= p, a += p, w) break e
                        } else s.head && (s.head.name = null);
                        s.length = 0, s.mode = 8;
                    case 8:
                        if (4096 & s.flags) {
                            if (0 === o) break e;
                            for (p = 0; w = r[a + p++], s.head && w && s.length < 65536 && (s.head.comment += String.fromCharCode(w)), w && p < o;);
                            if (512 & s.flags && (s.check = this.crc32(s.check, r, p, a)), o -= p, a += p, w) break e
                        } else s.head && (s.head.comment = null);
                        s.mode = 9;
                    case 9:
                        if (512 & s.flags) {
                            for (; c < 16;) {
                                if (0 === o) break e;
                                o--, h += r[a++] << c, c += 8
                            }
                            if (h !== (65535 & s.check)) {
                                e.msg = "header crc mismatch", s.mode = 30;
                                break
                            }
                            h = 0, c = 0
                        }
                        s.head && (s.head.hcrc = s.flags >> 9 & 1, s.head.done = !0), e.adler = s.check = 0, s.mode = 12;
                        break;
                    case 10:
                        for (; c < 32;) {
                            if (0 === o) break e;
                            o--, h += r[a++] << c, c += 8
                        }
                        e.adler = s.check = this.zswap32(h), h = 0, c = 0, s.mode = 11;
                    case 11:
                        if (0 === s.havedict) return e.next_out = n, e.avail_out = l, e.next_in = a, e.avail_in = o, s.hold = h, s.bits = c, 2;
                        e.adler = s.check = 1, s.mode = 12;
                    case 12:
                        if (5 === t || 6 === t) break e;
                    case 13:
                        if (s.last) h >>>= 7 & c, c -= 7 & c, s.mode = 27;
                        else {
                            for (; c < 3;) {
                                if (0 === o) break e;
                                o--, h += r[a++] << c, c += 8
                            }
                            switch (s.last = 1 & h, h >>>= 1, --c, 3 & h) {
                                case 0:
                                    s.mode = 14;
                                    break;
                                case 1:
                                    if (this.fixedtables(s), s.mode = 20, 6 !== t) break;
                                    h >>>= 2, c -= 2;
                                    break e;
                                case 2:
                                    s.mode = 17;
                                    break;
                                case 3:
                                    e.msg = "invalid block type", s.mode = 30
                            }
                            h >>>= 2, c -= 2
                        }
                        break;
                    case 14:
                        for (h >>>= 7 & c, c -= 7 & c; c < 32;) {
                            if (0 === o) break e;
                            o--, h += r[a++] << c, c += 8
                        }
                        if ((65535 & h) != (h >>> 16 ^ 65535)) {
                            e.msg = "invalid stored block lengths", s.mode = 30;
                            break
                        }
                        if (s.length = 65535 & h, h = 0, c = 0, s.mode = 15, 6 === t) break e;
                    case 15:
                        s.mode = 16;
                    case 16:
                        if (p = s.length) {
                            if (0 === (p = (p = p > o ? o : p) > l ? l : p)) break e;
                            this.arraySet(i, r, a, p, n), o -= p, a += p, l -= p, n += p, s.length -= p
                        } else s.mode = 12;
                        break;
                    case 17:
                        for (; c < 14;) {
                            if (0 === o) break e;
                            o--, h += r[a++] << c, c += 8
                        }
                        if (s.nlen = 257 + (31 & h), h >>>= 5, c -= 5, s.ndist = 1 + (31 & h), h >>>= 5, c -= 5, s.ncode = 4 + (15 & h), h >>>= 4, c -= 4, 286 < s.nlen || 30 < s.ndist) {
                            e.msg = "too many length or distance symbols", s.mode = 30;
                            break
                        }
                        s.have = 0, s.mode = 18;
                    case 18:
                        for (; s.have < s.ncode;) {
                            for (; c < 3;) {
                                if (0 === o) break e;
                                o--, h += r[a++] << c, c += 8
                            }
                            s.lens[R[s.have++]] = 7 & h, h >>>= 3, c -= 3
                        }
                        for (; s.have < 19;) s.lens[R[s.have++]] = 0;
                        if (s.lencode = s.lendyn, s.lenbits = 7, C = {
                                bits: s.lenbits
                            }, E = this.inflate_table(0, s.lens, 0, 19, s.lencode, 0, s.work, C), s.lenbits = C.bits, E) {
                            e.msg = "invalid code lengths set", s.mode = 30;
                            break
                        }
                        s.have = 0, s.mode = 19;
                    case 19:
                        for (; s.have < s.nlen + s.ndist;) {
                            for (; A = s.lencode[h & (1 << s.lenbits) - 1], _ = A >>> 24, f = A >>> 16 & 255, v = 65535 & A, !(_ <= c);) {
                                if (0 === o) break e;
                                o--, h += r[a++] << c, c += 8
                            }
                            if (v < 16) h >>>= _, c -= _, s.lens[s.have++] = v;
                            else {
                                if (16 === v) {
                                    for (y = _ + 2; c < y;) {
                                        if (0 === o) break e;
                                        o--, h += r[a++] << c, c += 8
                                    }
                                    if (h >>>= _, c -= _, 0 === s.have) {
                                        e.msg = "invalid bit length repeat", s.mode = 30;
                                        break
                                    }
                                    w = s.lens[s.have - 1], p = 3 + (3 & h), h >>>= 2, c -= 2
                                } else if (17 === v) {
                                    for (y = _ + 3; c < y;) {
                                        if (0 === o) break e;
                                        o--, h += r[a++] << c, c += 8
                                    }
                                    h >>>= _, c -= _, w = 0, p = 3 + (7 & h), h >>>= 3, c -= 3
                                } else {
                                    for (y = _ + 7; c < y;) {
                                        if (0 === o) break e;
                                        o--, h += r[a++] << c, c += 8
                                    }
                                    h >>>= _, c -= _, w = 0, p = 11 + (127 & h), h >>>= 7, c -= 7
                                }
                                if (s.have + p > s.nlen + s.ndist) {
                                    e.msg = "invalid bit length repeat", s.mode = 30;
                                    break
                                }
                                for (; p--;) s.lens[s.have++] = w
                            }
                        }
                        if (30 === s.mode) break;
                        if (0 === s.lens[256]) {
                            e.msg = "invalid code -- missing end-of-block", s.mode = 30;
                            break
                        }
                        if (s.lenbits = 9, C = {
                                bits: s.lenbits
                            }, E = this.inflate_table(1, s.lens, 0, s.nlen, s.lencode, 0, s.work, C), s.lenbits = C.bits, E) {
                            e.msg = "invalid literal/lengths set", s.mode = 30;
                            break
                        }
                        if (s.distbits = 6, s.distcode = s.distdyn, C = {
                                bits: s.distbits
                            }, E = this.inflate_table(2, s.lens, s.nlen, s.ndist, s.distcode, 0, s.work, C), s.distbits = C.bits, E) {
                            e.msg = "invalid distances set", s.mode = 30;
                            break
                        }
                        if (s.mode = 20, 6 === t) break e;
                    case 20:
                        s.mode = 21;
                    case 21:
                        if (6 <= o && 258 <= l) {
                            e.next_out = n, e.avail_out = l, e.next_in = a, e.avail_in = o, s.hold = h, s.bits = c, this.inflate_fast(e, u), n = e.next_out, i = e.output, l = e.avail_out, a = e.next_in, r = e.input, o = e.avail_in, h = s.hold, c = s.bits, 12 === s.mode && (s.back = -1);
                            break
                        }
                        for (s.back = 0; A = s.lencode[h & (1 << s.lenbits) - 1], _ = A >>> 24, f = A >>> 16 & 255, v = 65535 & A, !(_ <= c);) {
                            if (0 === o) break e;
                            o--, h += r[a++] << c, c += 8
                        }
                        if (f && 0 == (240 & f)) {
                            for (b = _, x = f, T = v; A = s.lencode[T + ((h & (1 << b + x) - 1) >> b)], _ = A >>> 24, f = A >>> 16 & 255, v = 65535 & A, !(b + _ <= c);) {
                                if (0 === o) break e;
                                o--, h += r[a++] << c, c += 8
                            }
                            h >>>= b, c -= b, s.back += b
                        }
                        if (h >>>= _, c -= _, s.back += _, s.length = v, 0 === f) {
                            s.mode = 26;
                            break
                        }
                        if (32 & f) {
                            s.back = -1, s.mode = 12;
                            break
                        }
                        if (64 & f) {
                            e.msg = "invalid literal/length code", s.mode = 30;
                            break
                        }
                        s.extra = 15 & f, s.mode = 22;
                    case 22:
                        if (s.extra) {
                            for (y = s.extra; c < y;) {
                                if (0 === o) break e;
                                o--, h += r[a++] << c, c += 8
                            }
                            s.length += h & (1 << s.extra) - 1, h >>>= s.extra, c -= s.extra, s.back += s.extra
                        }
                        s.was = s.length, s.mode = 23;
                    case 23:
                        for (; A = s.distcode[h & (1 << s.distbits) - 1], _ = A >>> 24, f = A >>> 16 & 255, v = 65535 & A, !(_ <= c);) {
                            if (0 === o) break e;
                            o--, h += r[a++] << c, c += 8
                        }
                        if (0 == (240 & f)) {
                            for (b = _, x = f, T = v; A = s.distcode[T + ((h & (1 << b + x) - 1) >> b)], _ = A >>> 24, f = A >>> 16 & 255, v = 65535 & A, !(b + _ <= c);) {
                                if (0 === o) break e;
                                o--, h += r[a++] << c, c += 8
                            }
                            h >>>= b, c -= b, s.back += b
                        }
                        if (h >>>= _, c -= _, s.back += _, 64 & f) {
                            e.msg = "invalid distance code", s.mode = 30;
                            break
                        }
                        s.offset = v, s.extra = 15 & f, s.mode = 24;
                    case 24:
                        if (s.extra) {
                            for (y = s.extra; c < y;) {
                                if (0 === o) break e;
                                o--, h += r[a++] << c, c += 8
                            }
                            s.offset += h & (1 << s.extra) - 1, h >>>= s.extra, c -= s.extra, s.back += s.extra
                        }
                        if (s.offset > s.dmax) {
                            e.msg = "invalid distance too far back", s.mode = 30;
                            break
                        }
                        s.mode = 25;
                    case 25:
                        if (0 === l) break e;
                        if (p = u - l, s.offset > p) {
                            if ((p = s.offset - p) > s.whave && s.sane) {
                                e.msg = "invalid distance too far back", s.mode = 30;
                                break
                            }
                            m = p > s.wnext ? (p -= s.wnext, s.wsize - p) : s.wnext - p, p > s.length && (p = s.length), g = s.window
                        } else g = i, m = n - s.offset, p = s.length;
                        for (p > l && (p = l), l -= p, s.length -= p; i[n++] = g[m++], --p;);
                        0 === s.length && (s.mode = 21);
                        break;
                    case 26:
                        if (0 === l) break e;
                        i[n++] = s.length, l--, s.mode = 21;
                        break;
                    case 27:
                        if (s.wrap) {
                            for (; c < 32;) {
                                if (0 === o) break e;
                                o--, h |= r[a++] << c, c += 8
                            }
                            if (u -= l, e.total_out += u, s.total += u, u && (e.adler = s.check = s.flags ? this.crc32(s.check, i, u, n - u) : this.adler32(s.check, i, u, n - u)), u = l, (s.flags ? h : this.zswap32(h)) !== s.check) {
                                e.msg = "incorrect data check", s.mode = 30;
                                break
                            }
                            h = 0, c = 0
                        }
                        s.mode = 28;
                    case 28:
                        if (s.wrap && s.flags) {
                            for (; c < 32;) {
                                if (0 === o) break e;
                                o--, h += r[a++] << c, c += 8
                            }
                            if (h !== (4294967295 & s.total)) {
                                e.msg = "incorrect length check", s.mode = 30;
                                break
                            }
                            h = 0, c = 0
                        }
                        s.mode = 29;
                    case 29:
                        E = 1;
                        break e;
                    case 30:
                        E = -3;
                        break e;
                    case 31:
                        return -4;
                    default:
                        return -2
                }
                return e.next_out = n, e.avail_out = l, e.next_in = a, e.avail_in = o, s.hold = h, s.bits = c, (s.wsize || u !== e.avail_out && s.mode < 30 && (s.mode < 27 || 4 !== t)) && this.updatewindow(e, e.output, e.next_out, u - e.avail_out) ? (s.mode = 31, -4) : (d -= e.avail_in, u -= e.avail_out, e.total_in += d, e.total_out += u, s.total += u, s.wrap && u && (e.adler = s.check = s.flags ? this.crc32(s.check, i, u, e.next_out - u) : this.adler32(s.check, i, u, e.next_out - u)), e.data_type = s.bits + (s.last ? 64 : 0) + (12 === s.mode ? 128 : 0) + (20 === s.mode || 15 === s.mode ? 256 : 0), E = (0 == d && 0 === u || 4 === t) && 0 === E ? -5 : E)
            }
            binstring2buf(s) {
                var r = new Uint8Array(s.length);
                for (let e = 0, t = r.length; e < t; e++) r[e] = s.charCodeAt(e);
                return r
            }
            string2buf(e) {
                let t, s, r, i, a, n = e.length,
                    o = 0;
                for (i = 0; i < n; i++) 55296 == (64512 & (s = e.charCodeAt(i))) && i + 1 < n && 56320 == (64512 & (r = e.charCodeAt(i + 1))) && (s = 65536 + (s - 55296 << 10) + (r - 56320), i++), o += s < 128 ? 1 : s < 2048 ? 2 : s < 65536 ? 3 : 4;
                for (t = new Uint8Array(o), a = 0, i = 0; a < o; i++) 55296 == (64512 & (s = e.charCodeAt(i))) && i + 1 < n && 56320 == (64512 & (r = e.charCodeAt(i + 1))) && (s = 65536 + (s - 55296 << 10) + (r - 56320), i++), s < 128 ? t[a++] = s : (s < 2048 ? t[a++] = 192 | s >>> 6 : (s < 65536 ? t[a++] = 224 | s >>> 12 : (t[a++] = 240 | s >>> 18, t[a++] = 128 | s >>> 12 & 63), t[a++] = 128 | s >>> 6 & 63), t[a++] = 128 | 63 & s);
                return t
            }
            updatewindow(e, t, s, r) {
                let i, a = e.state;
                return null === a.window && (a.wsize = 1 << a.wbits, a.wnext = 0, a.whave = 0, a.window = new Uint8Array(a.wsize)), r >= a.wsize ? (this.arraySet(a.window, t, s - a.wsize, a.wsize, 0), a.wnext = 0, a.whave = a.wsize) : ((i = a.wsize - a.wnext) > r && (i = r), this.arraySet(a.window, t, s - r, i, a.wnext), (r -= i) ? (this.arraySet(a.window, t, s - r, r, 0), a.wnext = r, a.whave = a.wsize) : (a.wnext += i, a.wnext === a.wsize && (a.wnext = 0), a.whave < a.wsize && (a.whave += i))), 0
            }
            inflateSetDictionary(e, t) {
                var s, r = t.length;
                return !e || !e.state || 0 !== (s = e.state).wrap && 11 !== s.mode ? -2 : 11 === s.mode && this.adler32(1, t, r, 0) !== s.check ? -3 : this.updatewindow(e, t, r, r) ? (s.mode = 31, -4) : (s.havedict = 1, 0)
            }
            buf2binstring(t, s) {
                if (s < 65537 && (t.subarray && a || !t.subarray && e)) return String.fromCharCode.apply(null, this.shrinkBuf(t, s));
                let r = "";
                for (let e = 0; e < s; e++) r += String.fromCharCode(t[e]);
                return r
            }
            buf2string(e, t) {
                let s, r, i, a, n = t || e.length,
                    o = new Array(2 * n);
                for (r = 0, s = 0; s < n;)
                    if ((i = e[s++]) < 128) o[r++] = i;
                    else if (4 < (a = l[i])) o[r++] = 65533, s += a - 1;
                else {
                    for (i &= 2 === a ? 31 : 3 === a ? 15 : 7; 1 < a && s < n;) i = i << 6 | 63 & e[s++], a--;
                    1 < a ? o[r++] = 65533 : i < 65536 ? o[r++] = i : (i -= 65536, o[r++] = 55296 | i >> 10 & 1023, o[r++] = 56320 | 1023 & i)
                }
                return this.buf2binstring(o, r)
            }
            push(e, t) {
                let s, r, i, a, n, o, l = this.strm,
                    h = this.options.chunkSize,
                    c = this.options.dictionary,
                    d = !1;
                if (this.ended) return !1;
                r = t === ~~t ? t : !0 === t ? 4 : 0, "string" == typeof e ? l.input = this.binstring2buf(e) : "[object ArrayBuffer]" === toString.call(e) ? l.input = new Uint8Array(e) : l.input = e, l.next_in = 0, l.avail_in = l.input.length;
                do {
                    if (0 === l.avail_out && (l.output = new Uint8Array(h), l.next_out = 0, l.avail_out = h), 2 === (s = this.zlib_inflate(l, 0)) && c && (o = "string" == typeof c ? this.string2buf(c) : "[object ArrayBuffer]" === toString.call(c) ? new Uint8Array(c) : c, s = this.inflateSetDictionary(this.strm, o)), -5 === s && !0 === d && (s = 0, d = !1), 1 !== s && 0 !== s) return this.onEnd(s), !(this.ended = !0)
                } while (!l.next_out || 0 !== l.avail_out && 1 !== s && (0 !== l.avail_in || 4 !== r && 2 !== r) || ("string" === this.options.to ? (i = this.utf8border(l.output, l.next_out), a = l.next_out - i, n = this.buf2string(l.output, i), l.next_out = a, l.avail_out = h - a, a && this.arraySet(l.output, l.output, i, a, 0), this.onData(n)) : this.onData(this.shrinkBuf(l.output, l.next_out))), 0 === l.avail_in && 0 === l.avail_out && (d = !0), (0 < l.avail_in || 0 === l.avail_out) && 1 !== s);
                return 4 === (r = 1 === s ? 4 : r) ? (s = this.inflateEnd(this.strm), this.onEnd(s), this.ended = !0, 0 === s) : 2 !== r || (this.onEnd(0), !(l.avail_out = 0))
            }
            onData(e) {
                this.chunks.push(e)
            }
            utf8border(e, t) {
                let s;
                for ((t = t || e.length) > e.length && (t = e.length), s = t - 1; 0 <= s && 128 == (192 & e[s]);) s--;
                return !(s < 0 || 0 === s) && s + l[e[s]] > t ? s : t
            }
            inflateEnd(e) {
                var t;
                return e && e.state ? ((t = e.state).window && (t.window = null), e.state = null, 0) : -2
            }
            static inflate(e) {
                var t = new Jt(void 0);
                if (t.push(e, !0), t.err) throw t.msg || t.err;
                return t.result
            }
        }
        class V {
            static writeBits(t, s, r) {
                for (let e = 0; e < t.length; ++e) s[r + e >> 3] |= t[e] << 7 - (r + e & 7)
            }
            static addNTimes(t, s, r) {
                for (let e = 0; e < s; ++e) t.push(r)
            }
            static makeDiff(t) {
                var s = [];
                1 == t[0] && s.push(0, 1);
                for (let e = 1; e < t.length; e++) t[e - 1] != t[e] && s.push(e, t[e]);
                return s.push(t.length, 0, t.length, 1), s
            }
            static findDiff(t, s, r) {
                for (let e = 0; e < t.length; e += 2)
                    if (t[e] >= s && t[e + 1] == r) return t[e]
            }
            static copyTile(s, r, e, i, a, n, o, l) {
                for (let t = 0; t < e; t++)
                    for (let e = 0; e < r; e++) {
                        var h = o + e,
                            c = l + t;
                        h < a && c < n && (i[c * a + h] = s[t * r + e])
                    }
            }
            static readIFD(t, s, r, i) {
                const a = t.readUshort(s, r);
                r += 2;
                var n = {};
                i.push(n);
                for (let e = 0; e < a; e++) {
                    const i = t.readUshort(s, r),
                        a = (r += 2, t.readUshort(s, r));
                    r += 2;
                    var o = t.readUint(s, r),
                        l = (r += 4, t.readUint(s, r)),
                        h = (r += 4, n["t" + i] = []);
                    if (1 == a || 7 == a)
                        for (let e = 0; e < o; e++) h.push(s[(o < 5 ? r - 4 : l) + e]);
                    if (2 == a && h.push(t.readASCII(s, o < 5 ? r - 4 : l, o - 1)), 3 == a)
                        for (let e = 0; e < o; e++) h.push(t.readUshort(s, (o < 3 ? r - 4 : l) + 2 * e));
                    if (4 == a)
                        for (let e = 0; e < o; e++) h.push(t.readUint(s, (o < 2 ? r - 4 : l) + 4 * e));
                    if (5 == a)
                        for (let e = 0; e < o; e++) h.push(t.readUint(s, l + 8 * e) / t.readUint(s, l + 8 * e + 4));
                    0 == h.length && console.log("unknown TIFF tag type: ", a, "num:", o)
                }
                return r
            }
            static writeIFD(i, a, n, o) {
                var l = Object.keys(o);
                i.writeUshort(a, n, l.length);
                let h = (n += 2) + 12 * l.length + 4;
                for (let r = 0; r < l.length; r++) {
                    var c = l[r],
                        d = parseInt(c.slice(1)),
                        u = V.ttypes[d];
                    if (null == u) throw "unknown type of tag: " + d;
                    let t = o[c];
                    var p = (t = 2 == u ? t[0] + "\0" : t).length;
                    i.writeUshort(a, n, d), n += 2, i.writeUshort(a, n, u), n += 2, i.writeUint(a, n, p);
                    let e = [-1, 1, 1, 2, 4, 8][u] * p,
                        s = n += 4;
                    if (4 < e && (i.writeUint(a, n, h), s = h), 2 == u && i.writeASCII(a, s, t), 3 == u)
                        for (let e = 0; e < p; e++) i.writeUshort(a, s + 2 * e, t[e]);
                    if (4 == u)
                        for (let e = 0; e < p; e++) i.writeUint(a, s + 4 * e, t[e]);
                    if (5 == u)
                        for (let e = 0; e < p; e++) i.writeUint(a, s + 8 * e, Math.round(1e4 * t[e])), i.writeUint(a, s + 8 * e + 4, 1e4);
                    4 < e && (e += 1 & e, h += e), n += 4
                }
                return [n, h]
            }
            static decodeThunder(e, t, s, r, i) {
                const a = [0, 1, 0, -1],
                    n = [0, 1, 2, 3, 0, -3, -2, -1],
                    o = t + s;
                let l = 2 * i,
                    h = 0;
                for (; t < o;) {
                    const s = e[t],
                        i = s >> 6,
                        o = 63 & s;
                    if (t++, 3 == i && (h = 15 & o, r[l >> 1] |= h << 4 * (1 - l & 1), l++), 0 == i)
                        for (let e = 0; e < o; e++) r[l >> 1] |= h << 4 * (1 - l & 1), l++;
                    if (2 == i)
                        for (let e = 0; e < 2; e++) {
                            const t = o >> 3 * (1 - e) & 7;
                            4 != t && (h += n[t], r[l >> 1] |= h << 4 * (1 - l & 1), l++)
                        }
                    if (1 == i)
                        for (let e = 0; e < 3; e++) {
                            const t = o >> 2 * (2 - e) & 3;
                            2 != t && (h += a[t], r[l >> 1] |= h << 4 * (1 - l & 1), l++)
                        }
                }
            }
            static decodePackBits(t, s, e, r, i) {
                for (var a = new Int8Array(t.buffer), n = new Int8Array(r.buffer), o = s + e; s < o;) {
                    const t = a[s];
                    if (s++, 0 <= t && t < 128)
                        for (let e = 0; e < t + 1; e++) n[i] = a[s], i++, s++;
                    if (-127 <= t && t < 0) {
                        for (let e = 0; e < 1 - t; e++) n[i] = a[s], i++;
                        s++
                    }
                }
            }
            static decodeLZW(t, e, s, r) {
                let i = [],
                    a = 9,
                    n = e << 3,
                    o, l = 0,
                    h = 0;
                for (;;) {
                    if (o = t[n >> 3] << 16 | t[n + 8 >> 3] << 8 | t[n + 16 >> 3], l = o >> 24 - (7 & n) - a & (1 << a) - 1, n += a, 0 == i.length && 256 != l) return void console.log("Error in LZW");
                    if (257 == l) break;
                    if (256 == l) {
                        a = 9, i = [];
                        for (let e = 0; e < 258; e++) i[e] = [e];
                        if (o = t[n >> 3] << 16 | t[n + 8 >> 3] << 8 | t[n + 16 >> 3], l = o >> 24 - (7 & n) - a & (1 << a) - 1, n += a, 257 == l) break;
                        for (let e = 0; e < i[l].length; e++) s[r + e] = i[l][e];
                        r += i[l].length
                    } else {
                        if (l < i.length) {
                            for (let e = 0; e < i[l].length; e++) s[r + e] = i[l][e];
                            r += i[l].length;
                            const t = null == i[h] ? [] : i[h].slice(0);
                            t.push(i[l][0]), i.push(t)
                        } else {
                            const t = null == i[h] ? [] : i[h].slice(0);
                            t.push(t[0]);
                            for (let e = 0; e < t.length; e++) s[r + e] = t[e];
                            r += t.length, i.push(t)
                        }
                        i.length + 1 == 1 << a && a++
                    }
                    h = l
                }
            }
            static endsWith(e, t) {
                return e.slice(-t.length) === t
            }
            static decodeG3(t, e, s, r, i, a, n) {
                let o = e << 3,
                    l = 0,
                    h = "",
                    c = [],
                    d = [];
                for (let e = 0; e < a; e++) c.push(0);
                let u = 0,
                    p, m, g, _ = 0,
                    f = -1,
                    v = "",
                    b = 0,
                    x = !1;
                for (; o >> 3 < e + s;) {
                    m = V.findDiff(d, u + (0 == u ? 0 : 1), 1 - _), g = V.findDiff(d, m, _);
                    let e = 0;
                    if (1 == n && (e = t[o >> 3] >> 7 - (7 & o) & 1), 2 == n && (e = t[o >> 3] >> (7 & o) & 1), o++, h += e, x) {
                        if (null != V._lens[_][h]) {
                            const t = V._lens[_][h];
                            h = "", l += t, t < 64 && (V.addNTimes(c, l, _), _ = 1 - _, l = 0)
                        }
                    } else if ("H" == v) {
                        if (null != V._lens[_][h]) {
                            const t = V._lens[_][h];
                            h = "", l += t, t < 64 && (V.addNTimes(c, l, _), u += l, _ = 1 - _, (l = 0) == --b) && (v = "")
                        }
                    } else "0001" == h && (h = "", V.addNTimes(c, g - u, _), u = g), "001" == h && (h = "", v = "H", b = 2), null != V._dmap[h] && (p = m + V._dmap[h], V.addNTimes(c, p - u, _), u = p, h = "", _ = 1 - _);
                    V.endsWith(h, "000000000001") && (0 <= f && V.writeBits(c, r, 8 * i + f * a), 1 == n && (x = 1 == (t[o >> 3] >> 7 - (7 & o) & 1)), 2 == n && (x = 1 == (t[o >> 3] >> (7 & o) & 1)), o++, null == V._G3Allow2D && (V._G3Allow2D = x), V._G3Allow2D || (x = !0, o--), h = "", _ = 0, f++, u = 0, d = V.makeDiff(c), c = [])
                }
                c.length == a && V.writeBits(c, r, 8 * i + f * a)
            }
            static decodeG4(t, e, s, r, i, a, n) {
                let o = e << 3,
                    l = 0,
                    h = "",
                    c = [],
                    d = [];
                for (let e = 0; e < a; e++) d.push(0);
                d = V.makeDiff(d);
                let u = 0,
                    p, m, g, _ = 0,
                    f = 0,
                    v = "",
                    b = 0;
                for (; o >> 3 < e + s;) {
                    m = V.findDiff(d, u + (0 == u ? 0 : 1), 1 - _), g = V.findDiff(d, m, _);
                    let e = 0;
                    if (1 == n && (e = t[o >> 3] >> 7 - (7 & o) & 1), 2 == n && (e = t[o >> 3] >> (7 & o) & 1), o++, h += e, "H" == v) {
                        if (null != V._lens[_][h]) {
                            const t = V._lens[_][h];
                            h = "", l += t, t < 64 && (V.addNTimes(c, l, _), u += l, _ = 1 - _, (l = 0) == --b) && (v = "")
                        }
                    } else "0001" == h && (h = "", V.addNTimes(c, g - u, _), u = g), "001" == h && (h = "", v = "H", b = 2), null != V._dmap[h] && (p = m + V._dmap[h], V.addNTimes(c, p - u, _), u = p, h = "", _ = 1 - _);
                    c.length == a && "" == v && (V.writeBits(c, r, 8 * i + f * a), _ = 0, f++, u = 0, d = V.makeDiff(c), c = [])
                }
            }
            static decompress(e, t, s, r, i, a, n, o) {
                if (1 == i)
                    for (let e = 0; e < r; e++) a[n + e] = t[s + e];
                else if (3 == i) V.decodeG3(t, s, r, a, n, e.width, o);
                else if (4 == i) V.decodeG4(t, s, r, a, n, e.width, o);
                else if (5 == i) V.decodeLZW(t, s, a, n);
                else if (8 == i) {
                    const e = new Uint8Array(t.buffer, s, r),
                        i = Jt.inflate(e);
                    for (let e = 0; e < i.length; e++) a[n + e] = i[e]
                } else 32773 == i ? V.decodePackBits(t, s, r, a, n) : 32809 == i ? V.decodeThunder(t, s, r, a, n) : console.log("Unknown compression", i);
                if (e.t317 && 2 == e.t317[0]) {
                    const t = e.t277 ? e.t277[0] : 1,
                        s = e.t278 ? e.t278[0] : e.height,
                        r = e.width * t;
                    for (let e = 0; e < s; e++) {
                        const s = n + e * r;
                        for (let e = t; e < r; ++e) a[s + e] = a[s + e] + a[s + e - t] & 255
                    }
                }
            }
            static decode(i) {
                V._G3Allow2D = null;
                var a = new Uint8Array(i);
                let n = 0;
                const o = V._binBE.readASCII(a, n, 2),
                    l = (n += 2, V._binBE.ui32 = new Uint32Array(V._binBE.ui8.buffer), "II" == o ? V._binLE : V._binBE);
                l.readUshort(a, n), n += 2;
                let h = l.readUint(a, n),
                    c = (n += 4, []);
                for (;;) {
                    const i = V.readIFD(l, a, h, c);
                    if (0 == (h = l.readUint(a, i))) break
                }
                if (null != c[0].t256)
                    for (let e = 0; e < c.length; e++) {
                        const n = c[e],
                            o = (n.width = n.t256[0], delete n.t256, n.height = n.t257[0], delete n.t257, n.t259[0]),
                            l = (delete n.t259, n.t266 ? n.t266[0] : 1),
                            h = (delete n.t266, n.t284 && 2 == n.t284[0] && console.log("PlanarConriguration 2 should not be used!"), (n.t258 ? n.t258[0] : 1) * (n.t277 ? n.t277[0] : 1));
                        let s = n.t273,
                            r = (null == s && (s = n.t324), n.t279);
                        null == (r = 1 == o && 1 == s.length ? [n.height * n.width * h >> 3] : r) && (r = n.t325);
                        var d = new Uint8Array(n.width * n.height * h >> 3);
                        let t = 0;
                        if (null != n.t322) {
                            const i = n.t322[0],
                                c = n.t323[0],
                                m = Math.floor((n.width + i - 1) / i),
                                g = Math.floor((n.height + c - 1) / c),
                                _ = new Uint8Array(i * c * h >> 3);
                            for (let t = 0; t < g; t++)
                                for (let e = 0; e < m; e++) {
                                    var u = t * m + e;
                                    for (let e = 0; e < _.length; e++) _[e] = 0;
                                    V.decompress(n, a, s[u], r[u], o, _, 0, l), V.copyTile(_, i * h >> 3, c, d, n.width * h >> 3, n.height, e * i * h >> 3, t * c)
                                }
                            t = d.length << 3
                        } else {
                            var p = n.t278 ? n.t278[0] : n.height,
                                p = Math.min(p, n.height);
                            for (let e = 0; e < s.length; e++) V.decompress(n, a, s[e], r[e], o, d, t >> 3, l), t += n.width * h * p;
                            t = Math.min(t, d.length << 3)
                        }
                        n.data = new Uint8Array(d.buffer, 0, t >> 3)
                    }
                return c
            }
            static toRGBA8(e) {
                const t = e.width * e.height,
                    s = 4 * t,
                    r = e.data,
                    i = new Uint8Array(4 * t),
                    a = e.t262[0],
                    n = e.t258 ? e.t258[0] : 1;
                if (0 == a) {
                    if (1 == n)
                        for (let e = 0; e < t; e++) {
                            const t = e << 2,
                                s = r[e >> 3] >> 7 - (7 & e) & 1;
                            i[t] = i[1 + t] = i[2 + t] = 255 * (1 - s), i[3 + t] = 255
                        }
                    if (4 == n)
                        for (let e = 0; e < t; e++) {
                            const t = e << 2,
                                s = r[e >> 1] >> 4 - 4 * (1 & e) & 15;
                            i[t] = i[1 + t] = i[2 + t] = 17 * (15 - s), i[3 + t] = 255
                        }
                    if (8 == n)
                        for (let e = 0; e < t; e++) {
                            const t = e << 2,
                                s = r[e];
                            i[t] = i[1 + t] = i[2 + t] = 255 - s, i[3 + t] = 255
                        }
                }
                if (1 == a) {
                    if (1 == n)
                        for (let e = 0; e < t; e++) {
                            const t = e << 2,
                                s = r[e >> 3] >> 7 - (7 & e) & 1;
                            i[t] = i[1 + t] = i[2 + t] = 255 * s, i[3 + t] = 255
                        }
                    if (2 == n)
                        for (let e = 0; e < t; e++) {
                            const t = e << 2,
                                s = r[e >> 2] >> 6 - 2 * (3 & e) & 3;
                            i[t] = i[1 + t] = i[2 + t] = 85 * s, i[3 + t] = 255
                        }
                    if (8 == n)
                        for (let e = 0; e < t; e++) {
                            const t = e << 2,
                                s = r[e];
                            i[t] = i[1 + t] = i[2 + t] = s, i[3 + t] = 255
                        }
                    if (16 == n)
                        for (let e = 0; e < t; e++) {
                            const t = e << 2,
                                s = Math.max(0, r[2 * e + 1] - 5) << 8 | r[2 * e];
                            i[t] = i[1 + t] = i[2 + t] = Math.min(255, s), i[3 + t] = 255
                        }
                }
                if (2 == a)
                    if (8 == n)
                        if (e.t338)
                            if (1 == e.t338[0])
                                for (let e = 0; e < s; e++) i[e] = r[e];
                            else
                                for (let e = 0; e < s; e += 4) i[e] = r[e], i[e + 1] = r[e + 1], i[e + 2] = r[e + 2], i[e + 3] = 255;
                else {
                    const a = e.t258 ? e.t258.length : 3;
                    if (4 == a)
                        for (let e = 0; e < s; e++) i[e] = r[e];
                    if (3 == a)
                        for (let e = 0; e < t; e++) {
                            const t = e << 2,
                                s = 3 * e;
                            i[t] = r[s], i[1 + t] = r[1 + s], i[2 + t] = r[2 + s], i[3 + t] = 255
                        }
                } else
                    for (let e = 0; e < t; e++) {
                        const t = e << 2,
                            s = 6 * e;
                        i[t] = r[s], i[1 + t] = r[2 + s], i[2 + t] = r[4 + s], i[3 + t] = 255
                    }
                if (3 == a) {
                    const s = e.t320;
                    for (let e = 0; e < t; e++) {
                        const t = e << 2,
                            a = r[e];
                        i[t] = s[a] >> 8, i[1 + t] = s[256 + a] >> 8, i[2 + t] = s[512 + a] >> 8, i[3 + t] = 255
                    }
                }
                if (5 == a)
                    for (let e = 0; e < t; e++) {
                        const t = e << 2,
                            s = 255 - r[t],
                            a = 255 - r[1 + t],
                            n = 255 - r[2 + t],
                            o = (255 - r[3 + t]) * (1 / 255);
                        i[t] = Math.round(s * o), i[1 + t] = Math.round(a * o), i[2 + t] = Math.round(n * o), i[3 + t] = 255
                    }
                return i
            }
            static encodeImage(t, e, s) {
                var r = {
                        t256: [e],
                        t257: [s],
                        t258: [8, 8, 8, 8],
                        t259: [1],
                        t262: [2],
                        t273: [1e3],
                        t277: [4],
                        t278: [s],
                        t279: [e * s * 4],
                        t282: [1],
                        t283: [1],
                        t284: [1],
                        t286: [0],
                        t287: [0],
                        t296: [1],
                        t305: ["ImagePlayground"],
                        t338: [1]
                    },
                    i = new Uint8Array(V.encode([r])),
                    a = new Uint8Array(1e3 + e * s * 4);
                for (let e = 0; e < i.length; e++) a[e] = i[e];
                for (let e = 0; e < t.length; e++) a[1e3 + e] = t[e];
                return a.buffer
            }
            static encode(t) {
                var s = new Uint8Array(2e4),
                    r = V._binBE;
                s[0] = 77, s[1] = 77, s[3] = 42;
                let i = 8;
                r.writeUint(s, 4, i);
                for (let e = 0; e < t.length; e++) {
                    var a = V.writeIFD(r, s, i, t[e]);
                    i = a[1], e < t.length - 1 && r.writeUint(s, a[0], i)
                }
                return s.slice(0, i).buffer
            }
        }

        function de(t, s, r, i) {
            for (let e = 0; e < s.length; e++) t[s[e]] = r + e * i
        }
        V._G3Allow2D = null, V._dmap = {
            1: 0,
            "011": 1,
            "000011": 2,
            "0000011": 3,
            "010": -1,
            "000010": -2,
            "0000010": -3
        }, V._binBE = {
            nextZero: function(e, t) {
                for (; 0 != e[t];) t++;
                return t
            },
            readUshort: function(e, t) {
                return e[t] << 8 | e[t + 1]
            },
            readUint: function(e, t) {
                var s = V._binBE.ui8;
                return s[0] = e[t + 3], s[1] = e[t + 2], s[2] = e[t + 1], s[3] = e[t], V._binBE.ui32[0]
            },
            readASCII: function(t, s, r) {
                let i = "";
                for (let e = 0; e < r; e++) i += String.fromCharCode(t[s + e]);
                return i
            },
            ui8: new Uint8Array(4),
            ui32: new Uint32Array(0),
            writeUshort: function(e, t, s) {
                e[t] = s >> 8 & 255, e[t + 1] = 255 & s
            },
            writeUint: function(e, t, s) {
                e[t] = s >> 24 & 255, e[t + 1] = s >> 16 & 255, e[t + 2] = s >> 8 & 255, e[t + 3] = s >> 0 & 255
            },
            writeASCII: function(t, s, r) {
                for (let e = 0; e < r.length; e++) t[s + e] = r.charCodeAt(e)
            }
        }, V._binLE = {
            nextZero: V._binBE.nextZero,
            readUshort: function(e, t) {
                return e[t + 1] << 8 | e[t]
            },
            readUint: function(e, t) {
                return e[t + 3] << 24 | e[t + 2] << 16 | e[t + 1] << 8 | e[t]
            },
            readASCII: V._binBE.readASCII
        }, V.tags = {
            254: "NewSubfileType",
            255: "SubfileType",
            256: "ImageWidth",
            257: "ImageLength",
            258: "BitsPerSample",
            259: "Compression",
            262: "PhotometricInterpretation",
            266: "FillOrder",
            269: "DocumentName",
            270: "ImageDescription",
            271: "Make",
            272: "Model",
            273: "StripOffset",
            274: "Orientation",
            277: "SamplesPerPixel",
            278: "RowsPerStrip",
            279: "StripByteCounts",
            280: "MinSampleValue",
            281: "MaxSampleValue",
            282: "XResolution",
            283: "YResolution",
            284: "PlanarConfiguration",
            286: "XPosition",
            287: "YPosition",
            292: "T4Options",
            296: "ResolutionUnit",
            297: "PageNumber",
            305: "Software",
            306: "DateTime",
            315: "Artist",
            317: "Predictor",
            320: "ColorMap",
            321: "HalftoneHints",
            322: "TileWidth",
            323: "TileLength",
            324: "TileOffset",
            325: "TileByteCounts",
            336: "DotRange",
            338: "ExtraSample",
            339: "SampleFormat",
            512: "JPEGProc",
            513: "JPEGInterchangeFormat",
            514: "JPEGInterchangeFormatLength",
            519: "JPEGQTables",
            520: "JPEGDCTables",
            521: "JPEGACTables",
            529: "YCbCrCoefficients",
            530: "YCbCrSubSampling",
            531: "YCbCrPositioning",
            532: "ReferenceBlackWhite",
            33432: "Copyright",
            34377: "Photoshop"
        }, V.ttypes = {
            256: 3,
            257: 3,
            258: 3,
            259: 3,
            262: 3,
            273: 4,
            274: 3,
            277: 3,
            278: 4,
            279: 4,
            282: 5,
            283: 5,
            284: 3,
            286: 5,
            287: 5,
            296: 3,
            305: 2,
            306: 2,
            338: 3,
            513: 4,
            514: 4,
            34665: 4
        }, V._lens = (t = "00110101,000111,0111,1000,1011,1100,1110,1111,10011,10100,00111,01000,001000,000011,110100,110101,101010,101011,0100111,0001100,0001000,0010111,0000011,0000100,0101000,0101011,0010011,0100100,0011000,00000010,00000011,00011010,00011011,00010010,00010011,00010100,00010101,00010110,00010111,00101000,00101001,00101010,00101011,00101100,00101101,00000100,00000101,00001010,00001011,01010010,01010011,01010100,01010101,00100100,00100101,01011000,01011001,01011010,01011011,01001010,01001011,00110010,00110011,00110100".split(","), ie = "0000110111,010,11,10,011,0011,0010,00011,000101,000100,0000100,0000101,0000111,00000100,00000111,000011000,0000010111,0000011000,0000001000,00001100111,00001101000,00001101100,00000110111,00000101000,00000010111,00000011000,000011001010,000011001011,000011001100,000011001101,000001101000,000001101001,000001101010,000001101011,000011010010,000011010011,000011010100,000011010101,000011010110,000011010111,000001101100,000001101101,000011011010,000011011011,000001010100,000001010101,000001010110,000001010111,000001100100,000001100101,000001010010,000001010011,000000100100,000000110111,000000111000,000000100111,000000101000,000001011000,000001011001,000000101011,000000101100,000001011010,000001100110,000001100111".split(","), j = "11011,10010,010111,0110111,00110110,00110111,01100100,01100101,01101000,01100111,011001100,011001101,011010010,011010011,011010100,011010101,011010110,011010111,011011000,011011001,011011010,011011011,010011000,010011001,010011010,011000,010011011".split(","), ae = "0000001111,000011001000,000011001001,000001011011,000000110011,000000110100,000000110101,0000001101100,0000001101101,0000001001010,0000001001011,0000001001100,0000001001101,0000001110010,0000001110011,0000001110100,0000001110101,0000001110110,0000001110111,0000001010010,0000001010011,0000001010100,0000001010101,0000001011010,0000001011011,0000001100100,0000001100101".split(","), ne = "00000001000,00000001100,00000001101,000000010010,000000010011,000000010100,000000010101,000000010110,000000010111,000000011100,000000011101,000000011110,000000011111".split(","), le = {}, de(oe = {}, t, 0, 1), de(oe, j, 64, 64), de(oe, ne, 1792, 64), de(le, ie, 0, 1), de(le, ae, 64, 64), de(le, ne, 1792, 64), [oe, le]);
        class Qt extends Yt {
            constructor() {
                super(Qt.ID), this._label = ".tif", this._type = "tiff", this._infoText = "\n\t\t\t<p>TIFF [<b>T</b>ag(ged) <b>I</b>mage <b>F</b>ile <b>F</b>ormat] is an old image format that loses its popularity over time.</p>\n\t\t\t<p>It's a superset of 12 distinct formats, and only very few programs support all of them.</p>\n\t\t\t<p>ImagePlayground can import all kinds of TIFF, but it can export it only in an uncompressed way with 24 bit (16.7 M) color plus 8 bit for the alpha (transparency) channel (a sum of 32 bit).</p>\n\t\t\t<p>Unless you specifically need to save your image as TIFF, we don't recommend using this format, because it doesn't have any real advantages over PNG.</p>\n\t\t\t"
            }
            async
            export (e) {
                var t = e.readPixels(!0, !0, !0),
                    s = e.width,
                    e = e.height;
                return V.encodeImage(t, s, e)
            }
        }
        Qt.ID = "tif";
        class es extends Yt {
            constructor() {
                super(es.ID), this._tga = [], this._isTransparent = !1, this._isCompressed = !1, this._infoText = "\n\t\t\t<p>TARGA [<b>T</b>ruevision <b>A</b>dvanced <b>R</b>aster <b>G</b>raphics <b>A</b>dapter, or TGA for short] is a relatively old format with optional lossless compression.</p>\n\t\t\t<p>It supports 24 bit (16.7 M) color plus 8 bit for the alpha (transparency) channel (a sum of 32 bit).</p>\n\t\t\t<p>Typically, TGAs are used as textures, but its popularity lessens over time.</p>\n\t\t\t<p>Unless you specifically need to save your image as TGA, we don't recommend using it, because it doesn't have any real advantages over PNG.</p>\n\t\t\t"
            }
            numToByteArray(t, e = !1) {
                let s = [0, 0];
                e && (s = [0, 0, 0, 0]);
                for (let e = 0; e < s.length; ++e) {
                    var r = 255 & t;
                    t = (t - (s[e] = r)) / 256
                }
                return s
            }
            writeHeader(e, t) {
                var s = this._isCompressed ? 10 : 2,
                    s = (this._tga.push(0), this._tga.push(0), this._tga.push(s), this._tga.push(0), this._tga.push(0), this._tga.push(0), this._tga.push(0), this._tga.push(0), this._tga.push(0), this._tga.push(0), this._tga.push(0), this._tga.push(0), this.numToByteArray(e)),
                    e = (this._tga.push(s[0]), this._tga.push(s[1]), this.numToByteArray(t)),
                    s = (this._tga.push(e[0]), this._tga.push(e[1]), this._isTransparent ? 32 : 24),
                    t = (this._tga.push(s), this._isTransparent ? 8 : 0);
                this._tga.push(t)
            }
            writePixelData(t, s, r) {
                var i = this._isTransparent ? 4 : 3;
                let a = 0;
                for (let e = 0; e < s; ++e)
                    for (let e = 0; e < t; ++e) this._tga.push(r[a + 2]), this._tga.push(r[a + 1]), this._tga.push(r[a]), this._isTransparent && this._tga.push(r[a + 3]), a += i
            }
            memcmp(t, s, r, i, a) {
                for (let e = 0; e < r; ++e) {
                    if (t[i + e] < s[a + e]) return -1;
                    if (t[i + e] > s[a + e]) return 1
                }
                return 0
            }
            writeCompressedData(o, t, s) {
                let l = 0,
                    h = this._isTransparent ? 4 : 3;
                for (let e = 0; e < t; ++e) {
                    let i = s,
                        a = 0 + e * o * h,
                        n = 1;
                    for (let r = 0; r < o; r += n) {
                        let t = i,
                            s = a + r * h,
                            e = 1;
                        if (n = 1, r < o - 1)
                            if (++n, e = this.memcmp(t, i, h, r * h, a + (r + 1) * h)) {
                                var c = t;
                                for (let e = r + 2; e < o && n < 128; ++e) {
                                    if (!this.memcmp(c, i, h, 0, a + e * h)) {
                                        --n;
                                        break
                                    }
                                    l += h, ++n
                                }
                            } else
                                for (let e = r + 2; e < o && n < 128 && !this.memcmp(t, i, h, s, a + e * h); ++e) ++n;
                        if (e) {
                            var d = n - 1 & 255;
                            this._tga.push(d);
                            for (let e = 0; e < n; ++e) this._tga.push(t[s + e * h + 2]), this._tga.push(t[s + e * h + 1]), this._tga.push(t[s + e * h]), this._isTransparent && this._tga.push(t[s + e * h + 3])
                        } else {
                            d = n - 129 & 255;
                            this._tga.push(d), this._tga.push(t[2 + s]), this._tga.push(t[1 + s]), this._tga.push(t[s]), this._isTransparent && this._tga.push(t[3 + s])
                        }
                    }
                }
            }
            writeTga(e, t, s) {
                this._tga.length = 0, this.writeHeader(e, t), this._isCompressed ? this.writeCompressedData(e, t, s) : this.writePixelData(e, t, s)
            }
            async
            export (e, t) {
                this._isTransparent = "32bit" === t.bpp, this._isCompressed = t.compression;
                var t = e.readPixels(this._isTransparent, this._isTransparent),
                    s = e.width,
                    e = e.height,
                    r = (this.writeTga(s, e, t), new Uint8Array(this._tga.length));
                for (let e = 0; e < r.length; ++e) r[e] = this._tga[e];
                return r
            }
        }
        es.ID = "tga";
        class ts {
            constructor(e, t, s) {
                this._alphadec = 0, this._netsize = 256, this._prime1 = 499, this._prime2 = 491, this._prime3 = 487, this._prime4 = 503, this._minpicturebytes = 3 * this._prime4, this._maxnetpos = this._netsize - 1, this._netbiasshift = 4, this._ncycles = 100, this._intbiasshift = 16, this._intbias = 1 << this._intbiasshift, this._gammashift = 10, this._gamma = 1 << this._gammashift, this._betashift = 10, this._beta = this._intbias >> this._betashift, this._betagamma = this._intbias << this._gammashift - this._betashift, this._initrad = this._netsize >> 3, this._radiusbiasshift = 6, this._radiusbias = 1 << this._radiusbiasshift, this._initradius = this._initrad * this._radiusbias, this._radiusdec = 30, this._alphabiasshift = 10, this._initalpha = 1 << this._alphabiasshift, this._radbiasshift = 8, this._radbias = 1 << this._radbiasshift, this._alpharadbshift = this._alphabiasshift + this._radbiasshift, this._alpharadbias = 1 << this._alpharadbshift, this._netindex = [], this._bias = [], this._freq = [], this._radpower = [], this._thepicture = e, this._lengthcount = t, this._samplefac = s, this._network = new Array(this._netsize);
                for (let e = 0; e < this._netsize; e++) {
                    this._network[e] = new Array(4);
                    const t = this._network[e];
                    t[0] = t[1] = t[2] = (e << this._netbiasshift + 8) / this._netsize, this._freq[e] = this._intbias / this._netsize, this._bias[e] = 0
                }
            }
            map(e, t, s) {
                let r, i, a, n, o, l, h;
                for (o = 1e3, h = -1, r = this._netindex[t], i = r - 1; r < this._netsize || 0 <= i;) r < this._netsize && (l = this._network[r], (a = l[1] - t) >= o ? r = this._netsize : (r++, a < 0 && (a = -a), (n = l[0] - e) < 0 && (n = -n), (a += n) < o && ((n = l[2] - s) < 0 && (n = -n), (a += n) < o) && (o = a, h = l[3]))), 0 <= i && (l = this._network[i], (a = t - l[1]) >= o ? i = -1 : (i--, a < 0 && (a = -a), (n = l[0] - e) < 0 && (n = -n), (a += n) < o && ((n = l[2] - s) < 0 && (n = -n), (a += n) < o) && (o = a, h = l[3])));
                return h
            }
            alterNeigh(e, t, s, r, i) {
                let a, n, o, l, h, c, d;
                for ((o = t - e) < -1 && (o = -1), (l = t + e) > this._netsize && (l = this._netsize), a = t + 1, n = t - 1, c = 1; a < l || n > o;) {
                    if (h = this._radpower[c++], a < l) {
                        d = this._network[a++];
                        try {
                            d[0] -= h * (d[0] - s) / this._alpharadbias, d[1] -= h * (d[1] - r) / this._alpharadbias, d[2] -= h * (d[2] - i) / this._alpharadbias
                        } catch (e) {}
                    }
                    if (n > o) {
                        d = this._network[n--];
                        try {
                            d[0] -= h * (d[0] - s) / this._alpharadbias, d[1] -= h * (d[1] - r) / this._alpharadbias, d[2] -= h * (d[2] - i) / this._alpharadbias
                        } catch (e) {}
                    }
                }
            }
            alterSingle(e, t, s, r, i) {
                t = this._network[t];
                t[0] -= e * (t[0] - s) / this._initalpha, t[1] -= e * (t[1] - r) / this._initalpha, t[2] -= e * (t[2] - i) / this._initalpha
            }
            contest(e, t, s) {
                let r, i, a, n, o, l, h, c, d, u;
                for (c = ~(1 << 31), d = c, l = -1, h = l, r = 0; r < this._netsize; r++) u = this._network[r], (i = u[0] - e) < 0 && (i = -i), (a = u[1] - t) < 0 && (a = -a), i += a, (a = u[2] - s) < 0 && (a = -a), (i += a) < c && (c = i, l = r), (n = i - (this._bias[r] >> this._intbiasshift - this._netbiasshift)) < d && (d = n, h = r), o = this._freq[r] >> this._betashift, this._freq[r] -= o, this._bias[r] += o << this._gammashift;
                return this._freq[l] += this._beta, this._bias[l] -= this._betagamma, h
            }
            learn() {
                let e, t, s, r, i, a, n, o, l, h, c, d, u, p;
                for (this._lengthcount < this._minpicturebytes && (this._samplefac = 1), this._alphadec = 30 + (this._samplefac - 1) / 3, d = this._thepicture, u = 0, p = this._lengthcount, c = this._lengthcount / (3 * this._samplefac), h = c / this._ncycles | 0, o = this._initalpha, a = this._initradius, (n = a >> this._radiusbiasshift) <= 1 && (n = 0), e = 0; e < n; e++) this._radpower[e] = o * ((n * n - e * e) * this._radbias / (n * n));
                for (l = this._lengthcount < this._minpicturebytes ? 3 : this._lengthcount % this._prime1 != 0 ? 3 * this._prime1 : this._lengthcount % this._prime2 != 0 ? 3 * this._prime2 : this._lengthcount % this._prime3 != 0 ? 3 * this._prime3 : 3 * this._prime4, e = 0; e < c;)
                    if (s = (255 & d[u + 0]) << this._netbiasshift, r = (255 & d[u + 1]) << this._netbiasshift, i = (255 & d[u + 2]) << this._netbiasshift, t = this.contest(s, r, i), this.alterSingle(o, t, s, r, i), 0 !== n && this.alterNeigh(n, t, s, r, i), (u += l) >= p && (u -= this._lengthcount), e++, 0 === h && (h = 1), e % h == 0)
                        for (o -= o / this._alphadec, a -= a / this._radiusdec, (n = a >> this._radiusbiasshift) <= 1 && (n = 0), t = 0; t < n; t++) this._radpower[t] = o * ((n * n - t * t) * this._radbias / (n * n))
            }
            unBiasNet() {
                for (let e = 0; e < this._netsize; e++) this._network[e][0] >>= this._netbiasshift, this._network[e][1] >>= this._netbiasshift, this._network[e][2] >>= this._netbiasshift, this._network[e][3] = e
            }
            inxBuild() {
                let e, t, s, r, i, a, n, o;
                for (n = 0, o = 0, e = 0; e < this._netsize; e++) {
                    for (i = this._network[e], s = e, r = i[1], t = e + 1; t < this._netsize; t++)(a = this._network[t])[1] < r && (s = t, r = a[1]);
                    if (a = this._network[s], e != s && (t = a[0], a[0] = i[0], i[0] = t, t = a[1], a[1] = i[1], i[1] = t, t = a[2], a[2] = i[2], i[2] = t, t = a[3], a[3] = i[3], i[3] = t), r != n) {
                        for (this._netindex[n] = o + e >> 1, t = n + 1; t < r; t++) this._netindex[t] = e;
                        n = r, o = e
                    }
                }
                for (this._netindex[n] = o + this._maxnetpos >> 1, t = n + 1; t < 256; t++) this._netindex[t] = this._maxnetpos
            }
            colorMap() {
                var t = [],
                    s = new Array(this._netsize);
                for (let e = 0; e < this._netsize; ++e) s[this._network[e][3]] = e;
                let r = 0;
                for (let e = 0; e < this._netsize; ++e) {
                    var i = s[e];
                    t[r++] = this._network[i][0], t[r++] = this._network[i][1], t[r++] = this._network[i][2]
                }
                return t
            }
            process() {
                return this.learn(), this.unBiasNet(), this.inxBuild(), this.colorMap()
            }
        }
        class ss {
            constructor(e, s, t, r) {
                this._buffer = e, this._byteCount = 0;
                e = (this._opts = r).loop;
                if (this._globalPalette = r.palette || null, s <= 0 || t <= 0 || 65535 < s || 65535 < t) throw "Width/Height invalid.";
                this._buffer[this._byteCount++] = 71, this._buffer[this._byteCount++] = 73, this._buffer[this._byteCount++] = 70, this._buffer[this._byteCount++] = 56, this._buffer[this._byteCount++] = 57, this._buffer[this._byteCount++] = 97;
                let i = 0,
                    a = 0;
                if (null !== this._globalPalette) {
                    let e = this.checkPaletteAndNumColors(this._globalPalette);
                    for (; e >>= 1;) ++i;
                    if (e = 1 << i, --i, void 0 !== r.background) {
                        if ((a = r.background) >= e) throw "Background index out of range.";
                        if (0 === a) throw "Background index explicitly passed as 0."
                    }
                }
                if (this._buffer[this._byteCount++] = 255 & s, this._buffer[this._byteCount++] = s >> 8 & 255, this._buffer[this._byteCount++] = 255 & t, this._buffer[this._byteCount++] = t >> 8 & 255, this._buffer[this._byteCount++] = (null !== this._globalPalette ? 128 : 0) | i, this._buffer[this._byteCount++] = a, this._buffer[this._byteCount++] = 0, null !== this._globalPalette)
                    for (let e = 0, t = this._globalPalette.length; e < t; ++e) {
                        const s = this._globalPalette[e];
                        this._buffer[this._byteCount++] = s >> 16 & 255, this._buffer[this._byteCount++] = s >> 8 & 255, this._buffer[this._byteCount++] = 255 & s
                    }
                if (null !== e) {
                    if (e < 0 || 65535 < e) throw "Loop count invalid.";
                    this._buffer[this._byteCount++] = 33, this._buffer[this._byteCount++] = 255, this._buffer[this._byteCount++] = 11, this._buffer[this._byteCount++] = 78, this._buffer[this._byteCount++] = 69, this._buffer[this._byteCount++] = 84, this._buffer[this._byteCount++] = 83, this._buffer[this._byteCount++] = 67, this._buffer[this._byteCount++] = 65, this._buffer[this._byteCount++] = 80, this._buffer[this._byteCount++] = 69, this._buffer[this._byteCount++] = 50, this._buffer[this._byteCount++] = 46, this._buffer[this._byteCount++] = 48, this._buffer[this._byteCount++] = 3, this._buffer[this._byteCount++] = 1, this._buffer[this._byteCount++] = 255 & e, this._buffer[this._byteCount++] = e >> 8 & 255, this._buffer[this._byteCount++] = 0
                }
                this._ended = !1
            }
            end() {
                return !1 === this._ended && (this._buffer[this._byteCount++] = 59, this._ended = !0), this._byteCount
            }
            gifWriterOutputLZWCodeStream(t, s) {
                this._buffer[this._byteCount++] = t;
                let r = this._byteCount++;
                var i = 1 << t,
                    a = i - 1,
                    n = 1 + i;
                let o = 1 + n,
                    l = t + 1,
                    h = 0,
                    c = 0,
                    d = this;

                function u(e) {
                    for (; h >= e;) d._buffer[d._byteCount++] = 255 & c, c >>= 8, h -= 8, d._byteCount === r + 256 && (d._buffer[r] = 255, r = d._byteCount++)
                }

                function p(e) {
                    c |= e << h, h += l, u(8)
                }
                let m = s[0] & a,
                    g = {};
                p(i);
                for (let e = 1; e < s.length; ++e) {
                    const u = s[e] & a,
                        _ = m << 8 | u,
                        f = g[_];
                    if (void 0 === f) {
                        for (c |= m << h, h += l; 8 <= h;) this._buffer[this._byteCount++] = 255 & c, c >>= 8, h -= 8, this._byteCount === r + 256 && (this._buffer[r] = 255, r = this._byteCount++);
                        4096 === o ? (p(i), o = 1 + n, l = t + 1, g = {}) : (o >= 1 << l && ++l, g[_] = o++), m = u
                    } else m = f
                }
                return p(m), p(n), u(1), r + 1 === this._byteCount ? this._buffer[r] = 0 : (this._buffer[r] = this._byteCount - r - 1, this._buffer[this._byteCount++] = 0), this._byteCount
            }
            findClosestRGB(e, t, s, r) {
                return r.map(e, t, s)
            }
            clamp(e, t, s) {
                return e < t ? t : s < e ? s : e
            }
            dither(e, r, i) {
                var a = [
                        [7 / 16, 1, 0],
                        [3 / 16, -1, 1],
                        [5 / 16, 0, 1],
                        [1 / 16, 1, 1]
                    ],
                    n = e.width,
                    o = e.height,
                    l = e.data,
                    h = new Uint8Array(l.length / 4);
                for (let s = 0; s < o; ++s)
                    for (let t = 0; t < n; ++t) {
                        var c, d = l[b = 4 * (c = s * n + t)],
                            u = l[1 + b],
                            p = l[2 + b],
                            m = i,
                            g = (b = this.findClosestRGB(d, u, p, r), h[c] = b, d - m[b *= 3]),
                            _ = u - m[1 + b],
                            f = p - m[2 + b];
                        for (let e = 0; e < a.length; ++e) {
                            var v, b, x = a[e][1],
                                T = a[e][2];
                            0 <= x + t && x + t < n && 0 <= T + s && T + s < o && (v = a[e][0], b = c + x + T * n, l[b *= 4] = this.clamp(l[b] + g * v, 0, 255), l[1 + b] = this.clamp(l[1 + b] + _ * v, 0, 255), l[2 + b] = this.clamp(l[2 + b] + f * v, 0, 255))
                        }
                    }
            }
            addFrame(e, t, s, r, i) {
                var a = s.width,
                    s = s.height;
                if (!0 === this._ended && (--this._byteCount, this._ended = !1), e < 0 || t < 0 || 65535 < e || 65535 < t) throw "x/y invalid.";
                if (a <= 0 || s <= 0 || 65535 < a || 65535 < s) throw "Width/Height invalid.";
                if (r.length < a * s) throw "Not enough pixels for the frame size.";
                let n = !0,
                    o = (i = void 0 === i ? {} : i).palette;
                if (null == o && (n = !1, o = this._globalPalette), null == o) throw "Must supply either a local or global palette.";
                let l = this.checkPaletteAndNumColors(o),
                    h = 0;
                for (; l >>= 1;) ++h;
                l = 1 << h;
                let c = i.delay || 0;
                var d = i.disposal || 0;
                if (d < 0 || 3 < d) throw "Disposal out of range.";
                let u = !1,
                    p = 0;
                if (void 0 !== i.transparent && null !== i.transparent && (u = !0, (p = i.transparent) < 0 || p >= l)) throw "Transparent color index.";
                if (0 === d && !u && 0 === c || (null != c && (c = Math.round(c)), this._buffer[this._byteCount++] = 33, this._buffer[this._byteCount++] = 249, this._buffer[this._byteCount++] = 4, this._buffer[this._byteCount++] = d << 2 | (!0 === u ? 1 : 0), this._buffer[this._byteCount++] = 255 & c, this._buffer[this._byteCount++] = c >> 8 & 255, this._buffer[this._byteCount++] = p, this._buffer[this._byteCount++] = 0), this._buffer[this._byteCount++] = 44, this._buffer[this._byteCount++] = 255 & e, this._buffer[this._byteCount++] = e >> 8 & 255, this._buffer[this._byteCount++] = 255 & t, this._buffer[this._byteCount++] = t >> 8 & 255, this._buffer[this._byteCount++] = 255 & a, this._buffer[this._byteCount++] = a >> 8 & 255, this._buffer[this._byteCount++] = 255 & s, this._buffer[this._byteCount++] = s >> 8 & 255, this._buffer[this._byteCount++] = !0 === n ? 128 | h - 1 : 0, !0 === n)
                    for (let e = 0; e < o.length; ++e) {
                        const t = o[e];
                        this._buffer[this._byteCount++] = t >> 16 & 255, this._buffer[this._byteCount++] = t >> 8 & 255, this._buffer[this._byteCount++] = 255 & t
                    }
                this._byteCount = this.gifWriterOutputLZWCodeStream(h < 2 ? 2 : h, r)
            }
            checkPaletteAndNumColors(e) {
                e = e.length;
                if (e < 2 || 256 < e || e & e - 1) throw "Invalid code/color length (" + e + "), must be power of 2 and 2 .. 256.";
                return e
            }
        }
        class rs extends Yt {
            constructor() {
                super(rs.ID), this._thereAreTransparentPixels = !1, this._infoText = "\n            <p>GIF [<b>G</b>raphics <b>I</b>nterchange <b>F</b>ormat] is a widely supported format that can contain multiple images in itself and viewers can play them as an animation.</p>\n            <p>It compresses the image in a lossless way. However, it supports only 8 bit (256) color with absolute transparency (a pixel is either fully transparent, or it's absolutely opaque).</p>\n            <p>Unless you specifically need to save your image as GIF, we don't recommend using this format because of its limited color palette.</p>\n            "
            }
            rgba2rgb(a, n, o) {
                let l = [],
                    h = 0,
                    e = a.length;
                for (let i = 0; i < e; i += 4) {
                    let e = a[i],
                        t = a[i + 1],
                        s = a[i + 2],
                        r = a[i + 3];
                    o && 0 === r ? (e = o[0], t = o[1], s = o[2], this._thereAreTransparentPixels = !0) : n && r < 255 && (e = (e * r + n[0] * (255 - r)) / 255 | 0, t = (t * r + n[1] * (255 - r)) / 255 | 0, s = (s * r + n[2] * (255 - r)) / 255 | 0), l[h++] = e, l[h++] = t, l[h++] = s
                }
                return l
            }
            rgb2num(t) {
                let s = [],
                    r = 0,
                    i = t.length;
                for (let e = 0; e < i; e += 3) s[r++] = t[e + 2] | t[e + 1] << 8 | t[e] << 16;
                return s
            }
            addFrame(e, t, s, r, i, a, n = !1) {
                var o = t.data;
                let l, h = this.rgba2rgb(o, s, r),
                    c = h.length,
                    d = c / 3,
                    u = [],
                    p = new ts(h, c, i),
                    m = p.process(),
                    g = this.rgb2num(m),
                    _ = {
                        palette: new Uint32Array(g),
                        delay: a,
                        disposal: 0,
                        transparent: void 0
                    },
                    f = (this._thereAreTransparentPixels && (_.transparent = p.map(r[0], r[1], r[2]), _.disposal = 2), !0 === n && (e.dither(t, p, m), h = this.rgba2rgb(o, s, r)), 0);
                for (let e = 0; e < d; ++e) {
                    const t = p.map(255 & h[f++], 255 & h[f++], 255 & h[f++]);
                    u[e] = t
                }
                l = new Uint8Array(u), e.addFrame(0, 0, t, l, _)
            }
            makeGif(t) {
                var s = t.frames,
                    r = s.length,
                    i = new Uint8ClampedArray(s[0].width * s[0].height * r * 5),
                    a = new ss(i, s[0].width, s[0].height, {
                        loop: t.loop || 0,
                        background: void 0,
                        palette: void 0
                    });
                for (let e = 0; e < r; ++e) this.addFrame(a, s[e], t.matte, t.transparent, t.sample, t.delay, t.dither);
                var n = [],
                    o = a.end();
                for (let e = 0; e < o; e++) n.push(i[e]);
                return n
            }
            async
            export (e, t) {
                var t = t.dither,
                    s = e.readPixels(!0, !0, !0),
                    r = e.width,
                    e = e.height,
                    i = [],
                    s = (i.push({
                        data: s,
                        width: r,
                        height: e
                    }), this.makeGif({
                        frames: i,
                        delay: 10,
                        loop: 0,
                        sample: 10,
                        dither: t,
                        matte: [255, 255, 255],
                        transparent: [255, 255, 255]
                    }));
                return new Uint8ClampedArray(s)
            }
        }
        rs.ID = "gif";
        class is extends Yt {
            constructor(e, t, s = is.ID) {
                super(s), this._width = 0, this._height = 0, this._hotspot = [0, 0], this._bmpExporter = e, this._pngExporter = t, this._mimeId = "x-icon", this._ico = [], this._isEncoderBMP = !0, this._infoText = "\n\t\t\t<p>The ICO format is mainly for launcher icons.</p>\n\t\t\t<p>If you have a program that needs an icon for its shortcut or launcher, this is the right format for you.</p>\n\t\t\t<p>It can store 24 bit (16.7 M) color plus 8 bit for the alpha (transparency) channel (a sum of 32 bit).</p>\n\t\t\t<p>Generally, you should set your icon to a square size (eg.: 128x128). Originally, it didn't support larger resolutions than 256x256, but larger sizes are now widely supported.</p>\n\t\t\t<p>We also recommend this format for favicons (for a webpage), usually in 32x32 pixel size.</p>\n\t\t\t"
            }
            async
            export (e, t) {
                return this._width = e.width, this._height = e.height, this._hotspot = t.hotspot || [0, 0], this._isEncoderBMP = !("png" === t.encoder), this.writeHeader(), this.writeImage(e)
            }
            writeHeader() {
                this._ico.length = 0;
                var e = this.isICO() ? 1 : 2;
                this.addNumber(0), this.addNumber(e), this.addNumber(1)
            }
            writeImage(s) {
                return new Promise(async e => {
                    var t;
                    this._isEncoderBMP ? (t = this._bmpExporter.exportSync(s, {
                        bpp: "32bit"
                    }), this._bmpData = new File([t], "", {
                        type: this._bmpExporter.mimeType,
                        lastModified: Date.now()
                    }), this.writeImageHeader(), this.writeImageDataHeader()) : (t = await this._pngExporter.export(s, {
                        quality: 1
                    }), this.writeImageHeader(t)), e(await this.writeImageData())
                })
            }
            writeImageHeader(e) {
                this._blob = e;
                var t = this._width % 256,
                    s = this._height % 256,
                    r = this.isICO() ? 1 : this._hotspot[0],
                    i = this.isICO() ? 32 : this._hotspot[1],
                    e = e ? e.size : this._width * this._height * 4 + is.BMP_HEADER_SIZE;
                this._ico.push(t), this._ico.push(s), this._ico.push(0), this._ico.push(0), this.addNumber(r), this.addNumber(i), this.addNumber(e, 4), this.addNumber(22, 4)
            }
            writeImageDataHeader() {
                var e = this._width,
                    t = 2 * this._height,
                    s = this._width * this._height * 4,
                    r = this.numToByteArray(0, 4);
                this.addNumber(40, 4), this.addNumber(e, 4), this.addNumber(t, 4), this.addNumber(1), this.addNumber(32), this.addNumber(0, 4), this.addNumber(s, 4), this.addBytes(r), this.addBytes(r), this.addBytes(r), this.addBytes(r)
            }
            addNumber(e, t = 2) {
                e = this.numToByteArray(e, t);
                this.addBytes(e)
            }
            addBytes(t) {
                for (let e = 0; e < t.length; ++e) this._ico.push(t[e])
            }
            async writeImageData() {
                const t = this._isEncoderBMP ? this._bmpData : this._blob,
                    e = await p.P.readAsArraybuffer(t),
                    s = new Uint8Array(e);
                for (let e = !0 === this._isEncoderBMP ? 54 : 0; e < s.length; ++e) this._ico.push(s[e]);
                if (this._isEncoderBMP) {
                    const t = this._width * this._height * 2 / 8 + 2;
                    for (let e = 0; e < t; ++e) this._ico.push(0)
                }
                return new Uint8ClampedArray(this._ico)
            }
            numToByteArray(e, t = 2) {
                for (var s = []; 0 < t; t--) s.push(255 & e), e >>= 8;
                return s
            }
            isICO() {
                return "x-icon" === this._mimeId
            }
        }
        is.ID = "ico", is.BMP_HEADER_SIZE = 104;
        class as extends is {
            constructor(e, t) {
                super(e, t, as.ID), this._mimeId = "com.microsoft.cur", this._infoText = "\n\t\t\tThe CUR format is similar to ICO but it's used for mouse cursors.\n\t\t"
            }
        }
        as.ID = "cur";
        class ns extends Yt {
            constructor() {
                super(ns.ID), this._infoText = "\n\t\t<p>BMP [<b>B</b>it<b>m</b>a<b>p</b>] is probably the simplest widely supported format. It doesn't compress the image, only in a few rare cases.</p>\n\t\t<p>Typically it supports 24 bit (16.7 M) color. However it can support 32 bit (with transparency) color, but it's not widely supported.</p>\n\t\t<p>Unless you specifically need to save your image as BMP, we don't recommend using this format because of the large file size it produces.</p>\n\t\t"
            }
            async
            export (e, t) {
                return this.exportSync(e, t)
            }
            exportSync(e, t) {
                var s = "32bit" === t.bpp,
                    r = s ? 4 : 3,
                    i = e.readPixels(s, s),
                    a = e.width,
                    t = e.height,
                    n = [];
                n.length = 13;
                let o = 4 - a * r % 4;
                var e = (a * r + (o = 4 === o ? 0 : o)) * t,
                    l = (n[0] = 54 + e, n[1] = 0, n[2] = 54, n[3] = 40, n[4] = a, n[5] = t, n[7] = 0, n[8] = e, n[9] = 0, n[10] = 0, n[11] = 0, n[12] = 0, new Uint8Array(n[0]));
                l[0] = 66, l[1] = 77;
                for (let e = 0; e <= 5; e++) l[4 * e + 2] = 255 & n[e], l[4 * e + 3] = (65280 & n[e]) >> 8, l[4 * e + 4] = (16711680 & n[e]) >> 16, l[4 * e + 5] = (4278190080 & n[e]) >> 24;
                l[26] = 1, l[27] = 0, l[28] = s ? 32 : 24, l[29] = 0;
                for (let e = 7; e <= 12; e++) l[4 * (e - 7) + 30] = 255 & n[e], l[4 * (e - 7) + 31] = (65280 & n[e]) >> 8, l[4 * (e - 7) + 32] = (16711680 & n[e]) >> 16, l[4 * (e - 7) + 33] = (4278190080 & n[e]) >> 24;
                let h = 0,
                    c = 0;
                for (let e = t - 1; 0 <= e; --e) {
                    for (let e = 0; e <= a - 1; ++e) l[54 + h + 0] = i[c + 2], l[54 + h + 1] = i[c + 1], l[54 + h + 2] = i[c + 0], s && (l[54 + h + 3] = i[c + 3]), h += r, c += r;
                    if (o)
                        for (let e = 1; e <= o; ++e) l[54 + h++] = 0
                }
                return l
            }
        }
        ns.ID = "bmp";
        class os extends jt {
            constructor() {
                super(os.ID), this._mimeId = "webp", this._infoText = "\n\t\t\tWEBP is a modern image format that provides superior lossless and lossy compression for images on the web.\n\t\t\t"
            }
        }
        os.ID = "webp";
        class ls extends z {
            async execute(e) {
                var t = this.createTextureExporter(e.fileFormat),
                    s = await t.export(e.texture, e.settings),
                    r = e.texture.name + "." + t.extension;
                t.downloadAsFile(s, r, e.document)
            }
            createTextureExporter(e) {
                t = new Kt, s = new ns;
                var t, s = new Map([
                    [qt.ID, new qt],
                    [Kt.ID, t],
                    [os.ID, new os],
                    [ns.ID, s],
                    [rs.ID, new rs],
                    [Qt.ID, new Qt],
                    [es.ID, new es],
                    [is.ID, new is(s, t)],
                    [as.ID, new as(s, t)]
                ]).get(e);
                if (s) return s;
                throw new Error("Exporter not found: " + e)
            }
        }
        ls.ID = "export_texture";
        class G extends u.Component {
            static getDerivedStateFromProps(e, t) {
                var s = t.active,
                    t = e.value !== t.prevPropValue;
                if (!s && t && f.M.isValidNumber(e.value)) {
                    const t = G.validateValue(e.value, e);
                    return {
                        lastValidNumber: t,
                        prevPropValue: e.value,
                        stringValue: G.getStringValue(t, e)
                    }
                }
                return {}
            }
            static getStringValue(e, t) {
                return e.toFixed(t.decimals)
            }
            static validateValue(e, t) {
                return f.M.clamp(e = (e = e === 1 / 0 ? 0 : e) === -1 / 0 ? 0 : e, t.min, t.max)
            }
            constructor(e) {
                super(e), this._firstMouseDown = !0, this.onInput = e => {
                    this.setState({
                        typing: !0,
                        stringValue: e.target.value
                    });
                    var t, s, e = this.getNumber(e.currentTarget.value);
                    isNaN(e) || null == (s = (t = this.props).onInput) || s.call(t, e)
                }, this.onKeyPress = e => {
                    "Enter" === e.key && (this.triggerChange(e), e.currentTarget.blur())
                }, this.onKeyDown = e => {
                    let t = 0;
                    switch (e.keyCode) {
                        case P.KEY_DOWN:
                            t = -1;
                            break;
                        case P.KEY_UP:
                            t = 1
                    }
                    0 !== t && (e.preventDefault(), this.step(t))
                }, this.onKeyUp = e => {}, this.onFocus = e => {
                    this.setState({
                        active: !0,
                        typing: !1
                    })
                }, this.onBlur = e => {
                    this._firstMouseDown = !0;
                    var t = this.state["typing"];
                    this.setState({
                        active: !1,
                        typing: !1
                    }), t && this.triggerChange(e)
                }, this.onMouseDown = e => {}, this.onMouseUp = e => {
                    this._firstMouseDown && (this._firstMouseDown = !1, e = e.currentTarget, yt.hasSelection(e) || e.select())
                }, this.onLabelDown = e => {
                    0 === e.button && (this.setState({
                        active: !0
                    }), e.currentTarget.requestPointerLock(), this.window.addEventListener("pointerup", this.onPointerUp), this.window.addEventListener("pointermove", this.onPointerMove))
                }, this.onLabelClick = e => {
                    e.preventDefault()
                }, this.onPointerUp = e => {
                    this.window.removeEventListener("pointerup", this.onPointerUp), this.window.removeEventListener("pointermove", this.onPointerMove), this.window.document.exitPointerLock(), this.setState({
                        active: !1
                    })
                }, this.onPointerMove = e => {
                    var t = e.movementX;
                    this.step(t, e.shiftKey)
                }, this.onMount = e => {
                    e && (this._window = e.ownerDocument.defaultView || window)
                };
                e = G.validateValue(e.value, e);
                this.state = {
                    stringValue: G.getStringValue(e, this.props),
                    lastValidNumber: e,
                    prevPropValue: e,
                    active: !1,
                    typing: !1
                }
            }
            step(e, t = !1) {
                var s, e = e * (this.props.step || 2),
                    e = G.validateValue(this.state.lastValidNumber + e, this.props),
                    t = t && f.M.isPositive(this.props.shiftRound) ? f.M.roundTo(e, this.props.shiftRound) : e;
                this.setState({
                    lastValidNumber: e,
                    stringValue: G.getStringValue(t, this.props)
                }), null != (s = (e = this.props).onInput) && s.call(e, t), null != (e = (s = this.props).onChange) && e.call(s, t)
            }
            triggerChange(t) {
                var s;
                if (this.props.onChange) {
                    let e = this.getNumber(t.currentTarget.value);
                    isNaN(e) && (e = this.state.lastValidNumber), null != (s = (t = this.props).onInput) && s.call(t, e), this.props.onChange(e)
                }
            }
            getNumber(e) {
                var t = this.props.postfix;
                if (t && this.containsAtEnd(t, e)) {
                    const s = e.indexOf(t);
                    s === e.length - t.length && (e = e.substr(0, s))
                }
                let s = parseFloat(e);
                return s = G.validateValue(s, this.props)
            }
            containsAtEnd(e, t) {
                var s = t.indexOf(e);
                return -1 < s && s === t.length - e.length
            }
            componentDidMount() {}
            get window() {
                return this._window || window
            }
            render() {
                var {
                    label: e,
                    disabled: t,
                    postfix: s,
                    className: r,
                    title: i
                } = this.props, {
                    active: a,
                    typing: n,
                    stringValue: o
                } = this.state;
                let l = o || "";
                return n || !s || this.containsAtEnd(s, l) || (l += s), u.createElement("label", {
                    title: i,
                    className: h("NumberField", {
                        disabled: t,
                        active: a,
                        [r || ""]: !!r
                    }),
                    ref: this.onMount
                }, u.createElement("span", {
                    className: "label",
                    onMouseDown: this.onLabelDown,
                    onClick: this.onLabelClick
                }, e), u.createElement("input", {
                    value: l,
                    disabled: this.props.disabled,
                    spellCheck: !1,
                    onFocus: this.onFocus,
                    onBlur: this.onBlur,
                    onChange: this.onInput,
                    onMouseDown: this.onMouseDown,
                    onMouseUp: this.onMouseUp,
                    onKeyPress: this.onKeyPress,
                    onKeyDown: this.onKeyDown,
                    onKeyUp: this.onKeyUp
                }))
            }
        }
        G.defaultProps = {
            value: 0,
            decimals: 2,
            step: .1,
            className: "number",
            postfix: "",
            title: ""
        };
        class hs extends u.Component {
            constructor(e) {
                super(e), this.onChangeQuality = e => {
                    this.props.onChange({
                        quality: e / 100
                    })
                }
            }
            render() {
                return u.createElement(u.Fragment, null, u.createElement(G, {
                    label: "Quality",
                    value: Math.round(100 * this.props.settings.quality),
                    onChange: this.onChangeQuality,
                    min: 0,
                    max: 100,
                    step: 1,
                    decimals: 0,
                    postfix: "%"
                }))
            }
        }
        class cs extends u.Component {
            constructor(e) {
                super(e), this._fileFormats = [{
                    value: "jpg",
                    label: "JPG",
                    ui: hs
                }, {
                    value: "png",
                    label: "PNG"
                }, {
                    value: "webp",
                    label: "WebP",
                    ui: hs
                }, {
                    value: "bmp",
                    label: "BMP"
                }, {
                    value: "gif",
                    label: "GIF"
                }, {
                    value: "tiff",
                    label: "TIFF"
                }, {
                    value: "tga",
                    label: "TGA"
                }], this.onChangeFileFormat = e => {
                    this.setState({
                        fileFormat: e.value
                    })
                }, this.onSaveClick = e => {
                    this.save()
                }, this.onCloseClick = () => {
                    this.close()
                }, this.onChangeOptions = e => {
                    this.setState({ ...this.state,
                        settings: { ...this.state.settings,
                            ...e
                        }
                    })
                }, this.onMount = e => {
                    y.listenPopup(e, this.onCloseClick)
                }, this.state = {
                    fileFormat: "jpg",
                    settings: {
                        quality: .9
                    }
                }, this.props.keyboardListener.signals.down.add(this.onKeyDown, this)
            }
            save() {
                var e = {
                    editor: this.props.editor,
                    texture: this.props.texture,
                    fileFormat: this.state.fileFormat,
                    document: this.props.editor.document,
                    settings: this.state.settings
                };
                this.props.app.commands.execute(ls.ID, e), this.close()
            }
            close() {
                this.props.keyboardListener.signals.down.remove(this.onKeyDown, this), this.props.onClose()
            }
            onKeyDown(e) {
                e.keyCode === P.KEY_ENTER && this.save()
            }
            render() {
                var e = this._fileFormats.find(e => e.value === this.state.fileFormat),
                    t = null == e ? void 0 : e.ui;
                return u.createElement("div", {
                    className: "SaveWindow popup dark-panel",
                    ref: this.onMount
                }, u.createElement("div", {
                    className: "panel-header"
                }, u.createElement("div", {
                    className: "panel-title"
                }, "Save"), u.createElement("div", {
                    className: "panel-close",
                    onClick: this.onCloseClick
                })), u.createElement("div", {
                    className: "panel-content vbox"
                }, u.createElement(k, {
                    label: "Format"
                }, u.createElement(F, {
                    options: this._fileFormats,
                    render: F.renderLabel,
                    selected: e,
                    onChange: this.onChangeFileFormat
                })), u.createElement("div", {
                    className: "format-ui"
                }, t && u.createElement(t, {
                    settings: this.state.settings,
                    onChange: this.onChangeOptions
                })), u.createElement("div", {
                    className: "alignSelfFlexEnd"
                }, u.createElement(Rt, {
                    label: "Save",
                    onClick: this.onSaveClick
                }))))
            }
        }
        class ds extends u.Component {
            constructor(e) {
                super(e), this._initialSize = [0, 0], this.onCancelClick = e => {
                    this.close()
                }, this.onOkClick = e => {
                    this.save()
                }, this.onCloseClick = () => {
                    this.close()
                }, this.onMount = e => {
                    y.listenPopup(e, this.onCloseClick), this._initialSize = [this.props.texture.width, this.props.texture.height]
                }, this.onWidthInput = e => {
                    var t;
                    this.state.keepAspectRatio && (t = this._initialSize[0] / this._initialSize[1], this.setState({
                        height: Math.max(1, Math.round(e / t))
                    }))
                }, this.onWidthChange = e => {
                    this.setState({
                        width: e
                    })
                }, this.onHeightInput = e => {
                    var t;
                    this.state.keepAspectRatio && (t = this._initialSize[0] / this._initialSize[1], this.setState({
                        width: Math.max(1, Math.round(e * t))
                    }))
                }, this.onHeightChange = e => {
                    this.setState({
                        height: e
                    })
                }, this.onToggleKeepAspectRatio = e => {
                    e = e ? {
                        width: this._initialSize[0],
                        height: this._initialSize[1],
                        keepAspectRatio: e
                    } : {
                        keepAspectRatio: e
                    };
                    this.setState(e)
                }, this.onToggleResample = e => {
                    this.setState({
                        resample: e
                    })
                }, this.state = {
                    width: e.texture.width,
                    height: e.texture.height,
                    keepAspectRatio: !0,
                    resample: !0
                }, this.props.keyboardListener.signals.down.add(this.onKeyDown, this)
            }
            save() {
                var e = this.props.texture;
                e.width === this.state.width && e.height === this.state.height || (e = e.resize({
                    width: this.state.width,
                    height: this.state.height,
                    resample: this.state.resample
                }), this.props.onChangeTexture(e)), this.close()
            }
            close() {
                this.props.keyboardListener.signals.down.remove(this.onKeyDown, this), this.props.onClose()
            }
            onKeyDown(e) {
                "Enter" === e.key && this.save()
            }
            render() {
                return u.createElement("div", {
                    className: "ResizeTextureWindow popup dark-panel",
                    ref: this.onMount
                }, u.createElement("div", {
                    className: "panel-header"
                }, u.createElement("div", {
                    className: "panel-title"
                }, "Resize"), u.createElement("div", {
                    className: "panel-close",
                    onClick: this.onCloseClick
                })), u.createElement("div", {
                    className: "panel-content vbox"
                }, u.createElement(G, {
                    label: "Width",
                    value: this.state.width,
                    onChange: this.onWidthChange,
                    onInput: this.onWidthInput,
                    decimals: 0,
                    min: 0
                }), u.createElement(G, {
                    label: "Height",
                    value: this.state.height,
                    onChange: this.onHeightChange,
                    onInput: this.onHeightInput,
                    decimals: 0,
                    min: 0
                }), u.createElement(k, {
                    label: "Keep aspect ratio"
                }, u.createElement(U, {
                    value: this.state.keepAspectRatio,
                    onChange: this.onToggleKeepAspectRatio
                })), u.createElement(k, {
                    label: "Resample"
                }, u.createElement(U, {
                    value: this.state.resample,
                    onChange: this.onToggleResample
                })), u.createElement("div", {
                    className: "alignSelfFlexEnd"
                }, u.createElement(Rt, {
                    label: "Cancel",
                    onClick: this.onCancelClick
                }), u.createElement(Rt, {
                    label: "Ok",
                    onClick: this.onOkClick
                }))))
            }
        }
        class us extends u.Component {
            constructor(e) {
                super(e), this.openResizeWindow = () => {
                    var e;
                    this.props.texture && null != (e = this.props.editor.popups) && e.open(ds, {
                        app: this.props.app,
                        editor: this.props.editor,
                        texture: this.props.texture,
                        onChangeTexture: this.props.onChangeTexture
                    })
                }, this.rotate90CW = () => {
                    this.props.texture && this.props.onChangeTexture(this.props.texture.rotate90(!0))
                }, this.rotate90CCW = () => {
                    this.props.texture && this.props.onChangeTexture(this.props.texture.rotate90(!1))
                }, this.flipHorizontal = () => {
                    this.props.texture && this.props.onChangeTexture(this.props.texture.flip(!0))
                }, this.flipVertical = () => {
                    this.props.texture && this.props.onChangeTexture(this.props.texture.flip(!1))
                }, this.onNew = () => {
                    var e = null != (e = null == (e = this.props.texture) ? void 0 : e.width) ? e : 1024,
                        t = null != (t = null == (t = this.props.texture) ? void 0 : t.height) ? t : 1024,
                        e = new kt({
                            adapter: this.adapter,
                            width: e,
                            height: t,
                            source: null,
                            transparent: !0
                        });
                    this.props.onChangeTexture(e)
                }, this.onOpen = () => {
                    p.P.openFileDialogue(!0, null, this.openFiles, this.props.editor.document)
                }, this.openFiles = e => {
                    e = e[0];
                    e && this.props.editor.importers.importFile(e, e => {
                        e = new kt({
                            adapter: this.adapter,
                            source: e,
                            transparent: !0
                        });
                        this.props.onChangeTexture(e)
                    })
                }, this.onSave = () => {
                    this.props.texture && this.props.onSaveTexture(this.props.texture)
                }, this.onSaveAs = () => {
                    var e;
                    this.props.texture && null != (e = this.props.editor.popups) && e.open(cs, {
                        app: this.props.app,
                        editor: this.props.editor,
                        texture: this.props.texture
                    })
                }, this.onSaveAndClose = () => {
                    this.props.texture && this.props.onSaveTexture(this.props.texture), this.props.onClose()
                }, this.onClose = () => {
                    this.props.onClose()
                }, this.state = {
                    menu: [{
                        id: "file",
                        label: "File",
                        children: [{
                            id: "textureNew",
                            label: "New",
                            onSelect: this.onNew
                        }, {
                            id: "textureOpen",
                            label: "Open",
                            onSelect: this.onOpen
                        }, {
                            id: "textureSave",
                            label: "Save",
                            onSelect: this.onSave
                        }, {
                            id: "textureSave",
                            label: "Save as...",
                            onSelect: this.onSaveAs
                        }, {
                            id: "textureSave",
                            label: "Save and Close",
                            onSelect: this.onSaveAndClose
                        }, {
                            label: "Close",
                            onSelect: this.onClose
                        }]
                    }, {
                        label: "Image",
                        children: [{
                            id: "imageSize",
                            label: "Image Size",
                            onSelect: this.openResizeWindow
                        }, {
                            separator: !0
                        }, {
                            id: "rotate90",
                            label: "Rotate 90 (CW)",
                            onSelect: this.rotate90CW
                        }, {
                            id: "rotate90",
                            label: "Rotate 90 (CCW)",
                            onSelect: this.rotate90CCW
                        }, {
                            id: "flipHorizontal",
                            label: "Flip Horizontal",
                            onSelect: this.flipHorizontal
                        }, {
                            id: "flipVertical",
                            label: "Flip Vertical",
                            onSelect: this.flipVertical
                        }]
                    }, {
                        label: "View",
                        children: [{
                            label: "Pixel Grid",
                            checked: () => {
                                var e;
                                return (null == (e = this.props.editor.state.renderer) ? void 0 : e.getPixelGrid()) || !1
                            },
                            onSelect: () => {
                                var e;
                                return null == (e = this.props.editor.state.renderer) ? void 0 : e.setPixelGrid(!(null != (e = this.props.editor.state.renderer) && e.getPixelGrid()))
                            }
                        }]
                    }]
                }
            }
            get adapter() {
                var e = (null == (e = this.props.texture) ? void 0 : e.adapter) || this.props.editor.adapter;
                if (e) return e;
                throw new Error("No adapter")
            }
            render() {
                return u.createElement("div", {
                    className: "HeaderPanel"
                }, u.createElement(Wt, {
                    app: Y.inst,
                    menu: this.state.menu
                }))
            }
        }(t = he = he || {})[t.BLEND = _.g.BLEND] = "BLEND", t[t.CULL_FACE = _.g.CULL_FACE] = "CULL_FACE", t[t.DEPTH_TEST = _.g.DEPTH_TEST] = "DEPTH_TEST", t[t.DITHER = _.g.DITHER] = "DITHER", t[t.POLYGON_OFFSET_FILL = _.g.POLYGON_OFFSET_FILL] = "POLYGON_OFFSET_FILL", t[t.SAMPLE_ALPHA_TO_COVERAGE = _.g.SAMPLE_ALPHA_TO_COVERAGE] = "SAMPLE_ALPHA_TO_COVERAGE", t[t.SAMPLE_COVERAGE = _.g.SAMPLE_COVERAGE] = "SAMPLE_COVERAGE", t[t.SCISSOR_TEST = _.g.SCISSOR_TEST] = "SCISSOR_TEST", t[t.STENCIL_TEST = _.g.STENCIL_TEST] = "STENCIL_TEST";
        class ps {
            constructor(e) {
                this._pixelStore = {
                    [_.g.PACK_ALIGNMENT]: 4,
                    [_.g.UNPACK_ALIGNMENT]: 4,
                    [_.g.UNPACK_FLIP_Y_WEBGL]: !1,
                    [_.g.UNPACK_PREMULTIPLY_ALPHA_WEBGL]: !1,
                    [_.g.UNPACK_COLORSPACE_CONVERSION_WEBGL]: _.g.BROWSER_DEFAULT_WEBGL
                }, this._ctx = e
            }
            setValue(e, t) {
                this._pixelStore[e] !== t && (this._ctx.gl.pixelStorei(e, t), this._pixelStore[e] = t)
            }
            getValue(e) {
                return this._pixelStore[e]
            }
        }
        class ms {
            constructor(e) {
                this._extensionsCache = {}, this._ctx = e
            }
            getExtension(e) {
                var t = this._extensionsCache;
                return t.hasOwnProperty(e) || (t[e] = this._ctx.gl.getExtension(e)), t[e]
            }
            enableStandardDerivatives() {
                return !(this._ctx.version < 2) || this.getExtension(ms.OES_standard_derivatives)
            }
            hasTextureCubeLod() {
                return this._ctx.is2 || this.getExtension(ms.EXT_shader_texture_lod)
            }
            get textureCubeLodFn() {
                return this._ctx.is2 ? "texture" : "textureCubeLodEXT"
            }
        }
        ms.OES_standard_derivatives = "OES_standard_derivatives", ms.GL_OES_standard_derivatives = "GL_OES_standard_derivatives", ms.EXT_shader_texture_lod = "EXT_shader_texture_lod", ms.GL_EXT_shader_texture_lod = "GL_EXT_shader_texture_lod";
        var g = c(9816);
        class gs {
            constructor(e) {
                this._boundVAO = null, this._ctx = e
            }
            bindVAO(e) {
                this._boundVAO !== e && (this._ctx.gl2.bindVertexArray(e), this._boundVAO = e)
            }
            unbind() {
                this.bindVAO(null)
            }
        }
        class _s {
            constructor(e) {
                this._version = 1, this._contextAttributes = {}, this._clear = {
                    color: [0, 0, 0, 0],
                    depth: 1,
                    stencil: 0,
                    mask: 0
                }, this._capabilities = {}, this._capabilitiesDirty = !0, this._cullFace = _.g.BACK, this._frontFace = _.g.CCW, this._activeProgram = null, this._enabledAttributeArrays = [], this._parametersCache = {}, this._boundFramebuffer = null, e.attributes = J.g.mergeConfig(_s.defaultConfig.attributes || {}, e.attributes || {});
                e = J.g.mergeConfig(_s.defaultConfig, e);
                if (this._depth = null == (t = null == (t = e.attributes) ? void 0 : t.depth) || t, this._depthTest = null == (t = e.depthTest) || t, this._depthMask = null == (t = e.depthMask) || t, this._contextAttributes = e.attributes || {}, this._activeTextureUnit = 0, this._viewport = [-1, -1, -1, -1], this._scissor = [-1, -1, -1, -1], this._boundTextures = {}, this._boundTextures[_.g.TEXTURE_2D] = [], this._boundTextures[_.g.TEXTURE_CUBE_MAP] = [], this._boundBuffers = {}, this._boundBuffers[_.g.ARRAY_BUFFER] = null, this._boundBuffers[_.g.ELEMENT_ARRAY_BUFFER] = null, this._vaoState = new gs(this), this._gl = function(t, e, s) {
                        let r = null,
                            i = ["webgl", "experimental-webgl", "webkit-3d", "moz-webgl"];
                        e && (i = ["webgl2", ...i]);
                        for (let e = 0; e < i.length; e++) {
                            try {
                                r = t.getContext(i[e], s)
                            } catch (t) {}
                            if (r) break
                        }
                        return r || (console.error("WebGLContext: could not create context"), null)
                    }(e.canvas, e.preferWebGL2, e.attributes), this._canvas = e.canvas, !this._gl) throw new Error("WebGLContext: could not create context");
                var t = this._canvas.ownerDocument.defaultView || window;
                t.WebGL2RenderingContext && this._gl instanceof t.WebGL2RenderingContext && (this._version = 2), this._pixelStore = new ps(this), this._extensions = new ms(this), this.initCapabilities();
                let s = this._depthTest;
                (s = void 0 === s && void 0 === (s = this._depth) ? null == (t = null == (t = _s.defaultConfig.attributes) ? void 0 : t.depth) || t : s) && this.enable(he.DEPTH_TEST), this.initClear(e), this.updateCapabilities()
            }
            get premultipliedAlpha() {
                return !!this._contextAttributes.premultipliedAlpha
            }
            viewport(e) {
                return !f.M.equals(this._viewport, e) && (this.gl.viewport(e[0], e[1], e[2], e[3]), g.v.copy(this._viewport, e), !0)
            }
            viewportToFull() {
                var e = this.gl;
                this.viewport([0, 0, e.drawingBufferWidth, e.drawingBufferHeight])
            }
            getViewport() {
                return this._viewport
            }
            setScissor(e) {
                return !f.M.equals(this._scissor, e) && (this.gl.scissor(e[0], e[1], e[2], e[3]), g.v.copy(this._scissor, e), !0)
            }
            initClear(t) {
                var s, r = this._clear.color;
                if (r && this._gl.clearColor(r[0], r[1], r[2], r[3]), void 0 === (null == (s = t.clear) ? void 0 : s.mask)) {
                    const s = this._gl;
                    let e = 0;
                    null != (r = t.clear) && r.color && (e |= s.COLOR_BUFFER_BIT), null != (r = t.attributes) && r.depth && (e |= s.DEPTH_BUFFER_BIT), null != (r = t.attributes) && r.depth && (e |= s.STENCIL_BUFFER_BIT), this._clear.mask = e
                }
            }
            clear(e, t, s = !0) {
                var r = this._gl,
                    e = (void 0 === e && (e = this._clear.color), this._contextAttributes.premultipliedAlpha && (e[0] *= e[3], e[1] *= e[3], e[2] *= e[3]), r.clearColor(e[0], e[1], e[2], e[3]), void 0 === t && (t = this._clear.mask), e && (t |= r.COLOR_BUFFER_BIT), this.isEnabled(he.SCISSOR_TEST)),
                    i = 0 < (t & this.gl.DEPTH_ATTACHMENT),
                    a = !!this.depthMask;
                s && this.disable(he.SCISSOR_TEST), i && (this.depthMask = !0), r.clear(t), i && (this.depthMask = a), s && this.setEnabled(he.SCISSOR_TEST, e)
            }
            bindTextureTo(e, t, s = !1) {
                var r = this._boundTextures[e.getTarget()];
                if (r[t] !== e) {
                    const s = r.indexOf(e); - 1 < s && (r[s] = null), this.setActiveTexture(t), this._gl.bindTexture(e.getTarget(), e.getTexture()), r[t] = e
                } else s && this.setActiveTexture(t)
            }
            bindTextureToActiveUnit(e) {
                this.bindTextureTo(e, this._activeTextureUnit, !1)
            }
            bindTexture(e) {
                var t = this._boundTextures[e.getTarget()].indexOf(e);
                return -1 < t ? this.setActiveTexture(t) : this.bindTextureToActiveUnit(e), this._activeTextureUnit
            }
            setActiveTexture(e) {
                this._activeTextureUnit !== e && (this._gl.activeTexture(this._gl.TEXTURE0 + e), this._activeTextureUnit = e)
            }
            getActiveTextureUnit() {
                return this._activeTextureUnit
            }
            createTexture() {
                return this._gl.createTexture()
            }
            deleteTexture(e) {
                this._gl.deleteTexture(e.getTexture());
                var t = this._boundTextures[e.getTarget()];
                t && -1 < (e = t.indexOf(e)) && (t[e] = null)
            }
            createProgram() {
                return this._gl.createProgram()
            }
            createShader(e) {
                return this._gl.createShader(e)
            }
            deleteProgram(e) {
                this._activeProgram === e && this.useProgram(null), this._gl.deleteProgram(e)
            }
            deleteShader(e) {
                this._gl.deleteShader(e)
            }
            useProgram(e) {
                this._activeProgram !== e && (this._gl.useProgram(e), this._activeProgram = e)
            }
            enableAttribute(e) {
                this._enabledAttributeArrays[e] || (this._gl.enableVertexAttribArray(e), this._enabledAttributeArrays[e] = !0)
            }
            disableAttribute(e) {
                this._enabledAttributeArrays[e] && (this._gl.disableVertexAttribArray(e), this._enabledAttributeArrays[e] = !1)
            }
            createBuffer() {
                return this._gl.createBuffer()
            }
            createRenderBuffer() {
                return this._gl.createRenderbuffer()
            }
            bindBuffer(e, t) {
                this._boundBuffers[t] !== e && (this._gl.bindBuffer(t, e), this._boundBuffers[t] = e)
            }
            unbindBuffer(e) {
                this._gl.bindBuffer(e, null), this._boundBuffers[e] = null
            }
            deleteBuffer(e) {
                this._boundBuffers[_.g.ELEMENT_ARRAY_BUFFER] === e && (this._boundBuffers[_.g.ELEMENT_ARRAY_BUFFER] = null), this._boundBuffers[_.g.ARRAY_BUFFER] === e && (this._boundBuffers[_.g.ARRAY_BUFFER] = null), this._gl.deleteBuffer(e)
            }
            getMaxAnisotropy() {}
            createFramebuffer() {
                return this._gl.createFramebuffer()
            }
            deleteFramebuffer(e) {
                this._gl.deleteFramebuffer(e)
            }
            bindFramebuffer(e) {
                this._boundFramebuffer !== e && (this._gl.bindFramebuffer(this._gl.FRAMEBUFFER, e), this._boundFramebuffer = e)
            }
            unbindFramebuffer() {
                this.bindFramebuffer(null)
            }
            drawArrays(e, t, s) {
                this._capabilitiesDirty && this.preDraw(), this._gl.drawArrays(e, t, s)
            }
            drawElements(e, t, s, r) {
                this._capabilitiesDirty && this.preDraw(), this._gl.drawElements(e, t, s, r)
            }
            preDraw() {
                this.updateCapabilities()
            }
            initCapabilities() {
                this._capabilities = {}, this._capabilities[he.DITHER] = {
                    value: !0,
                    dirty: !1
                }
            }
            setEnabled(e, t) {
                t ? this.enable(e) : this.disable(e)
            }
            enable(e) {
                e = this.getCapability(e);
                !0 !== e.value && (e.value = !0, e.dirty = !0, this._capabilitiesDirty = !0)
            }
            disable(e) {
                e = this.getCapability(e);
                !1 !== e.value && (e.value = !1, e.dirty = !0, this._capabilitiesDirty = !0)
            }
            cullFace(e) {
                this._cullFace !== e && (this._cullFace = e, this.gl.cullFace(e))
            }
            frontFace(e) {
                this._frontFace !== e && (this._frontFace = e, this.gl.frontFace(this._frontFace))
            }
            getCapability(e) {
                return this._capabilities[e] || (this._capabilities[e] = {
                    value: !1,
                    dirty: !1
                }), this._capabilities[e]
            }
            updateCapabilities() {
                for (const t in this._capabilities) {
                    var e = this._capabilities[t];
                    e.dirty && (e.value ? this._gl.enable(t) : this._gl.disable(t), e.dirty = !1)
                }
                this._capabilitiesDirty = !1
            }
            isEnabled(e) {
                return null != (e = null == (e = this._capabilities[e]) ? void 0 : e.value) && e
            }
            enableStandardBlend(e) {
                this.blend(!0);
                var t = this.gl;
                (e = null != e ? e : this.premultipliedAlpha) ? t.blendFunc(t.ONE, t.ONE_MINUS_SRC_ALPHA): t.blendFunc(t.SRC_ALPHA, t.ONE_MINUS_SRC_ALPHA)
            }
            blend(e) {
                e ? this.enable(this.gl.BLEND) : this.disable(this.gl.BLEND)
            }
            set depthTest(e) {
                e ? this.enable(this._gl.DEPTH_TEST) : this.disable(this._gl.DEPTH_TEST)
            }
            get depthTest() {
                return this.getCapability(this._gl.DEPTH_TEST).value
            }
            set depthMask(e) {
                e !== this._depthMask && (this._gl.depthMask(e), this._depthMask = e)
            }
            get depthMask() {
                return this._depthMask
            }
            get pixelStore() {
                return this._pixelStore
            }
            getParameter(e) {
                var t = this._parametersCache;
                return t.hasOwnProperty(e) || (t[e] = this._gl.getParameter(e)), t[e]
            }
            get extensions() {
                return this._extensions
            }
            getExtension(e) {
                return this._extensions.getExtension(e)
            }
            get vao() {
                return this._vaoState
            }
            get canvas() {
                return this._canvas
            }
            get drawingBufferSize() {
                return [this.gl.drawingBufferWidth, this.gl.drawingBufferHeight]
            }
            get gl() {
                return this._gl
            }
            get gl2() {
                return this._gl
            }
            hasWebGLSupport() {
                return !!this.gl
            }
            get is2() {
                return 2 === this._version
            }
            get version() {
                return this._version
            }
            dispose(e = 0) {}
        }
        _s.defaultConfig = {
            preferWebGL2: !0,
            depthTest: !0,
            depthMask: !0,
            clear: {
                color: [0, 0, 0, 0],
                depth: 1,
                stencil: 0,
                mask: void 0
            },
            attributes: {
                alpha: !1,
                depth: !0,
                stencil: !1,
                antialias: !0,
                premultipliedAlpha: !0,
                preserveDrawingBuffer: !1,
                failIfMajorPerformanceCaveat: !1,
                powerPreference: "high-performance"
            }
        };
        var ue = c(3829);
        class fs {
            constructor(e) {
                this._config = e, this._technique = e.technique;
                var t = this._config.adapter;
                this._vao = t.getVAO(this._config.geometry, this._technique.getProgram()), this._start = f.M.findFirstNumber(e.start, e.geometry.start, 0), this._count = f.M.findFirstNumber(e.count, e.geometry.count, 0), this._mode = null != (t = null != (t = e.mode) ? t : e.geometry.mode) ? t : _.g.TRIANGLES
            }
            draw(e, t, s) {
                this.enable(), this.bindBuffers(), this.render(e, t, s)
            }
            drawInstanced(e) {
                this.enable(), this.bindBuffers(), this._config.adapter.context.gl2.drawArraysInstanced(this._mode, this._start, this._count, e)
            }
            enable() {
                this._technique.enable()
            }
            bindBuffers() {
                this._vao.bind()
            }
            render(e, t, s) {
                e = null != e ? e : this._start, t = null != t ? t : this._count, s = null != s ? s : this._mode;
                var r, i = this._vao.indexBuffer,
                    a = this._config.adapter.context;
                i ? (r = e * ue.oY.getBytesForType(i.componentType), a.drawElements(s, t, i.componentType, i.byteOffset + r)) : a.drawArrays(s, e, t)
            }
            postRender() {
                this.cleanUp()
            }
            cleanUp() {
                this._vao.unbind()
            }
            get config() {
                return this._config
            }
            get count() {
                return this._count
            }
            get start() {
                return this._start
            }
            get mode() {
                return this._mode
            }
            get indexBuffer() {
                return this._vao.indexBuffer
            }
            get technique() {
                return this._technique
            }
        }
        class vs {
            constructor(e) {
                this._compiled = !1, this._config = e, this._ctx = e.context;
                var t = this._ctx.gl;
                if (this._shader = this._ctx.createShader(e.type), t.shaderSource(this._shader, e.source), t.compileShader(this._shader), t.getShaderParameter(this._shader, t.COMPILE_STATUS)) this._compiled = !0;
                else {
                    const e = t.getShaderInfoLog(this._shader);
                    console.log("Error", e), alert(e)
                }
            }
            dispose() {
                this._shader && this._ctx.deleteShader(this._shader)
            }
            get compiled() {
                return this._compiled
            }
            get shader() {
                return this._shader
            }
            get source() {
                return this._config.source
            }
        }
        class bs {
            static createInstance(e) {}
            constructor(e) {
                e = e || bs.defaultConfig, this._vertHeader = this.getPrecisionHeader(e.vert, _.g.VERTEX_SHADER), this._fragHeader = this.getPrecisionHeader(e.frag, _.g.FRAGMENT_SHADER)
            }
            getPrecisionHeader(e, t) {
                e = e || {};
                var s = ee.U.isDesktop() ? "desktop" : "mobile";
                let r = "",
                    i = [],
                    a = "";
                e.all && (e.float = e.all, e.int = e.all, e.sampler2D = e.all, e.samplerCube = e.all);
                for (const l in e) {
                    var n = l;
                    if ("all" !== n) {
                        var o = e[n],
                            o = o[s] || o.all || "";
                        if (o === bs.HIGH && t === _.g.FRAGMENT_SHADER ? i.push(n) : a += "precision " + o + " " + n + ";\n", 0 < i.length) {
                            r = "#ifdef GL_FRAGMENT_PRECISION_HIGH\n";
                            for (let e = 0, t = i.length; e < t; e++) r += "precision highp " + i[e] + ";\n";
                            r += "#else\n";
                            for (let e = 0, t = i.length; e < t; e++) r += "precision mediump " + i[e] + ";\n";
                            r += "#endif\n"
                        }
                    }
                }
                return r += a
            }
            get vertHeader() {
                return this._vertHeader
            }
            get fragHeader() {
                return this._fragHeader
            }
        }
        bs.HIGH = "highp", bs.MEDIUM = "mediump", bs.LOW = "lowp", bs.defaultConfig = {
            vert: {
                float: {
                    mobile: bs.HIGH,
                    desktop: bs.HIGH
                }
            },
            frag: {
                float: {
                    all: bs.HIGH
                }
            }
        };
        var pe = c(6017);

        function me(e) {
            return f.M.isPositiveOrZero(e)
        }
        class W {
            static getAttributeType(e, t, s) {
                return e === _.g.INT ? 1 === t ? "int" : "int" + t : e === _.g.BOOL ? "bool" : 1 === t ? "float" : s && 1 < s ? "mat" + t : "vec" + t
            }
            constructor(e) {
                this.id = ++W.highestId, this.name = "", this._attributes = [], this._attributesByName = {}, this._uniforms = {}, this._textureUniforms = {}, this._arrayUniforms = {}, this._version = 2, this._config = e, this._ctx = e.context, this._ctx.is2 && (this._version = 3), this.init()
            }
            init() {
                const e = this._ctx.gl;
                this._attributes = (this._config.attributes || []).map(e => {
                    var t = {
                        name: e.name,
                        index: null != (t = e.index) ? t : -1,
                        size: e.size || 3,
                        sizeY: e.sizeY || 1,
                        componentType: e.componentType || _.g.FLOAT,
                        semantic: e.semantic
                    };
                    return this._attributesByName[e.name] = t
                });
                for (let e = 0; e < this._attributes.length; ++e) {
                    const t = this._attributes[e];
                    void 0 === t.componentType && (t.componentType = _.g.FLOAT), this._attributesByName[t.name] = t
                }
                const t = this._config.uniforms;
                for (const e in t) {
                    const s = t[e];
                    !s.type && s.texture && (s.type = W.TYPE_SAMPLER_2D)
                }
                const [s, r] = this.initShaders();
                s.compiled && r.compiled && (this._program = this._ctx.createProgram(), e.attachShader(this._program, s.shader), e.attachShader(this._program, r.shader), this.bindAttributesWithExplicitIndices(this._program), e.linkProgram(this._program), e.getProgramParameter(this._program, e.LINK_STATUS) || (alert("Could not link shader!"), console.warn("Could not link shader!"), console.warn(e.getProgramInfoLog(this._program))), this.onProgramLinked(this._program))
            }
            initShaders() {
                let s = this._config.vertShader,
                    r = this._config.fragShader;
                if (!s || !r) {
                    let t = this._config.vertSource,
                        e = this._config.fragSource;
                    for (const s in this._config.uniforms) {
                        const r = this._config.uniforms[s],
                            i = r.arrayLength && 0 < r.arrayLength ? `[${r.arrayLength}]` : "";
                        r.addToVert && (t = `uniform ${r.type} ${s}${i};
` + t), r.addToFrag && (e = `uniform ${r.type} ${s}${i};
` + e)
                    }
                    for (let e = 0; e < this._attributes.length; ++e) {
                        const r = this._attributes[e],
                            a = W.getAttributeType(r.componentType, r.size, r.sizeY);
                        t = (3 === this._version ? "in" : "attribute") + ` ${a} ${r.name};
` + t
                    }
                    for (const s in this._config.varyings) {
                        const r = this._config.varyings[s];
                        e = 3 === this._version ? (t = `out ${r} ${s};
` + t, `in ${r} ${s};
` + e) : (t = `varying ${r} ${s};
` + t, `varying ${r} ${s};
` + e)
                    }
                    if (3 === this._version && (e = (e = (e = (e = (e = "out vec4 outColor;\n" + e).replace(/gl_FragColor/g, "outColor")).replace(/texture2D\(/g, "texture(")).replace(/textureCube\(/g, "texture(")).replace(/textureCubeLodEXT\(/g, "textureLod(")), W.addPrecision && null !== this._config.precision) {
                        const s = this._config.precision || W.precision || (W.precision = new bs);
                        t = s.vertHeader + t, e = s.fragHeader + e
                    }
                    if (this._config.extensions) {
                        for (const s of this._config.extensions.vert) t = `#extension ${s} : enable
` + t;
                        t += "\n";
                        for (const s of this._config.extensions.frag) e = `#extension ${s} : enable
` + e;
                        e += "\n"
                    }
                    3 === this._version && (t = "#version 300 es\n" + t, e = "#version 300 es\n" + e), s = s || new vs({
                        context: this._ctx,
                        source: t || "",
                        type: this._ctx.gl.VERTEX_SHADER
                    }), r = r || new vs({
                        context: this._ctx,
                        source: e || "",
                        type: this._ctx.gl.FRAGMENT_SHADER
                    })
                }
                return this._vertShader = s, this._fragShader = r, [this._vertShader, this._fragShader]
            }
            onProgramLinked(e) {
                this.retrieveMissingAttributeIndices(e), this.initUniforms()
            }
            retrieveMissingAttributeIndices(t) {
                var s = this._ctx.gl,
                    r = this._attributes;
                for (let e = 0; e < r.length; ++e) {
                    var i = r[e];
                    me(i.index) || (i.index = s.getAttribLocation(t, i.name), -1 === i.index && console.warn("Error! Attribute not found: " + i.name))
                }
            }
            bindAttributesWithExplicitIndices(t) {
                var s = this._ctx.gl,
                    r = this._attributes;
                for (let e = 0; e < r.length; ++e) {
                    var i = r[e].index;
                    me(i) && s.bindAttribLocation(t, i, r[e].name)
                }
            }
            getAttribute(e) {
                return this._attributesByName[e]
            }
            initUniforms() {
                this._uniforms = {}, this._textureUniforms = {}, this._arrayUniforms = {};
                var e = this._config.uniforms;
                for (const s in e) {
                    var t = e[s];
                    t.type === W.TYPE_SAMPLER_2D || t.type === W.TYPE_SAMPLER_CUBE ? this.addTextureUniform(s, t) : void 0 !== t.arrayLength ? (this.addArrayUniform(s, t), this._arrayUniforms[s] = t) : this.addUniform(s, t)
                }
            }
            addArrayUniform(t, s) {
                for (let e = 0; e < s.arrayLength; ++e) this.addUniform(t + `[${e}]`, s)
            }
            addUniform(e, t) {
                var s = t.type || "";
                let r = t.value,
                    i = !1,
                    a = !1;
                switch (t.type) {
                    case W.TYPE_MAT2:
                    case W.TYPE_MAT3:
                    case W.TYPE_MAT4:
                        i = !0;
                    case W.TYPE_IVEC2:
                    case W.TYPE_IVEC3:
                    case W.TYPE_IVEC4:
                    case W.TYPE_VEC2:
                    case W.TYPE_VEC3:
                    case W.TYPE_VEC4:
                        a = !0
                }
                let n = !0;
                if (null == r && (t.createInitialValue ? r = W.getUniformDefaultValue(s) : n = !1), t.alwaysDirty && (n = !0), !this._program) throw new Error("Program not linked yet!");
                var o = this._ctx.gl.getUniformLocation(this._program, e);
                o || console.log("Warning! Location for this uniform not found: " + e + "! The uniform may be mistyped or it's not used in the glsl code (the compiler removed it)."), this._uniforms[e] = {
                    location: o || void 0,
                    type: s,
                    isMatrix: i,
                    isVector: a,
                    initialValue: r,
                    value: r,
                    updatedValue: void 0,
                    dirty: n,
                    alwaysDirty: null != (e = t.alwaysDirty) && e
                }
            }
            addTextureUniform(e, t) {
                (t = Object.create(t)).type = W.TYPE_INT, void 0 === t.value && (t.value = Object.keys(this._textureUniforms).length), this.addUniform(e, t), t.texture || console.warn("Texture uniform must have a texture!"), this._textureUniforms[e] = {
                    texture: t.texture
                }
            }
            hasUniform(e) {
                return !!this._uniforms[e]
            }
            setUniform(e, t, s = !1) {
                var r = this._uniforms[e];
                r ? this._textureUniforms[e] && I.isTexture(t) ? this._textureUniforms[e].texture = t : r.value = t : this._arrayUniforms[e] ? this.setArrayUniform(e, t) : s || console.warn("No such uniform with name: " + e + "!")
            }
            setArrayUniform(t, s) {
                for (let e = 0; e < s.length; ++e) this.setUniform(t + `[${e}]`, s[e])
            }
            getUniform(e) {
                return this._uniforms[e]
            }
            updateUniforms() {
                for (const e in this._uniforms) this.updateUniform(e);
                this.bindTextureUniforms()
            }
            bindTextureUniforms() {
                for (const s in this._textureUniforms) {
                    var e = this._textureUniforms[s],
                        t = this._uniforms[s].value;
                    e.texture ? e.texture.bindTo(t) : console.warn("No texture for uniform: " + s)
                }
            }
            updateUniform(e, t = !1) {
                var s = this._ctx,
                    r = s.gl,
                    i = this._uniforms[e];
                if (void 0 !== i.value && (t || this.isDirty(i)) && i.location) {
                    const e = W.getUniformSetter(i.type, s);
                    i.isMatrix ? e.call(r, i.location, !1, i.value) : e.call(r, i.location, i.value), i.isVector ? i.updatedValue ? pe.B.copy(i.updatedValue, i.value) : i.updatedValue = i.value.slice(0) : i.updatedValue = i.value
                }
            }
            isDirty(e) {
                return void 0 === e.updatedValue || (e.isVector ? !pe.B.equals(e.value, e.updatedValue) : e.value !== e.updatedValue)
            }
            static getUniformSetter(e, t) {
                var s = t.gl;
                switch (e) {
                    case W.TYPE_FLOAT:
                        return s.uniform1f;
                    case W.TYPE_VEC2:
                        return s.uniform2fv;
                    case W.TYPE_VEC3:
                        return s.uniform3fv;
                    case W.TYPE_VEC4:
                        return s.uniform4fv;
                    case W.TYPE_BOOL:
                    case W.TYPE_SAMPLER_2D:
                    case W.TYPE_INT:
                        return s.uniform1i;
                    case W.TYPE_IVEC2:
                        return s.uniform2iv;
                    case W.TYPE_IVEC3:
                        return s.uniform3iv;
                    case W.TYPE_IVEC4:
                        return s.uniform4iv;
                    case W.TYPE_MAT2:
                        return s.uniformMatrix2fv;
                    case W.TYPE_MAT3:
                        return s.uniformMatrix3fv;
                    case W.TYPE_MAT4:
                        return s.uniformMatrix4fv
                }
                throw new Error("Unknown uniform type: " + e)
            }
            static getUniformDefaultValue(e) {
                switch (e) {
                    case "bool":
                        return !0;
                    case "float":
                    case "sampler2D":
                    case "texture":
                    case "int":
                        return 0;
                    case "vec2":
                        return new Float32Array(2);
                    case "vec3":
                        return new Float32Array(3);
                    case "vec4":
                        return new Float32Array(4);
                    case "ivec2":
                        return [0, 0];
                    case "ivec3":
                        return [0, 0, 0];
                    case "ivec4":
                        return [0, 0, 0, 0];
                    case "mat2":
                        return new Float32Array([1, 0, 0, 1]);
                    case "mat3":
                        return new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]);
                    case "mat4":
                        return new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1])
                }
                return null
            }
            enable() {
                this.use(), this.updateUniforms()
            }
            disable() {
                this.unUse()
            }
            use() {
                if (!this._program) throw new Error("Program not linked yet!");
                this._ctx.useProgram(this._program)
            }
            unUse() {
                this._ctx.useProgram(null)
            }
            dispose(e = !0) {
                this._program && this._ctx.deleteProgram(this._program), e && (this._vertShader && this._vertShader.dispose(), this._fragShader) && this._fragShader.dispose()
            }
            get attributes() {
                return this._attributes
            }
            get context() {
                return this._ctx
            }
        }
        W.TYPE_FLOAT = "float", W.TYPE_BOOL = "bool", W.TYPE_VEC2 = "vec2", W.TYPE_VEC3 = "vec3", W.TYPE_VEC4 = "vec4", W.TYPE_SAMPLER_2D = "sampler2D", W.TYPE_SAMPLER_CUBE = "samplerCube", W.TYPE_INT = "int", W.TYPE_IVEC2 = "ivec2", W.TYPE_IVEC3 = "ivec3", W.TYPE_IVEC4 = "ivec4", W.TYPE_MAT2 = "mat2", W.TYPE_MAT3 = "mat3", W.TYPE_MAT4 = "mat4", W.addPrecision = !0, W.createInitialUniformValues = !0, W.highestId = 0;
        class xs extends W {
            static getBaseConfig(e) {
                return {
                    context: e,
                    uniforms: {
                        u_posTransform: {
                            type: W.TYPE_VEC4,
                            value: [1, 1, 0, 0],
                            addToVert: !0
                        },
                        u_uvTransform: {
                            type: W.TYPE_MAT3,
                            value: R.w.create(),
                            addToVert: !0
                        },
                        u_texture: {
                            type: W.TYPE_SAMPLER_2D,
                            addToFrag: !0
                        }
                    },
                    vertSource: "\n\t\t\t\t\tvoid main(void)\n\t\t\t\t\t{\n\t\t\t\t\t\tvec3 transformedUV = u_uvTransform * vec3(a_uv, 1.0);\n\t\t\t\t\t\tv_uv = transformedUV.xy; //u_uvTransform.xy + u_uvTransform.zw;\n\t\t\t\t\t\t\n\t\t\t\t\t\tvec2 pos = a_pos.xy * u_posTransform.xy + u_posTransform.zw;\n\t\t\t\t\t\t\n\t\t\t\t\t\tgl_Position = vec4(pos, 0.0, 1.0);\n\t\t\t\t\t}\n\t\t\t\t",
                    fragSource: "\n\t\t\t\t\tvoid main()\n\t\t\t\t\t{\n\t\t\t\t\t\tgl_FragColor = texture2D(u_texture, v_uv);\n\t\t\t\t\t}\n\t\t\t\t",
                    attributes: [{
                        name: "a_pos",
                        semantic: A.p.POSITION,
                        size: 3
                    }, {
                        name: "a_uv",
                        semantic: A.p.TEXCOORD_0,
                        size: 2
                    }],
                    varyings: {
                        v_uv: "vec2"
                    }
                }
            }
            static mergeConfig(e) {
                var t = xs.getBaseConfig(e.context);
                return e.vertSource = e.vertSource || t.vertSource, e.fragSource = e.fragSource || t.fragSource, e.attributes = (t.attributes || []).concat(e.attributes || []), e.varyings = J.g.mergeConfig(t.varyings, e.varyings), e.uniforms = J.g.mergeConfig(t.uniforms, e.uniforms), e
            }
            constructor(e) {
                super(xs.mergeConfig(e))
            }
        }
        class Ts {
            static getInstance() {
                return Ts._instance || (Ts._instance = Ts.create()), Ts._instance
            }
            static create(e = !1, t = !0) {
                var s = new d.A(0, 0, 1, 1);
                return lt.createGeometry({
                    surface: s,
                    indices: e,
                    interleaved: !0,
                    uSteps: 1,
                    attributes: [{
                        semantic: A.p.POSITION,
                        size: 3
                    }, {
                        semantic: A.p.NORMAL,
                        size: 3
                    }, ...t ? [{
                        semantic: A.p.TEXCOORD_0,
                        size: 2
                    }] : []]
                })
            }
        }
        class ws {
            constructor(e) {
                this._pointSize = 0, this._techniqueKey = "", this._prepared = !1;
                var t, s = e;
                this._adapter = e.adapter, this._material = e.material, this._bufferAttributes = (null == (t = e.geometry) ? void 0 : t.getAttributes()) || [], this._program = s.program, this._programClass = s.programClass, this._uniforms = e.uniforms || {}, this.initTechniqueKey(e.geometry), this._materialEqualsKey = (null == (t = e.material) ? void 0 : t.getEqualsKey()) || ""
            }
            initTechniqueKey(e) {
                var t;
                e && (t = this._bufferAttributes.map(e => e.semantic).map(e => e).join("-"), e.mode === _.g.POINTS && (this._pointSize = window.devicePixelRatio), this._techniqueKey = t + "--" + this._pointSize)
            }
            getPointSize() {
                return this._pointSize ? "gl_PointSize = 1.0;" : ""
            }
            get techniqueKey() {
                return this._techniqueKey
            }
            hasBufferAttribute(t) {
                return this._bufferAttributes.some(e => e.semantic === t)
            }
            getBufferAttribute(t) {
                return this._bufferAttributes.find(e => e.semantic === t)
            }
            prepare() {
                this._prepared || (this.init(), this._prepared = !0)
            }
            init() {}
            getProgram() {
                if (this.prepare(), !this._program) {
                    var t = this.key,
                        s = this._adapter.shaderRegistry;
                    let e = s.get(t);
                    e || (e = this.createProgram(), s.set(t, e)), this._program = e
                }
                return this._program
            }
            createProgram() {
                return this._programClass ? new this._programClass(this._adapter.context) : null
            }
            enable() {
                var e = this.getProgram();
                for (const t in this._uniforms) e.setUniform(t, this._uniforms[t]);
                e.enable()
            }
            get key() {
                return this._programClass
            }
            get material() {
                return this._material
            }
            get materialEqualsKeys() {
                return this._materialEqualsKey
            }
            disable() {}
        }
        ws.bufferAttrs = [A.p.POSITION, A.p.NORMAL, A.p.TANGENT, A.p.COLOR, A.p.JOINTS_0, A.p.WEIGHTS_0, A.p.TEXCOORD_0];
        class Es {
            constructor(e, t) {
                this._uvTransform = M.R.create(), this._posTransform = g.v.create(), this._dstTexture = null, this._viewport = null, this._program = t || new xs(e);
                t = Ts.getInstance();
                this._drawUnit = new fs({
                    adapter: e,
                    technique: new ws({
                        adapter: e,
                        program: this._program
                    }),
                    geometry: t
                })
            }
            render(e) {
                var t = e.srcRect,
                    s = e.srcTexture.width,
                    r = e.srcTexture.height,
                    s = [t.left / s, t.bottom / r, t.right / s, t.top / r],
                    t = (this._uvTransform = [s[2] - s[0], 0, 0, 0, s[3] - s[1], 0, s[0], s[1], 1], this._srcTexture = e.srcTexture, this._dstTexture = e.dstTexture, e.dstRect);
                this._posTransform = [2, 2, 0, 0], this._viewport = null != (r = e.viewport) ? r : [t.left, t.bottom, t.width, t.height], this._render()
            }
            renderUnion(s) {
                var r = d.A.getUnionRectangles(s.dstRect, s.srcRect);
                if (r) {
                    var i = s.dstRect,
                        a = s.srcRect,
                        n = i.width,
                        o = i.height,
                        l = i.x,
                        h = i.y,
                        c = r.result1,
                        l = [c.width / n * 2, c.height / o * 2, -(l - (c.x + i.left)) / n * 2, -(h - (c.y + i.bottom)) / o * 2],
                        h = r.result2;
                    let e = a.width,
                        t = a.height;
                    s.textureRect && (e = s.textureRect.width, t = s.textureRect.height);
                    c = [h.left / e, h.bottom / t, h.right / e, h.top / t], i = (s.processUV && s.processUV(c), [c[2] - c[0], 0, 0, 0, c[3] - c[1], 0, c[0], c[1], 1]);
                    s.uvTransform && R.w.multiply(i, s.uvTransform, i), this._uvTransform = i, this._posTransform = l, this._srcTexture = s.srcTexture || void 0, this._dstTexture = s.dstTexture || null, this._viewport = null != (a = s.viewport) ? a : s.dstTexture ? [0, 0, n, o] : null, this._render()
                }
                return !!r
            }
            _render() {
                var e = this._program.context,
                    t = (this._program.setUniform("u_uvTransform", this._uvTransform), this._program.setUniform("u_posTransform", this._posTransform), this._srcTexture && this._program.setUniform("u_texture", this._srcTexture), this._viewport);
                t && (this._dstTexture && this._dstTexture.initFramebuffer().bind(), e.viewport(t)), this._drawUnit.draw()
            }
            get program() {
                return this._program
            }
            dispose(e = 0) {}
        }
        var ge = c(5979);
        class Cs {
            constructor() {
                this._programs = new Map
            }
            set(e, t) {
                this._programs.set(e, t)
            }
            get(e) {
                return this._programs.get(e)
            }
        }
        var _e = c(7054),
            fe = c(9866);
        class ys extends ws {
            constructor(e) {
                super(e), this._source = {
                    vert: {
                        declaration: "",
                        body: ""
                    },
                    frag: {
                        declaration: "",
                        body: ""
                    },
                    morph: ""
                }, this._baseUniforms = {}, this._attributes = [], this._skin = e.skin
            }
            addSkin() {
                var e, t;
                this.hasBufferAttribute(A.p.JOINTS_0) && this.hasBufferAttribute(A.p.WEIGHTS_0) && (this._skin ? (this.defineBool("HAS_SKIN"), e = this._bufferAttributes.find(e => e.semantic === A.p.JOINTS_0), t = this._bufferAttributes.find(e => e.semantic === A.p.WEIGHTS_0), e && t ? (this._attributes.push({
                    name: "a_joints_0",
                    size: 4,
                    sizeY: 1,
                    componentType: e.componentType,
                    normalized: e.normalized,
                    semantic: A.p.JOINTS_0
                }), this._attributes.push({
                    name: "a_weights_0",
                    size: 4,
                    sizeY: 1,
                    componentType: t.componentType,
                    normalized: t.normalized,
                    semantic: A.p.WEIGHTS_0
                })) : console.error("No joint or weight for NodeTechnique"), this._baseUniforms.u_bones = {
                    type: W.TYPE_MAT4,
                    addToVert: !0,
                    arrayLength: this._skin.jointCount
                }) : console.error("No skin for NodeTechnique"))
            }
            defineBool(e) {
                this._source.vert.declaration += `#define ${e} true
`, this._source.frag.declaration += `#define ${e} true
`
            }
            hasAttribute(t) {
                return this._attributes.some(e => e.semantic === t)
            }
            enableNode(e, t, s) {
                this.prepare(), this.updateMaterialUniforms(s), this.updateNodeUniforms(e, t), this.updateSides(t), this.updateSkin(t), super.enable(), this.enableBlend()
            }
            updateInstance(e, t = !0) {
                var s = this.getProgram(),
                    e = e.worldMatrixAutoUpdate && e.scene ? e.worldMatrix : e.calculateWorldMatrix();
                s.setUniform("u_ModelMatrix", e, !0), t && s.updateUniform("u_ModelMatrix", !0)
            }
            updateSkin(e) {
                if (this._skin) {
                    const e = this.getProgram();
                    this._skin.update(e)
                }
            }
            updateMaterialUniforms(e) {}
            enableTextureUniform(e, t, s, r) {
                t && (t = this._adapter.getTexture(t), r.setUniform(e, t), s) && r.setUniform(e + "_transform", s.mat)
            }
            updateNodeUniforms(e, t) {
                var s = e.getViewProjectionMatrix(),
                    r = this.getProgram();
                r.setUniform("u_ViewProjectionMatrix", s, !0), this.updateInstance(t, !1), null != e && e.getEye && r.setUniform("u_Camera", e.getEye(), !0)
            }
            updateSides(e) {
                var t = this._material,
                    s = this.getProgram();
                s.setUniform("u_doubleSided", t.doubleSided);
                let r = t.side === fe.N.BACK ? -1 : 1;
                t.doubleSided && e.isMirrored() && (r *= -1), s.setUniform("u_flipSide", r), this.setCulling(e)
            }
            setCulling(t) {
                var s = this._material,
                    r = this._adapter.context;
                if (s.doubleSided) r.disable(he.CULL_FACE);
                else {
                    r.enable(he.CULL_FACE);
                    let e = !0;
                    s.side === fe.N.BACK && (e = !e), t.isMirrored() && (e = !e), r.cullFace(e ? _.g.BACK : _.g.FRONT)
                }
            }
            enableBlend() {
                var e = this._adapter.context;
                this._material.alphaMode === _e.mM.BLEND ? e.enableStandardBlend(!0) : e.blend(null)
            }
        }
        class As {
            constructor(e = {}) {
                var t;
                this._color1 = null != (t = e.color1) ? t : As.defaultConfig.color1, this._color2 = null != (t = e.color2) ? t : As.defaultConfig.color2, this._noiseAlpha = null != (t = e.noiseAlpha) ? t : As.defaultConfig.noiseAlpha, this._grainScale = null != (t = e.grainScale) ? t : As.defaultConfig.grainScale
            }
            set color1(e) {
                this._color1 = e
            }
            get color1() {
                return this._color1
            }
            set color2(e) {
                this._color2 = e
            }
            get color2() {
                return this._color2
            }
            set noiseAlpha(e) {
                this._noiseAlpha = e
            }
            get noiseAlpha() {
                return this._noiseAlpha
            }
            set grainScale(e) {
                this._grainScale = e
            }
            get grainScale() {
                return this._grainScale
            }
        }
        As.defaultConfig = {
            color1: 16777215,
            color2: 13421772,
            noiseAlpha: .25,
            grainScale: 1.5
        };
        class Ms {
            render(e, t) {
                e = m.I.decomposeAndNormalizeRGBA(e.color, 1);
                t.context.clear(e)
            }
        }
        class Rs {
            constructor(e) {
                this._adapter = e
            }
            render(e) {
                var t = this._adapter.context,
                    s = this.drawUnit.technique.getProgram(),
                    [r, i] = [t.gl.drawingBufferWidth, t.gl.drawingBufferHeight];
                s.setUniform("u_posTransform", [2, 2, 0, 0]), s.setUniform("u_size", [t.gl.drawingBufferWidth, t.gl.drawingBufferHeight]), s.setUniform("u_size", [1, 1]), s.setUniform("u_color1", m.I.decomposeAndNormalizeRGB(e.color1)), s.setUniform("u_color2", m.I.decomposeAndNormalizeRGB(e.color2)), s.setUniform("u_grainScale", e.grainScale / Math.min(r, i)), s.setUniform("u_offset", [0, 0]), s.setUniform("u_noiseAlpha", e.noiseAlpha), t.depthMask = !1, this.drawUnit.draw(), t.depthMask = !0
            }
            get drawUnit() {
                var e, t;
                return this._drawUnit || (e = new xs({
                    context: this._adapter.context,
                    fragSource: "\n\t\t\t\t\n\t\t\t\tvec3 mod289(vec3 x)\n\t\t\t\t{\n\t\t\t\t  return x - floor(x * (1.0 / 289.0)) * 289.0;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvec4 mod289(vec4 x)\n\t\t\t\t{\n\t\t\t\t  return x - floor(x * (1.0 / 289.0)) * 289.0;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvec4 permute(vec4 x)\n\t\t\t\t{\n\t\t\t\t  return mod289(((x*34.0)+1.0)*x);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvec4 taylorInvSqrt(vec4 r)\n\t\t\t\t{\n\t\t\t\t  return 1.79284291400159 - 0.85373472095314 * r;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvec3 fade(vec3 t) {\n\t\t\t\t  return t*t*t*(t*(t*6.0-15.0)+10.0);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfloat snoise3D(vec3 v)\n\t\t\t\t  {\n\t\t\t\t  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n\t\t\t\t  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\t\t\t\t\n\t\t\t\t// First corner\n\t\t\t\t  vec3 i  = floor(v + dot(v, C.yyy) );\n\t\t\t\t  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\t\t\t\t\n\t\t\t\t// Other corners\n\t\t\t\t  vec3 g = step(x0.yzx, x0.xyz);\n\t\t\t\t  vec3 l = 1.0 - g;\n\t\t\t\t  vec3 i1 = min( g.xyz, l.zxy );\n\t\t\t\t  vec3 i2 = max( g.xyz, l.zxy );\n\t\t\t\t\n\t\t\t\t  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n\t\t\t\t  //   x1 = x0 - i1  + 1.0 * C.xxx;\n\t\t\t\t  //   x2 = x0 - i2  + 2.0 * C.xxx;\n\t\t\t\t  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n\t\t\t\t  vec3 x1 = x0 - i1 + C.xxx;\n\t\t\t\t  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n\t\t\t\t  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\t\t\t\t\n\t\t\t\t// Permutations\n\t\t\t\t  i = mod289(i);\n\t\t\t\t  vec4 p = permute( permute( permute(\n\t\t\t\t             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n\t\t\t\t           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n\t\t\t\t           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\t\t\t\t\n\t\t\t\t// Gradients: 7x7 points over a square, mapped onto an octahedron.\n\t\t\t\t// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n\t\t\t\t  float n_ = 0.142857142857; // 1.0/7.0\n\t\t\t\t  vec3  ns = n_ * D.wyz - D.xzx;\n\t\t\t\t\n\t\t\t\t  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\t\t\t\t\n\t\t\t\t  vec4 x_ = floor(j * ns.z);\n\t\t\t\t  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\t\t\t\t\n\t\t\t\t  vec4 x = x_ *ns.x + ns.yyyy;\n\t\t\t\t  vec4 y = y_ *ns.x + ns.yyyy;\n\t\t\t\t  vec4 h = 1.0 - abs(x) - abs(y);\n\t\t\t\t\n\t\t\t\t  vec4 b0 = vec4( x.xy, y.xy );\n\t\t\t\t  vec4 b1 = vec4( x.zw, y.zw );\n\t\t\t\t\n\t\t\t\t  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n\t\t\t\t  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n\t\t\t\t  vec4 s0 = floor(b0)*2.0 + 1.0;\n\t\t\t\t  vec4 s1 = floor(b1)*2.0 + 1.0;\n\t\t\t\t  vec4 sh = -step(h, vec4(0.0));\n\t\t\t\t\n\t\t\t\t  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n\t\t\t\t  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\t\t\t\t\n\t\t\t\t  vec3 p0 = vec3(a0.xy,h.x);\n\t\t\t\t  vec3 p1 = vec3(a0.zw,h.y);\n\t\t\t\t  vec3 p2 = vec3(a1.xy,h.z);\n\t\t\t\t  vec3 p3 = vec3(a1.zw,h.w);\n\t\t\t\t\n\t\t\t\t//Normalise gradients\n\t\t\t\t  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n\t\t\t\t  p0 *= norm.x;\n\t\t\t\t  p1 *= norm.y;\n\t\t\t\t  p2 *= norm.z;\n\t\t\t\t  p3 *= norm.w;\n\t\t\t\t\n\t\t\t\t// Mix final noise value\n\t\t\t\t  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n\t\t\t\t  m = m * m;\n\t\t\t\t  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n\t\t\t\t                                dot(p2,x2), dot(p3,x3) ) );\n\t\t\t\t  }\n  \n\t\t\t\t// Classic Perlin noise, periodic variant\n\t\t\t\tfloat pnoise3D(vec3 P, vec3 rep)\n\t\t\t\t{\n\t\t\t\t  vec3 Pi0 = mod(floor(P), rep); // Integer part, modulo period\n\t\t\t\t  vec3 Pi1 = mod(Pi0 + vec3(1.0), rep); // Integer part + 1, mod period\n\t\t\t\t  Pi0 = mod289(Pi0);\n\t\t\t\t  Pi1 = mod289(Pi1);\n\t\t\t\t  vec3 Pf0 = fract(P); // Fractional part for interpolation\n\t\t\t\t  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n\t\t\t\t  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n\t\t\t\t  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n\t\t\t\t  vec4 iz0 = Pi0.zzzz;\n\t\t\t\t  vec4 iz1 = Pi1.zzzz;\n\t\t\t\t\n\t\t\t\t  vec4 ixy = permute(permute(ix) + iy);\n\t\t\t\t  vec4 ixy0 = permute(ixy + iz0);\n\t\t\t\t  vec4 ixy1 = permute(ixy + iz1);\n\t\t\t\t\n\t\t\t\t  vec4 gx0 = ixy0 * (1.0 / 7.0);\n\t\t\t\t  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n\t\t\t\t  gx0 = fract(gx0);\n\t\t\t\t  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n\t\t\t\t  vec4 sz0 = step(gz0, vec4(0.0));\n\t\t\t\t  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n\t\t\t\t  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\t\t\t\t\n\t\t\t\t  vec4 gx1 = ixy1 * (1.0 / 7.0);\n\t\t\t\t  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n\t\t\t\t  gx1 = fract(gx1);\n\t\t\t\t  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n\t\t\t\t  vec4 sz1 = step(gz1, vec4(0.0));\n\t\t\t\t  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n\t\t\t\t  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\t\t\t\t\n\t\t\t\t  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n\t\t\t\t  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n\t\t\t\t  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n\t\t\t\t  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n\t\t\t\t  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n\t\t\t\t  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n\t\t\t\t  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n\t\t\t\t  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\t\t\t\t\n\t\t\t\t  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n\t\t\t\t  g000 *= norm0.x;\n\t\t\t\t  g010 *= norm0.y;\n\t\t\t\t  g100 *= norm0.z;\n\t\t\t\t  g110 *= norm0.w;\n\t\t\t\t  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n\t\t\t\t  g001 *= norm1.x;\n\t\t\t\t  g011 *= norm1.y;\n\t\t\t\t  g101 *= norm1.z;\n\t\t\t\t  g111 *= norm1.w;\n\t\t\t\t\n\t\t\t\t  float n000 = dot(g000, Pf0);\n\t\t\t\t  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n\t\t\t\t  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n\t\t\t\t  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n\t\t\t\t  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n\t\t\t\t  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n\t\t\t\t  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n\t\t\t\t  float n111 = dot(g111, Pf1);\n\t\t\t\t\n\t\t\t\t  vec3 fade_xyz = fade(Pf0);\n\t\t\t\t  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n\t\t\t\t  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n\t\t\t\t  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\n\t\t\t\t  return 2.2 * n_xyz;\n\t\t\t\t}\n\t\t\t\t// glsl-film-grain\n\t\t\t\tfloat grain(vec2 texCoord, vec2 resolution, float frame, float multiplier) {\n\t\t\t\t\tvec2 mult = texCoord * resolution;\n\t\t\t\t\tfloat offset = snoise3D(vec3(mult / multiplier, frame));\n\t\t\t\t\tfloat n1 = pnoise3D(vec3(mult, offset), vec3(1.0/texCoord * resolution, 1.0));\n\t\t\t\t\treturn n1 / 2.0 + 0.5;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfloat grain(vec2 texCoord, vec2 resolution, float frame) {\n\t\t\t\t\treturn grain(texCoord, resolution, frame, 2.5);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfloat grain(vec2 texCoord, vec2 resolution) {\n\t\t\t\t\treturn grain(texCoord, resolution, 0.0);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// glsl-blend-soft-light\n\t\t\t\tvec3 blendSoftLight(vec3 base, vec3 blend) {\n\t\t\t\t    return mix(\n\t\t\t\t        sqrt(base) * (2.0 * blend - 1.0) + 2.0 * base * (1.0 - blend), \n\t\t\t\t        2.0 * base * blend + base * base * (1.0 - 2.0 * blend), \n\t\t\t\t        step(base, vec3(0.5))\n\t\t\t\t    );\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvoid main()\n\t\t\t\t{\n\t\t\t\t// uniforms\n\t\t\t\t\n\t\t\t\t\tfloat aspect = 1.0;\n\t\t\t\t\t\n\t\t\t\t\tvec2 offset = vec2(-0.0, -0.0);\n\t\t\t\t\tvec2 scale  = u_size;\n\t\t\t\t\t\n\t\t\t\t\tbool aspectCorrection = true;\n\t\t\t\t\t\n\t\t\t\t\tfloat grainScale = u_grainScale; // 0.002; // 0.005;\n\t\t\t\t\tfloat grainTime = 0.0;\n\t\t\t\t\t\n\t\t\t\t\tvec2 u_smooth = vec2(0.0, 1.0);\n\t\t\t\t\t\n\t\t\t\t// end of uniforms\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tvec2 vUv = v_uv; // gl_FragCoord.xy / u_size;\n\t\t\t\t\tvec2 q = vec2(vUv - 0.5);\n\t\t\t\t\t\n\t\t\t\t\tq /= scale;\n\t\t\t\t\tq -= offset;\n\t\t\t\t\t\n\t\t\t\t\tfloat dst = length(q);\n\t\t\t\t\tdst = smoothstep(u_smooth.x, u_smooth.y, dst);\n\t\t\t\t\tvec3 color = mix(u_color1, u_color2, dst);\n\t\t\t\t\t\n\t\t\t\t\tif (u_noiseAlpha > 0.0 && grainScale > 0.0)\n\t\t\t\t\t{\n\t\t\t\t\t\tfloat gSize = 1.0 / grainScale;\n\t\t\t\t\t\tfloat g = grain(vUv, vec2(gSize * aspect, gSize), grainTime);\n\t\t\t\t\t\tvec3 noiseColor = blendSoftLight(color, vec3(g));\n\t\t\t\t\t\tgl_FragColor.rgb = mix(color, noiseColor, u_noiseAlpha);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tgl_FragColor.rgb = color;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tgl_FragColor.a = 1.0;\n\t\t\t\t}\n\t\t\t",
                    uniforms: {
                        u_texture: {
                            type: W.TYPE_INT,
                            addToFrag: !1
                        },
                        u_size: {
                            type: W.TYPE_VEC2,
                            addToFrag: !0
                        },
                        u_color1: {
                            type: W.TYPE_VEC3,
                            addToFrag: !0
                        },
                        u_color2: {
                            type: W.TYPE_VEC3,
                            addToFrag: !0
                        },
                        u_grainScale: {
                            type: W.TYPE_FLOAT,
                            addToFrag: !0
                        },
                        u_offset: {
                            type: W.TYPE_VEC2,
                            addToFrag: !0
                        },
                        u_noiseAlpha: {
                            type: W.TYPE_FLOAT,
                            addToFrag: !0
                        }
                    }
                }), t = Ts.getInstance(), this._drawUnit = new fs({
                    adapter: this._adapter,
                    technique: new ws({
                        adapter: this._adapter,
                        program: e
                    }),
                    geometry: t
                })), this._drawUnit
            }
        }
        var E = c(7734);
        class Ss {
            constructor() {
                this._nodes = {
                    transparent: [],
                    opaque: {}
                }, this._renderObjects = new Map, this.clearNodes()
            }
            updateNodes(e, t) {
                this.clearNodes(), this.parse(e, t), this.sort()
            }
            clearNodes() {
                this._nodes = {
                    transparent: [],
                    opaque: {}
                }
            }
            parse(e, t) {
                if (e.visible) {
                    e instanceof K.x || this.parseNode(e, t);
                    for (const K of e.children) this.parse(K, t)
                }
            }
            parseNode(e, t) {
                for (const s of e.renderNodes) this.parseRenderNode(s, t)
            }
            parseRenderNode(e, t) {
                if (e.transparent) {
                    this._renderObjects.has(e) || this._renderObjects.set(e, {
                        viewZ: 0
                    });
                    var s = this._renderObjects.get(e);
                    s && (s.viewZ = E.x.calculateViewZ(e.node, t)), this._nodes.transparent.push(e)
                } else {
                    const t = e.material.getEqualsKey() + "-" + e.geometry.id;
                    this._nodes.opaque[t] || (this._nodes.opaque[t] = []), this._nodes.opaque[t].push(e)
                }
            }
            sort() {
                this.sortByZ(this._nodes.transparent, !0)
            }
            sortByZ(e, s) {
                e.sort((e, t) => {
                    e = null != (e = null == (e = this._renderObjects.get(e)) ? void 0 : e.viewZ) ? e : 0, t = null != (t = null == (t = this._renderObjects.get(t)) ? void 0 : t.viewZ) ? t : 0;
                    return s ? t - e : e - t
                })
            }
            get nodes() {
                return this._nodes
            }
        }
        class Ns {
            constructor(e) {
                this._config = e, this._backgroundRenderers = {
                    solid: new Ms,
                    vignette: new Rs(e.engine.adapter)
                }, this._parser = new Ss
            }
            render(e, t) {
                var s;
                t = t || this._config.camera, (e = e || this._config.scene) && t && ((s = this._config.engine.adapter.context).viewport([0, 0, s.gl.drawingBufferWidth, s.gl.drawingBufferHeight]), this.renderBackground(e), this.updateNodes(e, t), e.updateWorldMatrices(), this.opaquePass(t), this.transparentPass(t), this._config.engine.adapter.context.vao.unbind())
            }
            async onReady() {}
            renderBackground(e) {
                e = e.background;
                e instanceof Q.$ ? this._backgroundRenderers.solid.render(e, this._config.engine.adapter) : e instanceof As && this._backgroundRenderers.vignette.render(e)
            }
            updateNodes(e, t) {
                this._parser.updateNodes(e, t)
            }
            opaquePass(t) {
                const s = this._parser.nodes;
                for (const e in s.opaque) {
                    var r = s.opaque[e];
                    if (0 < r.length) {
                        const s = this.renderNode(r[0], t);
                        for (let e = 1; e < r.length; ++e) this.renderNode(r[e], t, s)
                    }
                }
            }
            transparentPass(e) {
                for (const t of this._parser.nodes.transparent) this.renderNode(t, e)
            }
            renderNode(e, t, s) {
                if (this._config.renderFn) this._config.renderFn(e, t);
                else {
                    e = this._config.engine.adapter.getMeshRenderer(e);
                    if (!s) return e.render(t);
                    e.renderInstance(s)
                }
                return null
            }
            get engine() {
                return this._config.engine
            }
        }
        class Is {
            static createUniforms() {
                return {
                    u_id: {
                        type: W.TYPE_VEC4,
                        addToFrag: !0,
                        value: [0, 0, 0, 0]
                    },
                    u_renderIds: {
                        type: W.TYPE_BOOL,
                        addToFrag: !0,
                        value: !1
                    }
                }
            }
            static getFragmentChunk(e = "1.0") {
                return `
			if (u_renderIds)
			{
				if (${e} > 0.01)
				{
					gl_FragColor = u_id;
					return;
				}
				else
				{
					discard;
				}
			}
			`
            }
            constructor(e) {
                this._ids = new Map, this._nodes = new Map, this.renderNode = (e, t, s = e) => {
                    const r = this._renderer.engine;
                    if (!this._ids.has(s)) {
                        const e = this._ids.size;
                        this._ids.set(s, e), this._nodes.set(e, s)
                    }
                    const i = this._ids.get(s);
                    if (void 0 !== i) {
                        const s = this.id2color(i),
                            a = r.adapter.getMeshRenderer(e);
                        if (a.drawUnit) {
                            const r = a.drawUnit.technique.getProgram(),
                                i = (r.setUniform("u_renderIds", !0), r.setUniform("u_id", s), e.material.wireframe);
                            e.material.wireframe = !1, a.render(t), e.material.wireframe = i, r.setUniform("u_renderIds", !1)
                        }
                    }
                }, this._renderer = new Ns({
                    engine: e,
                    renderFn: this.renderNode
                })
            }
            pick(e, t, s, r, i) {
                var a = e[0],
                    e = t[1] - e[1],
                    t = (this._texture = this._texture || new I({
                        context: this._renderer.engine.adapter.context
                    }), this._texture.setSize(t[0], t[1]), this._texture.initFramebuffer(!0)),
                    s = (t.setAsRenderTarget(), t.clear([1, 1, 1, 1]), this._renderer.render(s, r), null != i && i(this), t.unbind(), v.O.readPixelsWebGL({
                        texture: this._texture,
                        rect: [a, e, 1, 1]
                    })),
                    r = this.color2id(s);
                return this._nodes.get(r) || null
            }
            color2id(e) {
                return m.I.rgb2hex(e[0], e[1], e[2])
            }
            id2color(e) {
                return m.I.decomposeAndNormalizeRGBA(e, 1)
            }
        }
        class Ps extends ys {
            constructor(e, t, s, r) {
                super({
                    program: null,
                    adapter: r,
                    geometry: t,
                    material: e,
                    skin: s
                }), this._texCoordinates = {}, this._textures = {}, this._sources = {
                    vert: "",
                    frag: ""
                }, this._extensions = {
                    vert: [],
                    frag: []
                }, this._supportedMorphTargets = new Set
            }
            init() {
                this.initUniforms(), this.initAttributes(), this.addSkin(), this.addIBL(), this.addTextureInfo("u_baseColorTexture", "HAS_BASECOLORMAP", this.material.baseColorTextureInfo), this.addTextureInfo("u_metallicRoughnessTexture", "HAS_METALROUGHNESSMAP", this.material.metallicRoughnessTextureInfo), this.addTextureInfo("u_emissiveTexture", "HAS_EMISSIVEMAP", this.material.emissiveTextureInfo), this.addNormalTexture(), this.addOcclusionTexture(), this.addTexCoordAttributes(), this.addMorphTargets(), this.createSources()
            }
            initUniforms() {
                this._baseUniforms = {
                    u_alphaCutoff: {
                        type: W.TYPE_FLOAT,
                        addToFrag: !0
                    },
                    u_doubleSided: {
                        type: W.TYPE_BOOL,
                        addToFrag: !0
                    },
                    u_flipSide: {
                        type: W.TYPE_FLOAT,
                        addToFrag: !0
                    },
                    u_ViewProjectionMatrix: {
                        type: W.TYPE_MAT4,
                        addToVert: !0
                    },
                    u_ModelMatrix: {
                        type: W.TYPE_MAT4,
                        addToVert: !0
                    },
                    u_Camera: {
                        type: W.TYPE_VEC3,
                        addToFrag: !0
                    },
                    u_LightDirection: {
                        type: W.TYPE_VEC3,
                        addToFrag: !0
                    },
                    u_ambientLight: {
                        type: W.TYPE_VEC3,
                        addToFrag: !0
                    },
                    u_LightColor: {
                        type: W.TYPE_VEC3,
                        addToFrag: !0
                    },
                    u_baseColorFactor: {
                        type: W.TYPE_VEC4,
                        addToFrag: !0
                    },
                    u_alphaMode: {
                        type: W.TYPE_FLOAT,
                        addToFrag: !0
                    },
                    u_emissiveFactor: {
                        type: W.TYPE_VEC3,
                        addToFrag: !0
                    },
                    u_metallicRoughnessValues: {
                        type: W.TYPE_VEC2,
                        addToFrag: !0
                    },
                    u_gamma: {
                        type: W.TYPE_FLOAT,
                        addToFrag: !0
                    },
                    ...Is.createUniforms()
                }
            }
            initAttributes() {
                this._attributes = [{
                    name: "a_position",
                    size: 3,
                    semantic: A.p.POSITION
                }], this.hasBufferAttribute(A.p.NORMAL) && (this._attributes.push({
                    name: "a_normal",
                    size: 3,
                    semantic: A.p.NORMAL
                }), this.defineBool("HAS_NORMALS"), this.material.normalTextureInfo.texture, this.hasBufferAttribute(A.p.TANGENT)) && (this._attributes.push({
                    name: "a_tangent",
                    size: 4,
                    semantic: A.p.TANGENT
                }), this.defineBool("HAS_TANGENTS"));
                var e = this._adapter.context;
                e.extensions.enableStandardDerivatives(), e.version < 2 && this._extensions.frag.push(ms.GL_OES_standard_derivatives), this.getBufferAttribute(A.p.COLOR) && (this._attributes.push({
                    name: "a_color",
                    size: 4,
                    semantic: A.p.COLOR
                }), this.defineBool("HAS_VERTEXCOLOR"))
            }
            addMorphTargets() {
                const e = this._bufferAttributes,
                    t = [],
                    s = this._adapter.context,
                    r = [];
                for (const t of e)
                    if (0 === t.semantic.indexOf(A.p.MORPH_PREFIX)) {
                        const e = A.p.decomposeMorph(t.semantic)["index"];
                        r[e] = r[e] || [], r[e].push(t)
                    }
                for (const e of r)
                    if (e) {
                        const r = s.getParameter(s.gl.MAX_VERTEX_ATTRIBS) - this._attributes.length;
                        if (e.length > r) break;
                        for (const s of e) {
                            const {
                                semantic: e,
                                index: r
                            } = A.p.decomposeMorph(s.semantic), i = `a_morph_${e}_` + r;
                            this._supportedMorphTargets.add(r), this._attributes.push({
                                name: i,
                                size: 3,
                                semantic: s.semantic
                            }), this._source.morph += `
				${e} += u_weight_${r} * ${i};
			`, t[r] = !0
                        }
                    }
                for (const e in t) this._baseUniforms["u_weight_" + e] = {
                    type: W.TYPE_FLOAT,
                    addToVert: !0,
                    value: 0
                }
            }
            addTexCoordAttributes() {
                this._attributes = this._attributes.concat(this.getTexCoordAttributes())
            }
            createSources() {
                this._sources.vert = `
				${this._source.vert.declaration}
			
				void main()
				{
					${this.getVaryingConnections()}
					
					vec3 position = a_position;
					
				#if defined(HAS_NORMALS)
					vec3 normal = a_normal;
					// TODO should use normal matrix if it has non uniform scale
					vec3 worldNormal = vec3(u_ModelMatrix * vec4(normal, 0.0));
				#endif
				
				#if defined(HAS_NORMALS) && defined(HAS_TANGENTS)
					vec3 tangent = a_tangent.xyz;
				#endif
					
					// this might use position, normal, tangent:
					${this._source.morph}
					
			#ifdef HAS_NORMALS
				#if defined(HAS_TANGENTS)
					vec3 normalW    = normalize(worldNormal);
					vec3 tangentW   = normalize(vec3(u_ModelMatrix * vec4(tangent, 0.0)));
					vec3 bitangentW = cross(normalW, tangentW) * a_tangent.w;
					v_TBN = mat3(tangentW, bitangentW, normalW);
				#else
					v_normal = worldNormal;
				#endif
			#endif
			
				#ifdef HAS_VERTEXCOLOR
					v_color = a_color;
				#endif
			
					${this._source.vert.body}
					
					vec4 worldPosition = u_ModelMatrix * vec4(position, 1.0);

		#ifdef HAS_SKIN
					
					mat4 skinMatrix = u_bones[int(a_joints_0.x)] * a_weights_0.x +
					                  u_bones[int(a_joints_0.y)] * a_weights_0.y +
					                  u_bones[int(a_joints_0.z)] * a_weights_0.z +
					                  u_bones[int(a_joints_0.w)] * a_weights_0.w;
					
					worldPosition = skinMatrix * vec4(position, 1.0);
					
					// TODO this is not verified
			#ifdef HAS_NORMALS
				#if defined(HAS_TANGENTS)
					normalW    = normalize(normal);
					tangentW   = normalize(tangent);
					bitangentW = cross(normalW, tangentW) * a_tangent.w;
					v_TBN = mat3(skinMatrix) * mat3(tangentW, bitangentW, normalW);
				#else
					v_normal = vec3(skinMatrix * vec4(normal, 0.0));
				#endif
			#endif

		#endif
					
					v_position = worldPosition.xyz / worldPosition.w;
					gl_Position = u_ViewProjectionMatrix * worldPosition;
					${this.getPointSize()}
				}
			`, this._sources.frag = `
				${this._source.frag.declaration}
				
				const float M_PI = 3.141592653589793;
				
				struct PBRInfo
				{
					float NdotL;
					float NdotV;
					float NdotH;
					float LdotH;
					float VdotH;
					float perceptualRoughness;
					float metalness;
					vec3 reflectance0;
					vec3 reflectance90;
					float alphaRoughness;
					vec3 diffuseColor;
					vec3 specularColor;
				};
				
				#define MANUAL_SRGB true
				vec4 SRGBtoLINEAR(vec4 srgbIn)
				{
					#ifdef MANUAL_SRGB
						#ifdef SRGB_FAST_APPROXIMATION
							vec3 linOut = pow(srgbIn.xyz, vec3(2.2));
						#else
							vec3 bLess = step(vec3(0.04045), srgbIn.xyz);
							vec3 linOut = mix(srgbIn.xyz / vec3(12.92), pow((srgbIn.xyz + vec3(0.055)) / vec3(1.055), vec3(2.4)), bLess);
						#endif
							return vec4(linOut, srgbIn.w);;
					#else
						return srgbIn;
					#endif
				}
				
				vec3 getNormal()
				{
			#ifdef HAS_TANGENTS
					mat3 tbn = v_TBN;
			#else
					vec3 pos_dx = dFdx(v_position);
					vec3 pos_dy = dFdy(v_position);
					
					vec3 v_uv = ${this.getUV()};
					vec3 tex_dx = dFdx(v_uv);
					vec3 tex_dy = dFdy(v_uv);
					
					vec3 t = (tex_dy.t * pos_dx - tex_dx.t * pos_dy) / (tex_dx.s * tex_dy.t - tex_dy.s * tex_dx.t);
					
				#ifdef HAS_NORMALS
					vec3 ng = normalize(v_normal);
				#else
					vec3 ng = normalize(cross(pos_dx, pos_dy));
				#endif
					t = normalize(t - ng * dot(ng, t));
					vec3 b = normalize(cross(ng, t));
					mat3 tbn = mat3(t, b, ng);
			#endif
				
					// Flip normal if doubleSided and facing back
					//tbn[2] *= u_doubleSided ? (2.0 * float(gl_FrontFacing) - 1.0) : u_flipSide;
					if (u_doubleSided)
					{
						tbn[2] *= (2.0 * float(gl_FrontFacing) - 1.0);
					}
					
					tbn[2] *= u_flipSide;
			
				#ifdef HAS_NORMALMAP
					vec3 n = ${this.sample("u_normalTexture")}.rgb;
					n = (n * 2.0 - 1.0) * vec3(u_normalScale, u_normalScale, 1.0);
					n = normalize(tbn * n); // Convert from tangent space to world space?
				#else
					vec3 n = normalize(tbn[2]);
				#endif
				
					return n;
				}
				
			#ifdef USE_IBL
				vec3 getIBLContribution(PBRInfo pbrInputs, vec3 n, vec3 reflection)
				{
					// retrieve a scale and bias to F0. See [1], Figure 3
					vec3 brdf = SRGBtoLINEAR(texture2D(u_brdfLUT, vec2(pbrInputs.NdotV, 1.0 - pbrInputs.perceptualRoughness))).rgb;
					vec3 diffuseLight = SRGBtoLINEAR(textureCube(u_DiffuseEnvSampler, n)).rgb;
				
				#ifdef USE_TEX_LOD
					float mipCount = 9.0; // resolution of 512x512
					float lod = (pbrInputs.perceptualRoughness * mipCount);
					vec3 specularLight = SRGBtoLINEAR(textureCubeLodEXT(u_SpecularEnvSampler, reflection, lod)).rgb;
				#else
					vec3 specularLight = SRGBtoLINEAR(textureCube(u_SpecularEnvSampler, reflection)).rgb;
				#endif
				
					vec3 diffuse = diffuseLight * pbrInputs.diffuseColor;
					vec3 specular = specularLight * (pbrInputs.specularColor * brdf.x + brdf.y);
				
					// For presentation, this allows us to disable IBL terms
					diffuse *= u_ScaleIBLAmbient.x;
					specular *= u_ScaleIBLAmbient.y;
				
					return diffuse + specular;
				}
			#endif
				
				vec3 diffuse(PBRInfo pbrInputs)
				{
					return pbrInputs.diffuseColor / M_PI;
				}
				
				vec3 specularReflection(PBRInfo pbrInputs)
				{
					return pbrInputs.reflectance0 + (pbrInputs.reflectance90 - pbrInputs.reflectance0) * pow(clamp(1.0 - pbrInputs.VdotH, 0.0, 1.0), 5.0);
				}
				
				float geometricOcclusion(PBRInfo pbrInputs)
				{
					float NdotL = pbrInputs.NdotL;
					float NdotV = pbrInputs.NdotV;
					float r = pbrInputs.alphaRoughness;
					
					float attenuationL = 2.0 * NdotL / (NdotL + sqrt(r * r + (1.0 - r * r) * (NdotL * NdotL)));
					float attenuationV = 2.0 * NdotV / (NdotV + sqrt(r * r + (1.0 - r * r) * (NdotV * NdotV)));
					return attenuationL * attenuationV;
				}
				
				float microfacetDistribution(PBRInfo pbrInputs)
				{
					float roughnessSq = pbrInputs.alphaRoughness * pbrInputs.alphaRoughness;
					float f = (pbrInputs.NdotH * roughnessSq - pbrInputs.NdotH) * pbrInputs.NdotH + 1.0;
					return roughnessSq / (M_PI * f * f);
				}
				
				void main()
				{
					float perceptualRoughness = u_metallicRoughnessValues.y;
					float metallic = u_metallicRoughnessValues.x;
					
				#ifdef HAS_METALROUGHNESSMAP
					vec4 mrSample = ${this.sample("u_metallicRoughnessTexture")};
					perceptualRoughness *= mrSample.g;
					metallic *= mrSample.b;
				#endif
					
					perceptualRoughness = clamp(perceptualRoughness, 0.04, 1.0);
					metallic = clamp(metallic, 0.0, 1.0);
					float alphaRoughness = perceptualRoughness * perceptualRoughness;
					
					vec4 baseColor = u_baseColorFactor;
					
				#ifdef HAS_BASECOLORMAP
					baseColor *= ${this.sample("u_baseColorTexture")};
				#endif
				
				#ifdef HAS_VERTEXCOLOR
					baseColor *= v_color;
				#endif
				
					baseColor.a = mix(1.0, baseColor.a, u_alphaMode);
				
					if (baseColor.a < u_alphaCutoff)
					{
						discard;
					}
					if (u_alphaCutoff > -0.5)
					{
						// AlphaBlendModeTest model..
						baseColor.rgb /= baseColor.a;
						baseColor.a = 1.0;
					}
					
					${Is.getFragmentChunk("baseColor.a")}
					
					${this._source.frag.body}
					
					vec3 f0 = vec3(0.04);
					vec3 diffuseColor = baseColor.rgb * (vec3(1.0) - f0);
					diffuseColor *= 1.0 - metallic;
					vec3 specularColor = mix(f0, baseColor.rgb, metallic);
					
					float reflectance = max(max(specularColor.r, specularColor.g), specularColor.b);
					
					float reflectance90 = clamp(reflectance * 25.0, 0.0, 1.0);
					vec3 specularEnvironmentR0 = specularColor.rgb;
					vec3 specularEnvironmentR90 = vec3(1.0, 1.0, 1.0) * reflectance90;
					
					vec3 n = getNormal();
					vec3 v = normalize(u_Camera - v_position);
					vec3 l = normalize(u_LightDirection);
					vec3 h = normalize(l + v);
					
					float NdotL = clamp(dot(n, l), 0.001, 1.0);
					float NdotV = abs(dot(n, v)) + 0.001;
					float NdotH = clamp(dot(n, h), 0.0, 1.0);
					float LdotH = clamp(dot(l, h), 0.0, 1.0);
					float VdotH = clamp(dot(v, h), 0.0, 1.0);
					
					PBRInfo pbrInputs = PBRInfo(
						NdotL,
						NdotV,
						NdotH,
						LdotH,
						VdotH,
						perceptualRoughness,
						metallic,
						specularEnvironmentR0,
						specularEnvironmentR90,
						alphaRoughness,
						diffuseColor,
						specularColor
					);
					
					vec3 F = specularReflection(pbrInputs);
					float G = geometricOcclusion(pbrInputs);
					float D = microfacetDistribution(pbrInputs);
					
					vec3 diffuseContrib = (1.0 - F) * diffuse(pbrInputs);
					vec3 specContrib = F * G * D / (4.0 * NdotL * NdotV);
					
					vec3 ambient = u_ambientLight * baseColor.rgb;
					vec3 color = ambient + NdotL * u_LightColor * (diffuseContrib + specContrib);
					
				#ifdef USE_IBL
					vec3 reflection = -normalize(reflect(v, n));
					color += getIBLContribution(pbrInputs, n, reflection);
				#endif
					
				#ifdef HAS_OCCLUSIONMAP
					float ao = ${this.sample("u_occlusionTexture")}.r;
					color = mix(color, color * ao, u_occlusionStrength);
				#endif
					
					vec3 emissive = u_emissiveFactor;
				#ifdef HAS_EMISSIVEMAP
					emissive *= ${this.sample("u_emissiveTexture")}.rgb;
				#endif
				
					color += emissive;
					
					color = pow(color, vec3(1.0 / u_gamma));
					
					gl_FragColor = vec4(color, baseColor.a);
					gl_FragColor.rgb *= gl_FragColor.a;
				}
			`
            }
            createProgram() {
                return new W({
                    context: this._adapter.context,
                    vertSource: this._sources.vert,
                    fragSource: this._sources.frag,
                    attributes: this._attributes,
                    varyings: this.getVaryings(),
                    uniforms: this._baseUniforms,
                    extensions: this._extensions
                })
            }
            addIBL() {
                var e = this._adapter.context;
                this.defineBool("USE_IBL"), e.extensions.hasTextureCubeLod() && (this.defineBool("USE_TEX_LOD"), e.version < 2) && this._extensions.frag.push(ms.GL_EXT_shader_texture_lod), this._baseUniforms.u_ScaleIBLAmbient = {
                    type: W.TYPE_VEC2,
                    addToFrag: !0
                }, this._baseUniforms.u_DiffuseEnvSampler = {
                    type: W.TYPE_SAMPLER_CUBE,
                    addToFrag: !0
                }, this._baseUniforms.u_SpecularEnvSampler = {
                    type: W.TYPE_SAMPLER_CUBE,
                    addToFrag: !0
                }, this._baseUniforms.u_brdfLUT = {
                    type: W.TYPE_SAMPLER_2D,
                    texture: this._adapter.getTexture(this._adapter.brdfLUT),
                    addToFrag: !0
                }
            }
            addOcclusionTexture() {
                this.addTextureInfo("u_occlusionTexture", "HAS_OCCLUSIONMAP", this.material.occlusionTextureInfo), this.material.occlusionTextureInfo.texture && (this._baseUniforms.u_occlusionStrength = {
                    type: W.TYPE_FLOAT,
                    addToFrag: !0
                })
            }
            addNormalTexture() {
                this.addTextureInfo("u_normalTexture", "HAS_NORMALMAP", this.material.normalTextureInfo), this.material.normalTextureInfo.texture && (this._baseUniforms.u_normalScale = {
                    type: W.TYPE_FLOAT,
                    addToFrag: !0
                })
            }
            sample(e, t = 0) {
                let s = this.getTexVarying(e);
                var r = e + "_transform";
                return `texture2D(${e}, ${s=this._baseUniforms[r]?`(${r} * vec3(${s}, 1.0)).xy`:s})`
            }
            getTexVarying(e) {
                let t = 0;
                return this._textures[e] && (t = this._textures[e].channel), "v_" + A.p.getTexCoord(t)
            }
            getUV() {
                var e, t = Object.keys(this._textures);
                return 0 === t.length ? "vec3(0.0)" : (e = "", e = this._textures.u_baseColorTexture ? "u_baseColorTexture" : this._textures.u_normalTexture ? "u_normalTexture" : t[0], `vec3(${this.getTexVarying(e)}, 0.0)`)
            }
            addTextureInfo(e, t, s) {
                var r, i = null == s ? void 0 : s.texture;
                i && (r = s.channel, this._textures[e] = {
                    channel: r
                }, f.M.isPositiveOrZero(r) && (this._texCoordinates[r] = !0), this._baseUniforms[e] = {
                    type: W.TYPE_SAMPLER_2D,
                    texture: i,
                    addToFrag: !0
                }, (r = s.transform) && (this._baseUniforms[e + "_transform"] = {
                    type: W.TYPE_MAT3,
                    value: r.mat,
                    addToFrag: !0
                }), this.defineBool(t))
            }
            getTexCoordAttributes() {
                var e = [];
                for (const s in this._texCoordinates) {
                    var t = A.p.getTexCoord(Number(s));
                    e.push({
                        name: "a_" + t,
                        size: 2,
                        sizeY: 1,
                        semantic: t
                    })
                }
                return e
            }
            getVaryingConnections() {
                let e = "";
                for (const s in this._texCoordinates) {
                    var t = A.p.getTexCoord(Number(s));
                    e += `v_${t} = a_${t};
`
                }
                return e
            }
            getVaryings() {
                var e = {};
                for (const t in this._texCoordinates) e["v_" + A.p.getTexCoord(Number(t))] = "vec2";
                return e.v_position = "vec3", this.hasAttribute(A.p.NORMAL) && (e.v_normal = "vec3", this.hasAttribute(A.p.TANGENT)) && (e.v_TBN = "mat3"), this.hasAttribute(A.p.COLOR) && (e.v_color = "vec4"), e
            }
            enableNode(e, t, s) {
                this.prepare(), this.updateMaterialUniforms(s), this.updateNodeUniforms(e, t), this.updateSides(t), this.updateLights(t), this.updateSkin(t), super.enable(), this.enableDepth(), this.enableBlend()
            }
            enable() {}
            updateMaterialUniforms(e) {
                e = e || this.material;
                var t = this.getProgram(),
                    s = (t.setUniform("u_alphaCutoff", e.alphaMode === _e.mM.MASK ? e.alphaCutoff : -1), this.enableTextureUniform("u_baseColorTexture", e.baseColorTextureInfo.texture, e.baseColorTextureInfo.transform, t), this.enableTextureUniform("u_emissiveTexture", e.emissiveTextureInfo.texture, e.emissiveTextureInfo.transform, t), this.enableTextureUniform("u_metallicRoughnessTexture", e.metallicRoughnessTextureInfo.texture, e.metallicRoughnessTextureInfo.transform, t), this.enableTextureUniform("u_normalTexture", e.normalTextureInfo.texture, e.normalTextureInfo.transform, t), this.enableTextureUniform("u_occlusionTexture", e.occlusionTextureInfo.texture, e.occlusionTextureInfo.transform, t), t.setUniform("u_alphaMode", e.alphaMode === _e.mM.OPAQUE ? 0 : 1), t.setUniform("u_baseColorFactor", m.I.decomposeAndNormalizeRGBA(e.baseColorFactor, e.baseColorAlpha)), m.I.decomposeAndNormalizeRGB(e.emissiveFactor)),
                    s = (M.R.scale(s, s, e.emissiveStrength), t.setUniform("u_emissiveFactor", s), t.setUniform("u_metallicRoughnessValues", [e.metallicFactor, e.roughnessFactor]), this._baseUniforms.u_normalScale && t.setUniform("u_normalScale", e.normalScale), this._baseUniforms.u_occlusionStrength && t.setUniform("u_occlusionStrength", e.occlusionStrength), t.setUniform("u_DiffuseEnvSampler", null != (s = this._adapter.getCubeTexture(this._adapter.environment.diffuseTexture)) ? s : this._adapter.placeholderTextures.diffuseEnv), t.setUniform("u_SpecularEnvSampler", null != (e = this._adapter.getCubeTexture(this._adapter.environment.specularTexture)) ? e : this._adapter.placeholderTextures.specularEnv), this._adapter.gammaEnabled ? this._adapter.gammaFactor : 1);
                t.setUniform("u_gamma", s)
            }
            updateNodeUniforms(e, t) {
                const s = e.getViewProjectionMatrix(),
                    r = this.getProgram(),
                    i = (r.setUniform("u_ViewProjectionMatrix", s, !0), this.updateInstance(t, !1), t.morphWeights);
                i && this._supportedMorphTargets.forEach(e => {
                    r.setUniform("u_weight_" + e, i[e])
                }), e && r.setUniform("u_Camera", e.getEye())
            }
            updateLights(e) {
                var t = e.scene;
                if (t) {
                    const e = this.getProgram(),
                        i = t.lights.ambient,
                        a = m.I.decomposeAndNormalizeRGB(i.color);
                    M.R.scale(a, a, i.intensity), e.setUniform("u_ambientLight", a);
                    var s = t.lights.sun,
                        r = m.I.decomposeAndNormalizeRGB(s.color),
                        s = (M.R.scale(r, r, s.intensity), e.setUniform("u_LightDirection", s.direction), e.setUniform("u_LightColor", r), t.lights.ibl.intensity);
                    e.hasUniform("u_ScaleIBLAmbient") && e.setUniform("u_ScaleIBLAmbient", [s, s])
                } else console.warn("No scene found for node", e)
            }
            enableDepth() {
                var e = this._adapter.context;
                e.depthMask = !0, e.depthTest = !0
            }
            get key() {
                return this._sources.vert + this._sources.frag
            }
        }
        class Fs extends fe.F {
            constructor(e = {}) {
                var t;
                super({}), this._color = null != (t = e.color) ? t : Fs.defaultConfig.color, this._opacity = null != (t = e.opacity) ? t : Fs.defaultConfig.opacity
            }
            clone() {
                return new Fs({ ...this.cloneConfig(),
                    color: this.color,
                    opacity: this.opacity
                })
            }
            set color(e) {
                this._color = e
            }
            get color() {
                return this._color
            }
            set opacity(e) {
                this._opacity = e
            }
            get opacity() {
                return this._opacity
            }
            get transparent() {
                return this.opacity < 1
            }
            getKey() {
                return "color"
            }
            getEqualsKey() {
                return `ColorMaterial-${this.color.toString(16)}-` + this.opacity
            }
        }
        Fs.defaultConfig = {
            color: 16711680,
            opacity: 100
        };
        class Ls extends W {
            constructor(e) {
                super({
                    context: e,
                    vertSource: "\n\t\t\t\t\tuniform mat4 u_ViewProjectionMatrix;\n\t\t\t\t\tuniform mat4 u_ModelMatrix;\n\t\t\t\t\n\t\t\t\t\tvoid main()\n\t\t\t\t\t{\n\t\t\t\t\t\tgl_Position = u_ViewProjectionMatrix * u_ModelMatrix * vec4(a_position, 1.0);\n\t\t\t\t\t}\n\t\t\t\t",
                    fragSource: `
					uniform vec4 u_color;
					
					void main()
					{
						${Is.getFragmentChunk()}
						gl_FragColor = u_color;
					}
				`,
                    attributes: [{
                        name: "a_position",
                        size: 3,
                        semantic: A.p.POSITION
                    }],
                    uniforms: {
                        u_ViewProjectionMatrix: {
                            type: W.TYPE_MAT4
                        },
                        u_ModelMatrix: {
                            type: W.TYPE_MAT4
                        },
                        u_color: {
                            type: W.TYPE_VEC4
                        },
                        ...Is.createUniforms()
                    }
                })
            }
        }
        class Ds extends ys {
            constructor(e, t, s, r) {
                super({
                    adapter: r,
                    programClass: Ls,
                    geometry: t,
                    material: e,
                    skin: void 0
                })
            }
            updateMaterialUniforms(e) {
                e = e || this._material;
                var t = m.I.decomposeAndNormalizeRGB(e.color),
                    e = e.opacity;
                this.getProgram().setUniform("u_color", [t[0], t[1], t[2], e])
            }
            updateSides(e) {
                this.setCulling(e)
            }
        }
        var ve = c(9894);
        class Os extends ys {
            constructor(e, t, s, r) {
                super({
                    program: null,
                    adapter: r,
                    geometry: t,
                    material: e,
                    skin: s
                }), this._texCoordinates = {}, this._textures = {}, this._sources = {
                    vert: "",
                    frag: ""
                }, this._extensions = {
                    vert: [],
                    frag: []
                }
            }
            init() {
                this.initUniforms(), this.initAttributes(), this.addSkin(), this.addBaseColorTexture(), this.addTexCoordAttributes(), this.createSources()
            }
            initUniforms() {
                this._baseUniforms = {
                    u_alphaCutoff: {
                        type: W.TYPE_FLOAT,
                        addToFrag: !0
                    },
                    u_doubleSided: {
                        type: W.TYPE_BOOL,
                        addToFrag: !0
                    },
                    u_flipSide: {
                        type: W.TYPE_FLOAT,
                        addToFrag: !0
                    },
                    u_ViewProjectionMatrix: {
                        type: W.TYPE_MAT4,
                        addToVert: !0
                    },
                    u_ModelMatrix: {
                        type: W.TYPE_MAT4,
                        addToVert: !0
                    },
                    u_baseColorFactor: {
                        type: W.TYPE_VEC4,
                        addToFrag: !0
                    },
                    u_alphaMode: {
                        type: W.TYPE_FLOAT,
                        addToFrag: !0
                    },
                    u_gamma: {
                        type: W.TYPE_FLOAT,
                        addToFrag: !0
                    },
                    ...Is.createUniforms()
                }
            }
            initAttributes() {
                this._attributes = [{
                    name: "a_position",
                    size: 3,
                    sizeY: 1,
                    componentType: _.g.FLOAT,
                    semantic: A.p.POSITION
                }];
                var e = this.getBufferAttribute(A.p.COLOR);
                e && (this._attributes.push({
                    name: "a_color",
                    size: 4,
                    sizeY: 1,
                    componentType: e.componentType,
                    semantic: A.p.COLOR
                }), this.defineBool("HAS_VERTEXCOLOR"))
            }
            addTexCoordAttributes() {
                this._attributes = this._attributes.concat(this.getTexCoordAttributes())
            }
            createSources() {
                this._sources.vert = `
				${this._source.vert.declaration}
			
				void main()
				{
					${this.getVaryingConnections()}
					
					vec3 position = a_position;
					
				#ifdef HAS_VERTEXCOLOR
					v_color = a_color;
				#endif
			
					${this._source.vert.body}
					
					vec4 worldPosition = u_ModelMatrix * vec4(position, 1.0);
					
				#ifdef HAS_SKIN
					mat4 skinMatrix = u_bones[int(a_joints_0.x)] * a_weights_0.x +
					                  u_bones[int(a_joints_0.y)] * a_weights_0.y +
					                  u_bones[int(a_joints_0.z)] * a_weights_0.z +
					                  u_bones[int(a_joints_0.w)] * a_weights_0.w;
					
					worldPosition = skinMatrix * vec4(position, 1.0);
				#endif
					
					v_position = worldPosition.xyz / worldPosition.w;
					gl_Position = u_ViewProjectionMatrix * worldPosition;
					
					${this.getPointSize()}
				}
			`, this._sources.frag = `
				${this._source.frag.declaration}
				
				const float M_PI = 3.141592653589793;
				
				#define MANUAL_SRGB true
				vec4 SRGBtoLINEAR(vec4 srgbIn)
				{
					#ifdef MANUAL_SRGB
						#ifdef SRGB_FAST_APPROXIMATION
							vec3 linOut = pow(srgbIn.xyz, vec3(2.2));
						#else
							vec3 bLess = step(vec3(0.04045), srgbIn.xyz);
							vec3 linOut = mix(srgbIn.xyz / vec3(12.92), pow((srgbIn.xyz + vec3(0.055)) / vec3(1.055), vec3(2.4)), bLess);
						#endif
							return vec4(linOut, srgbIn.w);;
					#else
						return srgbIn;
					#endif
				}
				
				void main()
				{
					vec4 baseColor = u_baseColorFactor;
					
				#ifdef HAS_BASECOLORMAP
					baseColor *= ${this.sample("u_baseColorTexture")};
				#endif
				
				#ifdef HAS_VERTEXCOLOR
					baseColor *= v_color;
				#endif
				
					baseColor.a = mix(1.0, baseColor.a, u_alphaMode);
				
					if (baseColor.a < u_alphaCutoff)
					{
						discard;
					}
					
					${Is.getFragmentChunk("baseColor.a")}
					
					${this._source.frag.body}
					
					vec3 color = baseColor.rgb;
					
					color = pow(color, vec3(1.0 / u_gamma));
					
					gl_FragColor = vec4(color, baseColor.a);
				}
			`
            }
            createProgram() {
                return new W({
                    context: this._adapter.context,
                    vertSource: this._sources.vert,
                    fragSource: this._sources.frag,
                    attributes: this._attributes,
                    varyings: this.getVaryings(),
                    uniforms: this._baseUniforms,
                    extensions: this._extensions
                })
            }
            addBaseColorTexture() {
                var e = this.material;
                this.addTexture("u_baseColorTexture", "HAS_BASECOLORMAP", e.baseColorTextureInfo)
            }
            sample(e, t) {
                let s = this.getTexVarying(e);
                var r = e + "_transform";
                return `texture2D(${e}, ${s=this._baseUniforms[r]?`(${r} * vec3(${s}, 1.0)).xy`:s})`
            }
            getTexVarying(e) {
                let t = 0;
                return this._textures[e] && (t = this._textures[e].channel), "v_" + A.p.getTexCoord(t)
            }
            getUV() {
                return 0 === Object.keys(this._textures).length ? "vec3(0.0)" : `vec3(${this.getTexVarying("u_baseColorTexture")}, 0.0)`
            }
            addTexture(e, t, s) {
                var {
                    texture: s,
                    channel: r,
                    transform: i
                } = s;
                s && (this._textures[e] = {
                    channel: r
                }, f.M.isPositiveOrZero(r) && (this._texCoordinates[r] = !0), this._baseUniforms[e] = {
                    type: W.TYPE_SAMPLER_2D,
                    texture: s,
                    addToFrag: !0
                }, i && (this._baseUniforms[e + "_transform"] = {
                    type: W.TYPE_MAT3,
                    value: i.mat,
                    addToFrag: !0
                }), this.defineBool(t))
            }
            getTexCoordAttributes() {
                var e = [];
                for (const s in this._texCoordinates) {
                    var t = A.p.getTexCoord(Number(s));
                    e.push({
                        name: "a_" + t,
                        size: 2,
                        sizeY: 1,
                        componentType: _.g.FLOAT,
                        semantic: t
                    })
                }
                return e
            }
            getVaryingConnections() {
                let e = "";
                for (const s in this._texCoordinates) {
                    var t = A.p.getTexCoord(Number(s));
                    e += `v_${t} = a_${t};
`
                }
                return e
            }
            getVaryings() {
                var e = {};
                for (const t in this._texCoordinates) e["v_" + A.p.getTexCoord(Number(t))] = "vec2";
                return e.v_position = "vec3", this.hasAttribute(A.p.NORMAL) && (e.v_normal = "vec3", this.hasAttribute(A.p.TANGENT)) && (e.v_TBN = "mat3"), this.hasAttribute(A.p.COLOR) && (e.v_color = "vec4"), e
            }
            updateMaterialUniforms(e) {
                e = e || this.material;
                var t = this.getProgram(),
                    e = (t.setUniform("u_alphaCutoff", e.alphaMode === _e.mM.MASK ? e.alphaCutoff : -1), this.enableTextureUniform("u_baseColorTexture", e.baseColorTextureInfo.texture, e.baseColorTextureInfo.transform, t), t.setUniform("u_alphaMode", e.alphaMode === _e.mM.OPAQUE ? 0 : 1), t.setUniform("u_baseColorFactor", m.I.decomposeAndNormalizeRGBA(e.baseColorFactor, e.baseColorAlpha)), this._adapter.gammaEnabled ? this._adapter.gammaFactor : 1);
                t.setUniform("u_gamma", e)
            }
            get key() {
                return this._sources.vert + this._sources.frag
            }
        }
        Os.bufferAttributes = [A.p.POSITION, A.p.COLOR];
        var be = c(4755);
        class Bs {
            constructor(e) {
                this._adapter = e.adapter, this._attributes = e.attributes || [], this._indexBuffer = e.indexBuffer
            }
            bind() {
                var e = this._adapter,
                    t = e.context.gl;
                for (const s of this._attributes) e.context.enableAttribute(s.index), e.getBuffer(s.buffer).bind(), t.vertexAttribPointer(s.index, s.size, s.componentType, s.normalized, s.byteStride, s.byteOffset);
                this._indexBuffer && e.getBuffer(this._indexBuffer.buffer).bind()
            }
            unbind() {
                var e = this._adapter.context;
                for (const t of this._attributes) e.disableAttribute(t.index);
                this._indexBuffer && this._adapter.getBuffer(this._indexBuffer.buffer).unbind()
            }
            dispose() {}
            get indexBuffer() {
                return this._indexBuffer
            }
        }
        class Us {
            constructor(e) {
                this._attributes = [], this._adapter = e.adapter, this._indexBuffer = e.indexBuffer, this._attributes = e.attributes || []
            }
            recordCalls() {
                var e, t = this._adapter.context.gl;
                for (const s of this._attributes) t.enableVertexAttribArray(s.index), this._adapter.getBuffer(s.buffer).bind(), t.vertexAttribPointer(s.index, s.size, s.componentType, s.normalized, s.byteStride, s.byteOffset);
                this.indexBuffer && (e = this._adapter.getBuffer(this.indexBuffer.buffer), t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, e.buffer), e.bind())
            }
            get indexBuffer() {
                return this._indexBuffer
            }
        }
        class ks extends Us {
            constructor(e) {
                super(e), this._vao = this.gl.createVertexArray(), this.bind(), this.recordCalls(), this.unbind()
            }
            bind() {
                this._adapter.context.vao.bindVAO(this._vao)
            }
            unbind() {
                this._adapter.context.vao.bindVAO(null)
            }
            dispose() {
                this._vao && (this.gl.deleteVertexArray(this._vao), this._vao = null)
            }
            get gl() {
                return this._adapter.context.gl
            }
        }
        class zs extends Us {
            static isSupported(e) {
                return e.getExtension(zs.OES_vertex_array_object)
            }
            constructor(e) {
                super(e), this._vaoExt = this._adapter.context.getExtension(zs.OES_vertex_array_object), this._vao = this._vaoExt.createVertexArrayOES(), this.bind(), this.recordCalls(), this.unbind()
            }
            bind() {
                var e;
                null != (e = this._vaoExt) && e.bindVertexArrayOES(this._vao)
            }
            unbind() {
                var e;
                null != (e = this._vaoExt) && e.bindVertexArrayOES(null)
            }
            dispose() {
                var e;
                this._vao && (null != (e = this._vaoExt) && e.deleteVertexArrayOES(this._vao), this._vao = null)
            }
        }
        zs.OES_vertex_array_object = "OES_vertex_array_object";
        class Vs {
            static createVAO(e) {
                if (Vs.initConfig(e), e.forcePolyfill) return new Bs(e);
                let t = Vs.VAOClass.get(e.adapter.context);
                var s;
                return t || ((s = e.adapter.context).is2 ? Vs.VAOClass.set(s, ks) : zs.isSupported(s) ? Vs.VAOClass.set(s, zs) : Vs.VAOClass.set(s, Bs), t = Vs.VAOClass.get(s)), new t(e)
            }
            static initConfig(e) {
                if (e.program && (e.programAttributes = e.program.attributes), e.programAttributes) {
                    var t = e.geometry;
                    if (!t) throw new Error("No geometry given, can't calculate program attributes!");
                    e.attributes = Vs.createAttributes(e.programAttributes, t), e.indexBuffer = t.indexBuffer
                }
                e.geometry && (e.indexBuffer = e.geometry.indexBuffer)
            }
            static createAttributes(e, t) {
                var s = t.getAttributes(),
                    r = [];
                for (const t of e) {
                    const e = Vs.createVAOAttribute(t, s);
                    e ? r.push(e) : console.warn("Error: geometryAttribute not found!")
                }
                return r
            }
            static createVAOAttribute(e, t) {
                var s;
                for (const r of t)
                    if (e.semantic && e.semantic === r.semantic) {
                        const t = (null != (s = r.normalized) ? s : e.normalized) || !1;
                        return {
                            index: e.index,
                            size: r.size,
                            componentType: r.componentType,
                            byteOffset: r.byteOffset,
                            byteStride: r.byteStride,
                            normalized: t,
                            buffer: r.buffer
                        }
                    }
                return null
            }
        }
        Vs.VAOClass = new Map;
        class Gs {
            constructor(e, t) {
                this._renderer = null, this._currentDimension = [0, 0], this._adapter = e, this._filter = t
            }
            getRenderer() {
                return this._renderer && f.M.equals(this._currentDimension, this._filter.kernelSize) || (re.K.copy(this._currentDimension, this._filter.kernelSize), this._renderer && this._renderer.dispose(), this._renderer = this.createRenderer(), this.update()), this._renderer
            }
            createRenderer() {
                var e = this._filter.kernelSize[0],
                    t = this._filter.kernelSize[1],
                    e = new xs({
                        context: this._adapter.context,
                        uniforms: {
                            u_kernel: {
                                type: W.TYPE_FLOAT,
                                arrayLength: e * t
                            },
                            u_texelSize: {
                                type: W.TYPE_VEC2,
                                addToFrag: !0
                            },
                            u_color: {
                                type: W.TYPE_VEC3,
                                addToFrag: !0
                            }
                        },
                        fragSource: `
			
				const int dimX = ${e};
				const int dimY = ${t};
				
				uniform float u_kernel[dimX * dimY];
			
				void main()
				{
					vec4 color = vec4(0.0);
					
					int halfX = (dimX - 1) / 2;
					int halfY = (dimY - 1) / 2;
					
					for (int x = 0; x < dimX; ++x)
					{
						for (int y = 0; y < dimY; ++y)
						{
							float u = float(x - halfX);
							float v = float(y - halfY);
							
							vec2 sampleCoord = v_uv + vec2(u, v) * u_texelSize;
							vec4 texel = texture2D(u_texture, sampleCoord) * u_kernel[y * dimX + x];
							
							color += texel;
						}
					}
					
					// abs: edge grows both ways
					// without abs: edge grows inside only
					// to grow outside only: use -abs or negate the kernel matrix
					
					color.a = abs(color.r);
					color.rgb = u_color;
					
					gl_FragColor = color;
				}
			`
                    });
                return new Es(this._adapter, e)
            }
            update() {
                this.getRenderer().program.setUniform("u_kernel", this._filter.kernel)
            }
            updateTexelSize(e) {
                this.getRenderer().program.setUniform("u_texelSize", e)
            }
            updateColor(e) {
                this.getRenderer().program.setUniform("u_color", m.I.decomposeAndNormalizeRGB(e))
            }
            dispose() {
                this._renderer && (this._renderer.dispose(!0), this._renderer = null)
            }
        }
        class Ws {
            constructor(e) {
                this.renderNode = (e, t) => {
                    if (e instanceof T.j) {
                        var s, r, i = this._adapter.getMeshRenderer(e);
                        i.drawUnit && ((s = i.drawUnit.technique.getProgram()).setUniform("u_renderIds", !0), s.setUniform("u_id", [1, 0, 0, 1]), r = e.material.wireframe, e.material.wireframe = !1, i.render(t), e.material.wireframe = r, s.setUniform("u_renderIds", !1))
                    } else if (e instanceof q.B) {
                        for (const a of e.renderNodes) this.renderNode(a, t);
                        this.renderNodes(e.children, t)
                    }
                }, this._adapter = e, this._edgeDetection = new Gs(e, {
                    kernel: [-1, -1, -1, -1, 8, -1, -1, -1, -1],
                    kernelSize: [3, 3],
                    divide: 1,
                    scale: 1
                }), this._edgeDetection.update()
            }
            render(e, t, s) {
                e = this.renderColorTexture(e, s);
                this.renderEdgeDetection(e, t)
            }
            renderColorTexture(e, t) {
                var s = this._adapter.context,
                    r = s.getViewport(),
                    r = (this._colorTexture = this._colorTexture || new I({
                        context: s
                    }), this._colorTexture.setSize(r[2], r[3]), this._colorTexture.initFramebuffer(!1));
                return r.setAsRenderTarget(), r.clear([0, 0, 0, 0]), s.depthTest = !1, s.depthMask = !1, this.renderNodes(e, t), s.depthTest = !0, s.depthMask = !0, s.cullFace(_.g.BACK), r.unbind(), this._colorTexture
            }
            renderNodes(e, t) {
                for (const s of e) this.renderNode(s, t)
            }
            renderEdgeDetection(e, t) {
                var s = this._adapter.context,
                    r = (this._edgeTexture || (this._edgeTexture = new I({
                        context: s
                    })), this._edgeTexture.setSize(e.width, e.height), this._edgeTexture.initFramebuffer(!1)),
                    i = t.thickness * window.devicePixelRatio,
                    i = [1 / this._edgeTexture.width * i, 1 / this._edgeTexture.height * i],
                    i = (this._edgeDetection.updateTexelSize(i), this._edgeDetection.updateColor(t.color), this._edgeDetection.getRenderer()),
                    t = new d.A,
                    a = (t.setFromEdges(0, this._edgeTexture.width, 0, this._edgeTexture.height), s.getViewport());
                r.unbind(), s.enableStandardBlend(!1), i.render({
                    srcTexture: e,
                    dstTexture: null,
                    srcRect: t,
                    dstRect: t,
                    textureRect: d.A.createFromEdges(0, a[2], 0, a[3]),
                    viewport: a
                }), s.blend(null)
            }
        }
        class Hs {
            static traverse(e, t) {
                if (!0 !== t(e) && e.children)
                    for (const s of e.children) this.traverse(s, t)
            }
            static traverseBackwards(t, s) {
                if (!0 !== s(t) && t.children)
                    for (let e = t.children.length - 1; 0 <= e; e--) this.traverseBackwards(t.children[e], s)
            }
            static traverseOnce(e, s) {
                const r = new Set;
                return function e(t) {
                    if (!0 !== s(t) && t.children)
                        for (const s of t.children) r.has(s) || (r.add(s), e(s))
                }(e), r
            }
            static filter(e, t, s) {
                const r = [];
                return this.traverse(e, e => (t(e) && r.push(e), null == s ? void 0 : s(e))), r
            }
        }
        class H {
            static traverseGeometryOnce(e, s) {
                if (e instanceof T.j) s(e.geometry);
                else {
                    const r = new Set;
                    Hs.traverse(e, e => {
                        for (const t of e.renderNodes) {
                            const e = t.geometry;
                            r.has(e) || (r.add(e), s(e))
                        }
                    })
                }
            }
            static traverseRenderNodesOnce(e, s) {
                if (e instanceof T.j) s(e);
                else {
                    const r = new Set;
                    Hs.traverse(e, e => {
                        for (const t of e.renderNodes) r.has(t) || (r.add(t), s(t))
                    })
                }
            }
            static traverseRenderNodes(e, s) {
                e instanceof T.j ? s(e) : Hs.traverse(e, e => {
                    for (const t of e.renderNodes) s(t)
                })
            }
            static traverseNodes(e, t) {
                e instanceof K.x ? Hs.traverse(e, e => {
                    t(e)
                }) : t(e)
            }
            static traverseNodesBackwards(e, t) {
                e instanceof K.x ? Hs.traverseBackwards(e, e => {
                    t(e)
                }) : t(e)
            }
            static flattenRenderNodes(e) {
                const t = [];
                return this.traverseRenderNodes(e, e => {
                    t.push(e)
                }), t
            }
            static findNodesByName(e, t) {
                return this.filterNodes(e, e => e.name === t)
            }
            static filterNodes(e, t, s) {
                return Hs.filter(e, t, s)
            }
            static findRenderNodeByName(e, t) {
                t = this.findNodesByName(e, t);
                for (const e of t) return e.renderNodes[0] || null;
                return null
            }
            static findPBRMaterialbyNodeName(e, t) {
                e = this.findRenderNodeByName(e, t);
                return e && e.material instanceof o.q ? e.material : null
            }
            static findPBRMaterialsByNodeName(e, t) {
                var s = [],
                    t = this.findNodesByName(e, t);
                for (const e of t)
                    for (const t of e.renderNodes) t.material instanceof o.q && s.push(t.material);
                return s
            }
            static findPBRMaterialsByNodeNames(t, e) {
                const s = [];
                return e.forEach(e => {
                    pe.B.push(s, this.findPBRMaterialsByNodeName(t, e))
                }), s
            }
            static findMaterialsByNames(e, s) {
                let r = [];
                return Hs.traverse(e, e => {
                    for (const t of e.renderNodes) - 1 < s.indexOf(t.material.name) && r.push(t.material)
                }), r
            }
        }
        var xe = c(5081);
        class Ys {
            static convertToLines(e) {
                H.traverseRenderNodesOnce(e, Ys.convertRenderNodeToLines)
            }
            static convertRenderNodeToLines(e) {
                var t = Ys.createLineGeometry(e.geometry);
                e.setGeometry(t)
            }
            static createLineGeometry(t) {
                if (t.mode !== _.g.TRIANGLES) return console.warn("Geometry mode not supported: " + t.mode), t; {
                    let e;
                    var s = t.indexBuffer;
                    if (s) {
                        var r = s.data,
                            i = t.start,
                            s = t.count,
                            a = xe.W.newTypedArray(r, 2 * s),
                            n = i + s;
                        for (let e = i; e < n; e += 3) {
                            var o = r[e],
                                l = r[e + 1],
                                h = r[e + 2],
                                c = 2 * (e - i);
                            a[0 + c] = o, a[1 + c] = l, a[2 + c] = l, a[3 + c] = h, a[4 + c] = h, a[5 + c] = o
                        }
                        e = x.Y.fromData(a)
                    } else {
                        var d = ue.oY.createIndexArray(t.count, 2 * t.count);
                        for (let e = 0; e < t.count; e += 3) {
                            var u = e + t.start,
                                p = u + 1,
                                m = u + 2,
                                g = 2 * e;
                            d[0 + g] = u, d[1 + g] = p, d[2 + g] = p, d[3 + g] = m, d[4 + g] = m, d[5 + g] = u
                        }
                        e = x.Y.fromData(d)
                    }
                    return new Z.Z({
                        indexBuffer: e,
                        buffers: t.buffers,
                        start: 0,
                        mode: _.g.LINES
                    })
                }
            }
            static convertToPoints(e) {
                H.traverseRenderNodesOnce(e, Ys.convertRenderNodeToPoints)
            }
            static convertRenderNodeToPoints(e) {
                var t = Ys.createPointGeometry(e.geometry);
                e.setGeometry(t)
            }
            static createPointGeometry(e) {
                return e.indexBuffer ? new Z.Z({
                    buffers: e.buffers.map(e => e.clone()),
                    mode: _.g.POINTS
                }) : e
            }
        }
        class js {
            constructor(e) {
                this._node = e.node, this._engine = e.engine
            }
            render(e) {
                var t, s = this.initDrawUnit();
                return s.technique instanceof ys ? (t = this._node.material.wireframe ? null : this._node.material, s.technique.enableNode(e, this._node.node, t), s.draw(), s) : null
            }
            renderInstance(e) {
                e.technique.updateInstance(this._node.node, !0), e.render()
            }
            initDrawUnit() {
                var e, t = this._engine,
                    s = this._node.geometry;
                return this._node.material.wireframe ? (this._drawUnitWireFrame || (this._drawUnitWireFrame = class {
                    static getWireframeDrawUnit(e) {
                        var t = e.engine,
                            s = e.node.geometry;
                        let r = t.debugTools.wireframeGeometries.get(s);
                        r || (r = this.createWireframeGeometry(s, e.engine), t.debugTools.wireframeGeometries.set(s, r));
                        s = t.adapter.getTechnique({
                            material: t.debugTools.wireframeMaterial,
                            geometry: e.node.geometry,
                            skin: e.node.skin
                        });
                        return new fs({
                            adapter: t.adapter,
                            geometry: r,
                            technique: s
                        })
                    }
                    static createWireframeGeometry(e, t) {
                        return t.adapter.context.vao.unbind(), Ys.createLineGeometry(e)
                    }
                }.getWireframeDrawUnit(this)), this._drawUnitWireFrame) : (this._drawUnit && !this.isTechniqueInvalid() || (e = t.adapter.getTechnique(this._node), this._drawUnit = new fs({
                    adapter: t.adapter,
                    geometry: s,
                    technique: e,
                    start: this._node.geometry.start,
                    count: this._node.geometry.count
                })), this._drawUnit)
            }
            isTechniqueInvalid() {
                var e;
                return this.drawUnit.config.geometry !== this._node.geometry || (e = this.drawUnit.technique.materialEqualsKeys, this._node.material.getEqualsKey() !== e)
            }
            get node() {
                return this._node
            }
            get drawUnit() {
                return this._drawUnit || (this._drawUnit = this.initDrawUnit()), this._drawUnit
            }
            get engine() {
                return this._engine
            }
            dispose(e = !1) {
                this.disposeDrawUnits(), e && this._node.geometry.dispose()
            }
            disposeDrawUnits() {
                this._drawUnit, this._drawUnitWireFrame
            }
        }
        class Ks {
            constructor(e) {
                this.id = ++Ks.highestId, this.name = "", this.buffer = null, this._uploaded = !1;
                e = J.g.mergeConfig(Ks.defaultConfig, e);
                this._config = e, this._ctx = e.context, this._buffer = e.buffer, this.usage = e.usage, this.buffer = this._ctx.createBuffer(), e.lazyUpload || this.bufferData()
            }
            bufferData(e, t) {
                e = e || this._buffer.data, t = null != t ? t : this.usage, e && (this.bind(!1), this._ctx.gl.bufferData(this._buffer.target, e, t), this.uploadDone())
            }
            bufferSubData(e, t = 0) {
                e = e || this._buffer.data, this.bind(!1), this._ctx.gl.bufferSubData(this._buffer.target, t, e), this.uploadDone()
            }
            uploadDone() {
                this._uploaded = !0
            }
            bind(e = !0) {
                this.buffer && (e && this._config.lazyUpload && !this._uploaded && (this.bufferData(), this._uploaded = !0), this._ctx.bindBuffer(this.buffer, this._buffer.target))
            }
            unbind() {
                this._ctx.unbindBuffer(this._buffer.target)
            }
            get arrayBuffer() {
                var e = this._buffer.data;
                return e instanceof ArrayBuffer ? e : e.buffer
            }
            dispose() {
                this.buffer && (this._ctx.deleteBuffer(this.buffer), this.buffer = null)
            }
        }
        Ks.highestId = 0, Ks.defaultConfig = {
            context: null,
            buffer: null,
            usage: _.g.STATIC_DRAW,
            lazyUpload: !1
        };
        var S = c(7723),
            Te = c(2671);
        class qs extends W {
            constructor(e) {
                super({
                    context: e,
                    vertSource: "\n\t\t\t\t\tuniform mat4 u_ViewProjectionMatrix;\n\t\t\t\t\tuniform mat4 u_ModelMatrix;\n\t\t\t\t\t\n\t\t\t\t\tvoid main()\n\t\t\t\t\t{\n\t\t\t\t\t\tvec4 position = u_ModelMatrix * vec4(a_position, 1.0);\n\t\t\t\t\t\tv_uv = position.xz;\n\t\t\t\t\t\tgl_Position = u_ViewProjectionMatrix * position;\n\t\t\t\t\t}\n\t\t\t\t",
                    fragSource: "\n\t\t\t\t\n\t\t\t\t\tfloat gridSize = 200.0;\n\t\t\t\t\tfloat gridCellSize = 0.1;\n\t\t\t\t\tvec4 gridColorThin = vec4(0.3, 0.3, 0.3, 1.0);\n\t\t\t\t\tvec4 gridColorThick = vec4(0.6, 0.6, 0.6, 1.0);\n\t\t\t\t\tconst float gridMinPixelsBetweenCells = 8.0;\n\t\t\t\t\t\n\t\t\t\t\tfloat log10(float x) {\n\t\t\t\t\t\treturn log(x) / log(10.0);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tfloat satf(float x) {\n\t\t\t\t\t\treturn clamp(x, 0.0, 1.0);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tvec2 satv(vec2 x) {\n\t\t\t\t\t\treturn clamp(x, vec2(0.0), vec2(1.0));\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat max2(vec2 v) {\n\t\t\t\t\t\treturn max(v.x, v.y);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tvoid main()\n\t\t\t\t\t{\n\t\t\t\t\t\tvec2 dudv = vec2(\n\t\t\t\t\t\t\tlength(vec2(dFdx(v_uv.x), dFdy(v_uv.x))),\n\t\t\t\t\t\t\tlength(vec2(dFdx(v_uv.y), dFdy(v_uv.y)))\n\t\t\t\t\t\t);\n\t\t\t\t\t\t\n\t\t\t\t\t\tfloat lodLevel = max(0.0,\n\t\t\t\t\t\t\tlog10(\n\t\t\t\t\t\t\t\t(length(dudv) * gridMinPixelsBetweenCells) / gridCellSize\n\t\t\t\t\t\t\t) + 1.0);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\tfloat lodFade = fract(lodLevel);\n\t\t\t\t\t\t\n\t\t\t\t\t\tfloat lod0 = gridCellSize * pow(10.0, floor(lodLevel + 0.0));\n\t\t\t\t\t\tfloat lod1 = gridCellSize * pow(10.0, floor(lodLevel + 1.0));\n\t\t\t\t\t\tfloat lod2 = gridCellSize * pow(10.0, floor(lodLevel + 2.0));\n\t\t\t\t\t\t\n\t\t\t\t\t\tdudv *= 4.0;\n\t\t\t\t\t\t\n\t\t\t\t\t\tfloat lod0a = max2(vec2(1.0) - abs(satv(mod(v_uv, lod0) / dudv) * 2.0 - vec2(1.0)));\n\t\t\t\t\t\tfloat lod1a = max2(vec2(1.0) - abs(satv(mod(v_uv, lod1) / dudv) * 2.0 - vec2(1.0)));\n\t\t\t\t\t\tfloat lod2a = max2(vec2(1.0) - abs(satv(mod(v_uv, lod2) / dudv) * 2.0 - vec2(1.0)));\n\t\t\t\t\t\t\n\t\t\t\t\t\tvec4 c = lod2a > 0.0 ? \n\t\t\t\t\t\t\tgridColorThick\n\t\t\t\t\t\t\t:\n\t\t\t\t\t\t\tlod1a > 0.0 ?\n\t\t\t\t\t\t\t\tmix(gridColorThick, gridColorThin, lodFade)\n\t\t\t\t\t\t\t\t:\n\t\t\t\t\t\t\t\tgridColorThin;\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\tfloat opacityFalloff = 1.0 - satf(length(v_uv) / gridSize);\n\t\t\t\t\t\t\n\t\t\t\t\t\tc.a *= lod2a > 0.0 ? \n\t\t\t\t\t\t\tlod2a\n\t\t\t\t\t\t\t:\n\t\t\t\t\t\t\tlod1a > 0.0 ?\n\t\t\t\t\t\t\t\tlod1a\n\t\t\t\t\t\t\t\t:\n\t\t\t\t\t\t\t\t(lod0a * (1.0 - lodFade));\n\t\t\t\t\t\tc.a *= opacityFalloff * opacityFalloff;\n\t\t\t\t\t\t\n\t\t\t\t\t\t// discard pixel if invisible to allow transparent object to be seen behind the grid\n\t\t\t\t\t\tif (c.a < 0.01) discard;\n\t\t\t\t\t\t\n\t\t\t\t\t\tgl_FragColor = c;\n\t\t\t\t\t}\n\t\t\t\t",
                    attributes: [{
                        name: "a_position",
                        size: 3,
                        semantic: A.p.POSITION
                    }],
                    varyings: {
                        v_uv: "vec2"
                    },
                    uniforms: {
                        u_ViewProjectionMatrix: {
                            type: W.TYPE_MAT4
                        },
                        u_ModelMatrix: {
                            type: W.TYPE_MAT4
                        }
                    }
                })
            }
        }
        class $s {
            constructor(e) {
                this._model = S._.create(), this._adapter = e, this._program = new qs(e.context);
                var t = Ts.getInstance();
                this._drawUnit = new fs({
                    adapter: e,
                    technique: new ws({
                        adapter: e,
                        program: this._program
                    }),
                    geometry: t
                }), S._.fromRotationTranslationScale(this._model, Te.g.fromEuler(Te.g.create(), -90, 0, 0), [0, 0, 0], [300, 300, 1]), this._program.setUniform("u_ModelMatrix", this._model)
            }
            render(e) {
                var t = this._adapter.context;
                t.disable(t.gl.CULL_FACE), t.enableStandardBlend(!1), this._program.setUniform("u_ViewProjectionMatrix", e.getViewProjectionMatrix()), this._drawUnit.draw()
            }
        }
        class Xs extends I {
            static placeholder(s) {
                const {} = s;
                var r = [];
                for (let t = 0; t < s.mipLevels; ++t) {
                    r[t] = [];
                    for (let e = 0; e < 6; ++e) r[t][e] = s.source
                }
                return new Xs({ ...s,
                    sources: r
                })
            }
            constructor(e) {
                super({
                    context: e.context,
                    target: _.g.TEXTURE_CUBE_MAP,
                    minFilter: e.minFilter,
                    magFilter: e.magFilter,
                    flipY: !1,
                    generateMipmap: !1,
                    width: e.width,
                    height: e.height
                }), this.onCubeMapSliced = e => {
                    this.uploadSource(e[0], void 0, void 0, _.g.TEXTURE_CUBE_MAP_POSITIVE_X), this.uploadSource(e[1], void 0, void 0, _.g.TEXTURE_CUBE_MAP_NEGATIVE_X), this.uploadSource(e[2], void 0, void 0, _.g.TEXTURE_CUBE_MAP_POSITIVE_Y), this.uploadSource(e[3], void 0, void 0, _.g.TEXTURE_CUBE_MAP_NEGATIVE_Y), this.uploadSource(e[4], void 0, void 0, _.g.TEXTURE_CUBE_MAP_POSITIVE_Z), this.uploadSource(e[5], void 0, void 0, _.g.TEXTURE_CUBE_MAP_NEGATIVE_Z), this.initTexParameters()
                }, this._width = e.width, this._height = e.height, this._sources = e.sources, this.onSourceLoaded()
            }
            initSource() {}
            onSourceLoaded() {
                this.uploadSources()
            }
            uploadSources() {
                for (let e = 0; e < this._sources.length; ++e) {
                    var t = this._sources[e];
                    this.uploadSource(t[0], this._width, this._height, _.g.TEXTURE_CUBE_MAP_POSITIVE_X, e), this.uploadSource(t[1], this._width, this._height, _.g.TEXTURE_CUBE_MAP_NEGATIVE_X, e), this.uploadSource(t[2], this._width, this._height, _.g.TEXTURE_CUBE_MAP_POSITIVE_Y, e), this.uploadSource(t[3], this._width, this._height, _.g.TEXTURE_CUBE_MAP_NEGATIVE_Y, e), this.uploadSource(t[4], this._width, this._height, _.g.TEXTURE_CUBE_MAP_POSITIVE_Z, e), this.uploadSource(t[5], this._width, this._height, _.g.TEXTURE_CUBE_MAP_NEGATIVE_Z, e)
                }
                this.initTexParameters()
            }
            sliceCubeMap(e, t) {}
        }
        var we = c(8227);
        class Zs {
            static placeholder(s) {
                const {
                    source: e,
                    ...t
                } = s;
                var r = [];
                for (let t = 0; t < s.mipLevels; ++t) {
                    r[t] = [];
                    for (let e = 0; e < 6; ++e) r[t][e] = s.source
                }
                return this.from({ ...t,
                    sources: r
                })
            }
            static from(s) {
                var e, r, i, a, n = [],
                    o = [];
                for (let t = 0; t < s.sources.length; ++t) {
                    const r = s.sources[t];
                    for (let e = 0; e < r.length; ++e) {
                        const i = r[e],
                            a = new X.c;
                        n[t] = n[t] || [], n[t][e] = a, o.push(new Promise((e, t) => {
                            a.signals.load.addOnce(() => {
                                e()
                            })
                        })), "string" == typeof i ? a.setUrlSource(i) : (0, v.JZ)(i) ? a.setMediaSource(i) : a.setDataSource(i || null, 0, 0)
                    }
                }
                var t = new we.a;
                t.wrapS = null != (e = s.wrapS) ? e : t.wrapS, t.wrapT = null != (r = s.wrapT) ? r : t.wrapT, t.minFilter = null != (i = s.minFilter) ? i : t.minFilter, t.magFilter = null != (a = s.magFilter) ? a : t.magFilter;
                const l = new Zs(n, t);
                return Promise.all(o).then(() => {
                    var e;
                    null != (e = s.onLoad) && e.call(s, l)
                }), l
            }
            constructor(e, t) {
                this.id = ++Zs.highestId, this._images = e, this._sampler = t || new we.a
            }
            get images() {
                return this._images
            }
            get sampler() {
                return this._sampler
            }
            isLoaded() {
                for (let e = 0; e < this._images.length; ++e) {
                    var t = this._images[e];
                    for (let e = 0; e < t.length; ++e)
                        if (!t[e].isLoaded()) return !1
                }
                return !0
            }
            get width() {
                var e;
                return null != (e = null == (e = null == (e = this._images[0]) ? void 0 : e[0]) ? void 0 : e.width) ? e : 0
            }
            get height() {
                var e;
                return null != (e = null == (e = null == (e = this._images[0]) ? void 0 : e[0]) ? void 0 : e.height) ? e : 0
            }
        }
        Zs.highestId = 0;
        class Js {
            constructor(e) {
                var t;
                this.signals = {
                    change: n.M.create(),
                    resize: n.M.create()
                }, this._shaderRegistry = new Cs, this._techniqueClasses = new Map, this._techniques = {}, this._renderers = new Map, this._vaoRegistry = new Map, this._buffers = new Map, this._textures = new Map, this._cubeTextures = new Map, this._gammaFactor = 2.2, this._gammaEnabled = !1, this._canvas = e.canvas || (null == (t = e.context) ? void 0 : t.canvas) || document.createElement("canvas"), this._context = e.context || new _s({
                    canvas: this._canvas
                }), this._engine = e.engine, this.init(), this._placeholderTextures = {
                    black: new I({
                        context: this._context,
                        width: 1,
                        height: 1,
                        source: new Uint8Array([0, 0, 0, 255]),
                        minFilter: _.g.NEAREST,
                        magFilter: _.g.NEAREST,
                        wrapS: _.g.CLAMP_TO_EDGE,
                        wrapT: _.g.CLAMP_TO_EDGE
                    }),
                    white: new I({
                        context: this._context,
                        width: 1,
                        height: 1,
                        source: new Uint8Array([255, 255, 255, 255]),
                        minFilter: _.g.NEAREST,
                        magFilter: _.g.NEAREST,
                        wrapS: _.g.CLAMP_TO_EDGE,
                        wrapT: _.g.CLAMP_TO_EDGE
                    }),
                    diffuseEnv: Xs.placeholder({
                        context: this._context,
                        mipLevels: 1,
                        width: 1,
                        height: 1,
                        source: new Uint8Array([255, 255, 255, 255]),
                        minFilter: _.g.LINEAR,
                        magFilter: _.g.LINEAR
                    }),
                    specularEnv: Xs.placeholder({
                        context: this._context,
                        mipLevels: 10,
                        width: 1,
                        height: 1,
                        source: new Uint8Array([255, 255, 255, 255]),
                        minFilter: _.g.LINEAR_MIPMAP_LINEAR,
                        magFilter: _.g.LINEAR
                    })
                }, this.brdfLUT = X.x.from({
                    source: "assets/textures/brdfLUT.png",
                    minFilter: _.g.NEAREST,
                    magFilter: _.g.NEAREST,
                    wrapS: _.g.CLAMP_TO_EDGE,
                    wrapT: _.g.CLAMP_TO_EDGE,
                    flipY: !1,
                    onLoad: () => {
                        this._engine.signals.change.dispatch()
                    }
                })
            }
            init() {
                this.registerTechnique(o.q, Ps), this.registerTechnique(Fs, Ds), this.registerTechnique(ve.z, Os)
            }
            getVAO(e, t) {
                var s = e.id + "-" + t.id,
                    r = this._vaoRegistry.get(s);
                return r || (r = Vs.createVAO({
                    adapter: this,
                    programAttributes: t.attributes,
                    geometry: e
                }), this._vaoRegistry.set(s, r), r)
            }
            createRenderer() {
                return new Ns({
                    engine: this._engine
                })
            }
            createOutlineRenderer() {
                return new Ws(this)
            }
            createGridRenderer() {
                return new $s(this)
            }
            createPixelPicker() {
                return new Is(this._engine)
            }
            renderNode(e, t) {
                for (const s of e.renderNodes) this.getMeshRenderer(s).render(t);
                for (const r of e.children) this.renderNode(r, t)
            }
            setViewport(e) {
                return this._context.viewport(e)
            }
            registerTechnique(e, t) {
                this._techniqueClasses.set(e, t)
            }
            createTechnique(e, t, s) {
                var r = be.h.getClass(e),
                    i = this._techniqueClasses.get(r);
                if (i) return new i(e, t, s, this);
                throw new Error("No technique registered for material class " + r.name)
            }
            getTechnique(e) {
                var t = e.material,
                    s = e.geometry,
                    s = this.createTechnique(t, s, e.skin),
                    e = t.getEqualsKey() + "-" + s.techniqueKey;
                return this._techniques[e] || (this._techniques[e] = s), this._techniques[e]
            }
            getMeshRenderer(e) {
                const t = this._renderers.get(e);
                if (t) return t; {
                    const t = new js({
                        node: e,
                        engine: this._engine
                    });
                    return this._renderers.set(e, t), t
                }
            }
            getRectangleRenderer() {
                return this._rectangleRenderer = this._rectangleRenderer || new Es(this)
            }
            updateBuffer(e) {
                this.getBuffer(e).bufferData()
            }
            getBuffer(e) {
                var t = this._buffers.get(e);
                return t || (t = new Ks({
                    context: this._context,
                    buffer: e
                }), this._buffers.set(e, t), t)
            }
            getTexture(e) {
                var t;
                return e.image.isLoaded() ? (t = this._textures.get(e.image)) ? (e.sampler.needUpdate && (t.wrapS = e.sampler.wrapS, t.wrapT = e.sampler.wrapT, t.minFilter = e.sampler.minFilter, t.magFilter = e.sampler.magFilter), t) : (t = new I({
                    context: this._context,
                    source: e.image.source,
                    width: e.image.width,
                    height: e.image.height,
                    minFilter: e.sampler.minFilter,
                    magFilter: e.sampler.magFilter,
                    wrapS: e.sampler.wrapS,
                    wrapT: e.sampler.wrapT,
                    flipY: e.flipY
                }), this._textures.set(e.image, t), t) : this._placeholderTextures.black
            }
            getCubeTexture(e) {
                var t;
                if (e.isLoaded()) return this._cubeTextures.get(e) || (t = new Xs({
                    context: this._context,
                    sources: e.images.map(e => e.map(e => e.source)),
                    width: e.width,
                    height: e.height,
                    magFilter: e.sampler.magFilter,
                    minFilter: e.sampler.minFilter
                }), this._cubeTextures.set(e, t), t)
            }
            uploadBufferData(e, t, s = _.g.STATIC_DRAW) {
                this.getBuffer(e).bufferData(t, s)
            }
            get placeholderTextures() {
                return this._placeholderTextures
            }
            get shaderRegistry() {
                return this._shaderRegistry
            }
            get canvas() {
                return this._canvas
            }
            get context() {
                return this._context
            }
            get drawingBufferSize() {
                return this._context.drawingBufferSize
            }
            set gammaFactor(e) {
                this._gammaFactor = e
            }
            get gammaFactor() {
                return this._gammaFactor
            }
            set gammaEnabled(e) {
                this._gammaEnabled = e
            }
            get gammaEnabled() {
                return this._gammaEnabled
            }
            get environment() {
                return this._environment = this._environment || {
                    diffuseTexture: this.loadEnvironmentCubeMap("assets/textures/papermill/diffuse/diffuse", 1),
                    specularTexture: this.loadEnvironmentCubeMap("assets/textures/papermill/specular/specular", 10)
                }, this._environment
            }
            loadEnvironmentCubeMap(t, s) {
                var r = [];
                for (let e = 0; e < s; ++e) {
                    const s = [];
                    s[0] = t + "_right_" + e + ".jpg", s[1] = t + "_left_" + e + ".jpg", s[2] = t + "_top_" + e + ".jpg", s[3] = t + "_bottom_" + e + ".jpg", s[4] = t + "_front_" + e + ".jpg", s[5] = t + "_back_" + e + ".jpg", r[e] = s
                }
                return Zs.from({
                    sources: r,
                    minFilter: s < 2 ? _.g.LINEAR : _.g.LINEAR_MIPMAP_LINEAR,
                    magFilter: _.g.LINEAR,
                    onLoad: () => {
                        this.signals.change.dispatch()
                    }
                })
            }
        }
        var N = c(8706);
        class Qs {
            static isSupported(e) {
                var e = e.geometry,
                    t = e.getAttribute(A.p.POSITION),
                    s = e.getAttribute(A.p.NORMAL);
                if (e.mode === _.g.TRIANGLES && t && s && 3 <= (null == t ? void 0 : t.size) && 3 <= (null == s ? void 0 : s.size)) return {
                    positionAttribute: t,
                    normalAttribute: s
                }
            }
            constructor(e, t) {
                this._geometryVersion = -1, this._scale = .1, this._color = 16711680, this._engine = e, this._renderNode = t, this.initScale()
            }
            initScale() {
                var e = pe.B.filter(this._renderNode.getBoundingBox().getSize(), e => 0 < e),
                    e = f.M.min(e),
                    t = this.getQuantizedMultiplier(this._renderNode);
                this._scale = Math.max(.001, .05 * e * .6 * t)
            }
            getQuantizedMultiplier(e) {
                e = e.geometry.getAttribute(A.p.NORMAL);
                if (e && e.componentType !== _.g.FLOAT) {
                    if (e.componentType === _.g.BYTE) return 1 / 127;
                    if (e.componentType === _.g.UNSIGNED_BYTE) return 1 / 255;
                    if (e.componentType === _.g.SHORT) return 1 / 32767;
                    if (e.componentType === _.g.UNSIGNED_SHORT) return 1 / 65535
                }
                return 1
            }
            initRenderNode() {
                var s;
                const r = this._renderNode.geometry,
                    i = r.dataVersion > this._geometryVersion;
                if (!this._meshRenderer || i) {
                    this.dispose();
                    const i = Qs.isSupported(this._renderNode);
                    if (i) {
                        var a = i.positionAttribute,
                            n = i.normalAttribute,
                            o = new N.s(a),
                            l = new N.s(n); {
                            const i = 6,
                                h = null != (s = a.count) ? s : r.vertexCount,
                                c = new Float32Array(6 * h);
                            for (let e = 0; e < h; ++e) {
                                const r = o.readAt(e, 0),
                                    d = o.readAt(e, 1),
                                    u = o.readAt(e, 2),
                                    T = l.readAt(e, 0) * this._scale,
                                    p = l.readAt(e, 1) * this._scale,
                                    m = l.readAt(e, 2) * this._scale;
                                c[6 * e + 0] = r, c[6 * e + 1] = d, c[6 * e + 2] = u, c[6 * e + 3] = r + T, c[6 * e + 4] = d + p, c[6 * e + 5] = u + m
                            }
                            let e, t = 2 * h;
                            if (r.indexBuffer) {
                                const s = r.count,
                                    i = (t = 2 * s, r.indexBuffer.data),
                                    g = xe.W.newTypedArray(i, 2 * s);
                                for (let e = 0; e < s; ++e) {
                                    const s = this._renderNode.geometry.start + e;
                                    g[2 * e] = 2 * i[s], g[2 * e + 1] = 2 * i[s] + 1
                                }
                                e = x.Y.fromData(g)
                            }
                            n = new Z.Z({
                                mode: _.g.LINES,
                                indexBuffer: e,
                                count: t,
                                buffers: [new b.t({
                                    buffer: new w.f({
                                        data: c
                                    }),
                                    attributes: [{
                                        size: 3,
                                        semantic: A.p.POSITION
                                    }]
                                })]
                            });
                            this._meshRenderer = new js({
                                node: new T.j({
                                    node: this._renderNode.node,
                                    material: new Fs,
                                    geometry: n
                                }),
                                engine: this._engine
                            }), this._geometryVersion = r.dataVersion
                        }
                    }
                }
            }
            set scale(e) {
                e !== this._scale && (this._scale = e, this.disposeRenderNode())
            }
            get scale() {
                return this._scale
            }
            set color(e) {
                this._color = e
            }
            get color() {
                return this._color
            }
            render(e) {
                this.initRenderNode(), this._meshRenderer && (this._meshRenderer.node.material.color = this._color, this._meshRenderer.render(e))
            }
            dispose() {
                this.disposeRenderNode()
            }
            disposeRenderNode() {
                this._meshRenderer && (this._meshRenderer.dispose(!0), this._meshRenderer = void 0)
            }
        }
        class er {
            constructor(e) {
                this.wireframeGeometries = new Map, this.wireframeMaterial = new Fs({
                    color: 5872286
                }), this._vertexNormalRenderers = new Map, this.selectionColor = 16748324, this.selectionThickness = .6, this.grid = !0, this._engine = e
            }
            isVertexNormalRendererSupported(e) {
                return !!Qs.isSupported(e)
            }
            getVertexNormalRenderer(e) {
                return this._vertexNormalRenderers.get(e)
            }
            toggleVertexNormals(e, t) {
                if (t) {
                    if (!this._vertexNormalRenderers.get(e)) {
                        const t = new Qs(this._engine, e);
                        return this._vertexNormalRenderers.set(e, t), t
                    }
                } else {
                    const t = this._vertexNormalRenderers.get(e);
                    t && (t.dispose(), this._vertexNormalRenderers.delete(e))
                }
                return null
            }
            render(t) {
                this._vertexNormalRenderers.forEach(e => {
                    e.render(t)
                })
            }
            clear() {
                this._vertexNormalRenderers.forEach(e => {
                    e.dispose()
                }), this._vertexNormalRenderers.clear()
            }
        }
        class tr {
            constructor(e) {
                this._engine = e
            }
            draw(e, t, s, r, i = 1) {
                var [a, n] = this.getNode(), s = (a.renderNodes[0].material.color = s, a.renderNodes[0].material.opacity = i, a.renderNodes[0].geometry.buffers[0].buffer);
                n[0] = e[0], n[1] = e[1], n[2] = e[2], n[3] = t[0], n[4] = t[1], n[5] = t[2], this._engine.adapter.uploadBufferData(s, n, _.g.DYNAMIC_DRAW), this._engine.adapter.renderNode(a, r)
            }
            getNode() {
                var e;
                return this._node && this._lineData || (this._lineData = new Float32Array([0, 0, 0, 1, 0, 0]), e = new Z.Z({
                    buffers: [new b.t({
                        buffer: new w.f({
                            data: this._lineData,
                            usage: _.g.DYNAMIC_DRAW
                        }),
                        attributes: [{
                            size: 3,
                            semantic: A.p.POSITION
                        }]
                    })],
                    mode: _.g.LINES
                }), this._node = q.B.create(e, new Fs)), [this._node, this._lineData]
            }
        }
        class sr {
            constructor() {}
            get unitQuad() {
                return this._unitQuad || (this._unitQuad = this.createUnitQuad()), this._unitQuad
            }
            createUnitQuad() {
                return sr.createUnitQuad()
            }
            static createUnitQuad(e = !1, t = !0) {
                var s = new d.A(0, 0, 1, 1);
                return lt.createGeometry({
                    surface: s,
                    indices: e,
                    interleaved: !0,
                    uSteps: 1,
                    attributes: [{
                        semantic: A.p.POSITION,
                        size: 3
                    }, {
                        semantic: A.p.NORMAL,
                        size: 3
                    }, ...t ? [{
                        semantic: A.p.TEXCOORD_0,
                        size: 2
                    }] : []]
                })
            }
        }
        class rr {
            static isWebGL(e) {
                return e.adapter instanceof Js
            }
            constructor(e) {
                this.signals = {
                    change: n.M.create(),
                    resize: n.M.create()
                }, this._cache = new Map, this._resolutionScale = 1, this._drawing = {
                    line: new tr(this)
                }, this._geometryPool = new sr, this._adapter = e || new Js({
                    engine: this
                }), this._debugTools = new er(this)
            }
            getCache(e, t) {
                return this._cache.get(e) || this._cache.set(e, t()), this._cache.get(e)
            }
            get geometryPool() {
                return this._geometryPool
            }
            set resolutionScale(e) {
                this._resolutionScale !== e && (this._resolutionScale = e, this.signals.resize.dispatch())
            }
            clear() {
                this._debugTools.clear()
            }
            get canvas() {
                return this._adapter.canvas
            }
            get resolutionScale() {
                return this._resolutionScale
            }
            get drawingBufferSize() {
                return this._adapter.drawingBufferSize
            }
            get adapter() {
                return this._adapter
            }
            get debugTools() {
                return this._debugTools
            }
            get drawing() {
                return this._drawing
            }
        }
        class ir {
            constructor(e) {
                this.signals = {
                    start: n.M.create(),
                    update: n.M.create(),
                    end: n.M.create()
                }, this._active = !1, this._pointerDetector = e, this._moveData = {
                    pointer1: null,
                    pointer2: null,
                    startDistance: 0,
                    distance: 0
                }
            }
            listen() {
                this._pointerDetector.signals.down.add(this.onPointerUpOrDown, this), this._pointerDetector.signals.up.add(this.onPointerUpOrDown, this)
            }
            complete() {}
            onPointerUpOrDown() {
                var e = this._pointerDetector.pointersLength;
                this._active || 2 !== e ? this._active && 2 !== e && this.deactivate() : this.activate()
            }
            activate() {
                this._active = !0, this._moveData.pointer1 = this._pointerDetector.pointerArray[0], this._moveData.pointer2 = this._pointerDetector.pointerArray[1];
                var e = this.calculateDistance();
                this._moveData.startDistance = e, this._moveData.distance = e, this.signals.start.dispatch(this._moveData), this._pointerDetector.signals.move.add(this.onPointerMove, this)
            }
            deactivate() {
                this._active = !1, this.refreshDistance(), this.signals.end.dispatch(this._moveData)
            }
            onPointerMove() {
                this._active && (this.refreshDistance(), this.signals.update.dispatch(this._moveData))
            }
            refreshDistance() {
                var e = this.calculateDistance();
                this._moveData.distance = e
            }
            calculateDistance() {
                var e, t = this._moveData.pointer1,
                    s = this._moveData.pointer2;
                return t && s ? (e = t.localX - s.localX, t = t.localY - s.localY, Math.sqrt(e * e + t * t)) : (console.warn("Pointer1 or pointer2 is null"), 0)
            }
            get lastData() {
                return this._moveData
            }
        }
        class ar {
            constructor(e) {
                this.signals = {
                    pan: {
                        start: n.M.create(),
                        update: n.M.create(),
                        end: n.M.create()
                    },
                    click: n.M.create(),
                    longClick: n.M.create()
                }, this._panPointer = null, this._panStarted = !1, this._longClickTimeout = -1, this._longClicked = !1, this._isWithinClickTolerance = !0, this.onPointerDown = e => {
                    this.tryPanStart(), this._longClicked = !1, this._config.longTap.enabled && (this._longClickTimeout = setTimeout(() => {
                        this.onLongTap(e)
                    }, this._config.longTap.timeout))
                }, this.onPointerMove = e => {
                    1 === this._pointerDetector.pointersLength && this._panStarted && (this.pointerIsWithinClickTolerance(e) || (this._isWithinClickTolerance = !1, clearTimeout(this._longClickTimeout)), this._isWithinClickTolerance || this.signals.pan.update.dispatch(e))
                }, this.onPointerUp = e => {
                    0 === this._pointerDetector.pointersLength && this._panStarted && this.finishPan(), clearTimeout(this._longClickTimeout)
                }, this.onStartPinchZoom = e => {
                    this._panStarted && this.finishPan(this._pinchZoom), this._isWithinClickTolerance = !1
                }, this.onEndPinchZoom = e => {
                    this.tryPanStart(this._pinchZoom)
                }, e = J.g.mergeConfig(ar.defaultConfig, e), this._config = e, this._pointerDetector = e.pointerDetector || new Tt({
                    element: this._config.element,
                    parent: e.parent,
                    maxPointers: 3,
                    disableContextMenu: !!e.disableContextMenu,
                    getBufferSize: e.getBufferSize
                }), this._pointerDetector.signals.down.add(this.onPointerDown), this._pointerDetector.signals.move.add(this.onPointerMove), this._pointerDetector.signals.up.add(this.onPointerUp), this._pinchZoom = new ir(this._pointerDetector), this._pinchZoom.signals.start.add(this.onStartPinchZoom), this._pinchZoom.signals.end.add(this.onEndPinchZoom), this._pinchZoom.listen()
            }
            onLongTap(e) {
                this._longClickTimeout = -1, this._longClicked = !0, this.signals.longClick.dispatch(e)
            }
            tryPanStart(e) {
                1 !== this._pointerDetector.pointersLength || this._panStarted || (this._panStarted = !0, this._panPointer = this._pointerDetector.pointerArray[0], this._panPointer.dx = 0, this._panPointer.dy = 0, this._panPointer.offsetX = 0, this._panPointer.offsetY = 0, this._panPointer.startX = this._panPointer.localX, this._panPointer.startY = this._panPointer.localY, e || (this._isWithinClickTolerance = !0), this.signals.pan.start.dispatch(this._panPointer, e))
            }
            finishPan(e) {
                var t;
                this._panStarted && this._panPointer && (this._panStarted = !1, t = this.testClick(this._panPointer, e), this.signals.pan.end.dispatch(this._panPointer, e, t), t && !this._longClicked && this.signals.click.dispatch(this._panPointer), this._panPointer = null)
            }
            testClick(e, t) {
                return !(t || !this._isWithinClickTolerance)
            }
            pointerIsWithinClickTolerance(e) {
                return this._config.clickDistanceTolerance < 0 || Math.sqrt(e.offsetX * e.offsetX + e.offsetY * e.offsetY) < this._config.clickDistanceTolerance
            }
            breakClick() {
                return this._isWithinClickTolerance = !1
            }
            get panPointer() {
                return this._panPointer
            }
            get isWithinClickTolerance() {
                return this._isWithinClickTolerance
            }
            get pinchZoom() {
                return this._pinchZoom
            }
            get pointerDetector() {
                return this._pointerDetector
            }
        }
        ar.defaultConfig = {
            element: null,
            clickDistanceTolerance: 3,
            disableContextMenu: !0,
            longTap: {
                enabled: !1,
                timeout: 2e3
            }
        };
        class nr {
            constructor(e) {
                this.signals = {
                    wheel: n.M.create()
                }, this.onMouseWheel = e => {
                    this._config.preventDefault && e.preventDefault();
                    let t = 0;
                    e.deltaY ? t = -e.deltaY : e.detail && (t = -40 * e.detail), this.signals.wheel.dispatch({
                        event: e,
                        delta: t
                    })
                }, this._config = J.g.mergeConfig(nr.defaultConfig, e), this._config.autoEnable && this.setEnabled(!0)
            }
            setEnabled(e) {
                e ? (this._config.element.addEventListener("mousewheel", this.onMouseWheel), this._config.element.addEventListener("DOMMouseScroll", this.onMouseWheel)) : (this._config.element.removeEventListener("mousewheel", this.onMouseWheel), this._config.element.removeEventListener("DOMMouseScroll", this.onMouseWheel))
            }
        }
        nr.defaultConfig = {
            element: null,
            preventDefault: !0,
            autoEnable: !0
        };
        class or {
            constructor(e, t, s) {
                this.signals = {
                    zoom: n.M.create(),
                    change: n.M.create()
                }, this.getBufferSize = () => this._adapter.drawingBufferSize, this._camera = e, this._adapter = t, this._clamp = s, this._gestures = new ar({
                    element: t.canvas,
                    getBufferSize: this.getBufferSize
                }), this._gestures.signals.pan.start.add(this.onPanStart, this), this._gestures.signals.pan.update.add(this.onPan, this), this._gestures.pinchZoom.signals.update.add(this.onPinchZoom, this), this._mouseWheel = new nr({
                    element: t.canvas.parentElement || t.canvas
                }), this._mouseWheel.signals.wheel.add(this.onMouseWheel, this), this._keyboardListener = new P(this._adapter.canvas.ownerDocument.body), this._keyboardListener.signals.down.add(this.onKeyDown, this)
            }
            onKeyDown(e) {
                let t = null;
                switch (e.keyCode) {
                    case P.KEY_LEFT:
                        t = [1, 0];
                        break;
                    case P.KEY_RIGHT:
                        t = [-1, 0];
                        break;
                    case P.KEY_DOWN:
                        t = [0, -1];
                        break;
                    case P.KEY_UP:
                        t = [0, 1]
                }
                if (t) {
                    const e = 20 / this.getZoom();
                    t[0] *= e, t[1] *= e, this.move(t, this._camera)
                }
            }
            onPanStart(e) {
                this._cameraDown = this._camera.clone()
            }
            onPan(e) {
                var t, s;
                this._cameraDown && (t = this.getZoom(), s = e.offsetX / t, e = e.offsetY / t, this.move([s, e], this._cameraDown))
            }
            move(e, t) {
                var s = this._camera;
                s.left = t.left - e[0], s.right = t.right - e[0], s.top = t.top + e[1], s.bottom = t.bottom + e[1], this.signals.change.dispatch()
            }
            onPinchZoom(e) {
                console.log("pinch zoom", e)
            }
            onMouseWheel(e) {
                var t;
                0 < e.event.buttons || (t = e.delta < 0 ? 1.1 : 1 / 1.1, e = this.findTexelUnderMouse(e.event), this.zoomBy(t, e))
            }
            zoomTo(e) {
                var t = this._camera,
                    s = (t.left + t.right) / 2,
                    r = (t.bottom + t.top) / 2,
                    i = this._adapter.canvas.width / e / 2,
                    e = this._adapter.canvas.height / e / 2;
                t.left = s - i, t.right = s + i, t.bottom = r - e, t.top = r + e, this.signals.change.dispatch(), this.signals.zoom.dispatch()
            }
            zoomBy(e, t) {
                var s = this._camera,
                    r = (s.left + s.right) / 2,
                    i = (s.bottom + s.top) / 2,
                    a = (t = t || [r, i], (s.right - r) * e),
                    n = (s.top - i) * e,
                    a = (s.left = r - a, s.right = r + a, s.bottom = i - n, s.top = i + n, [r - t[0], i - t[1]]),
                    n = a[0] * -e + a[0],
                    r = a[1] * -e + a[1];
                s.left -= n, s.right -= n, s.bottom -= r, s.top -= r, this.signals.change.dispatch(), this.signals.zoom.dispatch()
            }
            findTexelUnderMouse(e, t = !0, s = !1) {
                var r = this._camera,
                    i = this.getZoom(),
                    a = this.getBufferSize(),
                    e = Tt.getLocalCoordsInBuffer(e, this._adapter.canvas, a);
                let n = r.left + e[0] / i,
                    o = r.top - e[1] / i;
                if (t) {
                    const e = this._clamp();
                    n = f.M.clamp(n, 0, e[0]), o = f.M.clamp(o, 0, e[1])
                }
                return s && (n = Math.floor(n), o = Math.floor(o)), [n, o]
            }
            getZoom() {
                var e = this._camera,
                    t = this._adapter.canvas.width,
                    e = e.right - e.left;
                return 0 === t || 0 == e ? 1 : t / e
            }
            get gestures() {
                return this._gestures
            }
        }
        class lr {
            constructor(e) {
                this._target = e
            }
            updateByUrl(e, t = null, s) {
                let r = "";
                ee.U.isMS() || t && (r = ` ${t[0]} ` + t[1]), this.update(`url('${e}')${r}, default`)
            }
            update(e) {
                this._target.style.cursor = e
            }
            clear() {
                this.update("")
            }
            dispose() {
                this.clear()
            }
        }
        class hr {
            constructor(e) {
                this._dom = null, this._mouseEntered = !1, this._enabled = !1, this._mouse = [0, 0], this.onMouseEnter = e => {
                    this._mouseEntered = !0, this.updateStatus()
                }, this.onMouseLeave = e => {
                    this._mouseEntered = !1, this.updateStatus()
                }, this.onMouseMove = e => {
                    this._mouse[0] = e.clientX, this._mouse[1] = e.clientY, this.updatePos()
                }, this._target = e, this._target.addEventListener("mouseenter", this.onMouseEnter), this._target.addEventListener("mouseleave", this.onMouseLeave), this.document.body.addEventListener("mousemove", this.onMouseMove)
            }
            setCursor(e) {
                e ? (this._dom = e, this.enable()) : (this.disable(), this._dom = null)
            }
            enable() {
                this._dom && !this._dom.parentNode && (this._dom.style.zIndex = "9999999999", this._dom.style.position = "absolute", this._dom.style.left = "0", this._dom.style.top = "0", this._dom.style.pointerEvents = "none", this._dom.style.display = "none", this.document.body.appendChild(this._dom)), this._enabled = !0, this.updateStatus()
            }
            disable() {
                yt.detach(this._dom), this._enabled = !1, this.updateStatus()
            }
            updateStatus() {
                var e;
                this._dom && (e = this._enabled && this._mouseEntered, this._dom.style.display = e ? "" : "none", e) && this.updatePos(), this._enabled && (this._target.style.cursor = this._mouseEntered ? "none" : "")
            }
            updatePos() {
                var e = this._mouse[0],
                    t = this._mouse[1];
                this._dom && yt.transform(this._dom, `translate(${e}px, ${t}px) translate(-50%, -50%)`)
            }
            dispose() {
                this._target.removeEventListener("mouseenter", this.onMouseEnter), this._target.removeEventListener("mouseleave", this.onMouseLeave), this.document.body.removeEventListener("mousemove", this.onMouseMove)
            }
            get document() {
                return this._target.ownerDocument
            }
        }
        class cr {
            constructor(e) {
                this._target = e, this._dom = new hr(e), this._css = new lr(e)
            }
            updateCSS(e, t, s) {
                this._css.updateByUrl(e, t, s)
            }
            updateDom(e) {
                this._dom.setCursor(e)
            }
            update(e) {
                this._css.update(e)
            }
            clear() {
                this._css.update(""), this._dom.setCursor(null)
            }
            dispose() {
                this._css.dispose(), this._dom.dispose()
            }
        }
        class dr {
            constructor(e) {
                var t = [{
                    name: "a_position",
                    size: 3,
                    semantic: A.p.POSITION
                }];
                this._drawUnit = new fs({
                    adapter: e,
                    technique: new ws({
                        adapter: e,
                        program: new W({
                            context: e.context,
                            vertSource: "\n\t\t\t\t\t\n\t\t\t\t\t\tuniform float u_step;\n\t\t\t\t\t\tuniform float u_start;\n\t\t\t\t\t\tuniform float u_horizontal; // 0 if vertical, 1 if horizontal\n\t\t\t\t\t\n\t\t\t\t\t\tvoid main()\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvec4 pos = vec4(a_position, 1.0);\n\t\t\t\t\t\t\tpos.x = mix(pos.x, float(gl_InstanceID) * u_step + u_start, 1.0 - u_horizontal);\n\t\t\t\t\t\t\tpos.y = mix(pos.y, float(gl_InstanceID) * u_step + u_start, u_horizontal);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// Convert from [-1, 1] to [0, 1] for the texture read\n\t\t\t\t\t\t\tv_screenPos = (pos.xy / pos.w + vec2(1.0, 1.0)) / 2.0;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tgl_Position = pos;\n\t\t\t\t\t\t}\n\t\t\t\t\t",
                            fragSource: "\n\t\t\t\t\t\n\t\t\t\t\t\tuniform sampler2D u_canvasTexture;\n\t\t\t\t\t\t\n\t\t\t\t\t\tvoid main()\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvec4 color = texture2D(u_canvasTexture, v_screenPos);\n\t\t\t\t\t\t\tfloat brightness = 0.299 * color.r + 0.587 * color.g + 0.114 * color.b;\n\t\t\t\t\t\t\tfloat c = 1.0 - floor(brightness + 0.5); // 0.0 or 1.0\n\t\t\t\t\t\t\tfloat alpha = 0.1;\n\t\t\t\t\t\t\tgl_FragColor = vec4(c, c, c, 1.0) * alpha;\n\t\t\t\t\t\t}\n\t\t\t\t\t",
                            attributes: t,
                            varyings: {
                                v_screenPos: "vec2"
                            },
                            uniforms: {
                                u_canvasTexture: {
                                    type: W.TYPE_SAMPLER_2D
                                },
                                u_step: {
                                    type: W.TYPE_FLOAT
                                },
                                u_start: {
                                    type: W.TYPE_FLOAT
                                },
                                u_horizontal: {
                                    type: W.TYPE_FLOAT
                                }
                            }
                        }),
                        uniforms: {}
                    }),
                    geometry: new Z.Z({
                        mode: _.g.LINES,
                        buffers: [new b.t({
                            buffer: new w.f({
                                data: new Float32Array([-1, -1, 0, 2, 2, 0])
                            }),
                            attributes: t
                        })]
                    })
                })
            }
            render(e, t) {
                var s = this._drawUnit.technique.getProgram(),
                    t = (s.setUniform("u_canvasTexture", t), [2 / (e.right - e.left), 2 / (e.top - e.bottom)]),
                    r = (s.setUniform("u_horizontal", 1), s.setUniform("u_start", -1 - t[1] * (e.bottom % 1)), s.setUniform("u_step", t[1]), Math.floor(e.top - e.bottom) + 2),
                    r = (this._drawUnit.drawInstanced(r), s.setUniform("u_horizontal", 0), s.setUniform("u_start", -1 - t[0] * (e.left % 1)), s.setUniform("u_step", t[0]), Math.floor(e.right - e.left) + 2);
                this._drawUnit.drawInstanced(r)
            }
        }
        class ur {
            constructor(e) {
                this.signals = {
                    rendered: n.M.create()
                }, this._pixelGrid = !0, this._tiledTexture = null, this._needsUpdate = !0, this._canvasTextureInvalid = !0, this.invalidate = () => {
                    this._needsUpdate = !0
                }, this.onUpdate = () => {
                    requestAnimationFrame(this.onUpdate), this._needsUpdate && (this.updateCanvasSize(), this.resizeCamera(this._canvas.width, this._canvas.height), this.render(), this.signals.rendered.dispatch(), this._needsUpdate = !1)
                }, this._canvas = e;
                var t = new _s({
                        canvas: e,
                        depthMask: !1,
                        depthTest: !1,
                        attributes: {
                            preserveDrawingBuffer: !0,
                            depth: !1,
                            antialias: !1,
                            alpha: !1,
                            premultipliedAlpha: !1
                        }
                    }),
                    t = (this._adapter = new Js({
                        context: t,
                        canvas: e,
                        engine: new rr
                    }), this.dpr),
                    s = e.clientWidth * t,
                    t = e.clientHeight * t;
                this._camera = new ge.i({
                    left: -s / 2,
                    right: s / 2,
                    bottom: -t / 2,
                    top: t / 2
                }), this._checkerboardRenderer = new Es(this._adapter, new xs({
                    context: this._adapter.context,
                    fragSource: "\n\t\t\t\tvoid main()\n\t\t\t\t{\n\t\t\t\t\tvec2 boxSize = vec2(10.0, 10.0);\n\t\t\t\t\t\n\t\t\t\t\tfloat x = ceil(gl_FragCoord.x / boxSize.x);\n\t\t\t\t\tfloat y = ceil(gl_FragCoord.y / boxSize.y);\n\t\t\t\t\tfloat sign = mod(x + y, 2.0);\n\t\t\t\t\tgl_FragColor = vec4(vec3(sign) * 0.3 + 0.7, 1.0);\n\t\t\t\t}\n\t\t\t",
                    uniforms: {
                        u_texture: {
                            type: W.TYPE_INT,
                            addToFrag: !1
                        }
                    }
                })), this._navigation = new or(this._camera, this._adapter, () => {
                    var e;
                    return [null != (e = null == (e = this._tiledTexture) ? void 0 : e.width) ? e : 0, null != (e = null == (e = this._tiledTexture) ? void 0 : e.height) ? e : 0]
                }), this._navigation.signals.change.add(this.invalidate), this._cursor = new cr(e), new ResizeObserver(this.invalidate).observe(e), requestAnimationFrame(this.onUpdate)
            }
            updateImage(e) {
                var t, s = !this._tiledTexture;
                null != (t = this._tiledTexture) && t.dispose(), this._tiledTexture = e, this._adapter.context.unbindFramebuffer(), this._adapter.context.viewportToFull(), s && this.fitCameraToCanvas(), this.invalidate()
            }
            fitCameraToCanvas() {
                var e = [null != (e = null == (e = this._tiledTexture) ? void 0 : e.width) ? e : 0, null != (e = null == (e = this._tiledTexture) ? void 0 : e.height) ? e : 0],
                    t = [this._canvas.width, this._canvas.height],
                    t = f.M.fitAroundSize(t, e),
                    s = Math.max(t[0] - e[0], 0) / 2,
                    e = Math.max(t[1] - e[1], 0) / 2;
                this._camera.left = 0 - s, this._camera.bottom = 0 - e, this._camera.right = t[0] - s, this._camera.top = t[1] - e, 1 < this._navigation.getZoom() && this._navigation.zoomTo(1)
            }
            setPixelGrid(e) {
                this._pixelGrid !== e && (this._pixelGrid = e, this.invalidate())
            }
            getPixelGrid() {
                return this._pixelGrid
            }
            render() {
                this._adapter.context.unbindFramebuffer(), this._adapter.context.viewportToFull(), this._adapter.context.enableStandardBlend(!0), this._adapter.context.clear();
                var t, s = [null != (t = null == (s = this._tiledTexture) ? void 0 : s.width) ? t : 0, null != (t = null == (s = this._tiledTexture) ? void 0 : s.height) ? t : 0];
                if (this._checkerboardRenderer.renderUnion({
                        srcTexture: null,
                        dstTexture: null,
                        dstRect: this._camera.createRectangle(),
                        srcRect: d.A.createFromEdges(0, s[0], 0, s[1])
                    }), this._tiledTexture) {
                    const s = this._camera.createRectangle(),
                        t = this._adapter.getRectangleRenderer();
                    this._tiledTexture.eachTile(e => {
                        t.renderUnion({
                            srcTexture: e.texture,
                            dstTexture: null,
                            srcRect: e.rectangle,
                            dstRect: s,
                            textureRect: e.rectangleFull
                        })
                    })
                }
                if (this._pixelGrid && 10 < this._navigation.getZoom()) {
                    this._pixelGridRenderer = null != (t = this._pixelGridRenderer) ? t : new dr(this._adapter);
                    const s = this.getCanvasTexture();
                    this._adapter.context.unbindFramebuffer(), this._pixelGridRenderer.render(this._camera, s)
                }
                this._canvasTextureInvalid = !0
            }
            updateCanvasSize() {
                var e = this.dpr,
                    t = Math.round(this._canvas.clientWidth * e),
                    e = Math.round(this._canvas.clientHeight * e);
                this._canvas.width === t && this._canvas.height === e || (this._canvas.width = t, this._canvas.height = e, this._adapter.context.viewportToFull())
            }
            resizeCamera(e, t) {
                this._navigation.zoomBy(1);
                var s = this._camera,
                    r = (s.left + s.right) / 2,
                    i = (s.bottom + s.top) / 2,
                    a = this._navigation.getZoom(),
                    e = e / 2,
                    t = t / 2;
                s.left = r - e / a, s.right = r + e / a, s.bottom = i - t / a, s.top = i + t / a
            }
            getCanvasTexture() {
                var e = this.canvasSize[0],
                    t = this.canvasSize[1];
                this._canvasTexture || (this._canvasTexture = new I({
                    context: this._adapter.context,
                    width: e,
                    height: t
                }));
                const s = this._canvasTexture;
                if (this._canvasTextureInvalid) {
                    this._canvasTextureInvalid = !1, this._canvasTexture.uploadSource(null, e, t);
                    const r = this._adapter.getRectangleRenderer(),
                        i = this.camera.createRectangle();
                    this._adapter.context.viewportToFull(), null != (e = this._tiledTexture) && e.eachTile(e => {
                        r.renderUnion({
                            srcTexture: e.texture,
                            dstTexture: this._canvasTexture,
                            srcRect: e.rectangle,
                            dstRect: i,
                            textureRect: e.rectangleFull,
                            viewport: [0, 0, s.width, s.height]
                        })
                    })
                }
                return this._canvasTexture
            }
            get navigation() {
                return this._navigation
            }
            get adapter() {
                return this._adapter
            }
            get camera() {
                return this._camera
            }
            get cursor() {
                return this._cursor
            }
            get texture() {
                return this._tiledTexture
            }
            get canvas() {
                return this._canvas
            }
            get dpr() {
                var e;
                return null != (e = null != (e = null == (e = this._canvas.ownerDocument.defaultView) ? void 0 : e.devicePixelRatio) ? e : window.devicePixelRatio) ? e : 1
            }
            get canvasSize() {
                return [this._canvas.width, this._canvas.height]
            }
        }
        class pr extends u.PureComponent {
            render() {
                return u.createElement(G, {
                    className: "zoom",
                    label: "Zoom",
                    postfix: "%",
                    value: Math.round(100 * this.props.zoom),
                    decimals: 0,
                    min: .01,
                    onChange: this.props.onZoomChange
                })
            }
        }
        class mr extends u.PureComponent {
            constructor(e) {
                super(e), this.onZoom = () => {
                    this.forceUpdate()
                }, this.onZoomChange = e => {
                    var t;
                    null != (t = this.props.renderer) && t.navigation.zoomTo(e / 100)
                }
            }
            listenZoom(e) {
                this._renderer !== e && (this._renderer && this._renderer.navigation.signals.zoom.remove(this.onZoom), this._renderer = e, this._renderer) && this._renderer.navigation.signals.zoom.add(this.onZoom)
            }
            render() {
                this.listenZoom(this.props.renderer);
                var e = null != (e = null == (e = this.props.renderer) ? void 0 : e.navigation.getZoom()) ? e : 1,
                    t = null != (t = null == (t = this.props.texture) ? void 0 : t.width) ? t : 0,
                    s = null != (s = null == (s = this.props.texture) ? void 0 : s.height) ? s : 0,
                    r = null != (r = null == (r = this.props.texture) ? void 0 : r.name) ? r : "Untitled";
                return u.createElement("div", {
                    className: "TextureHeader"
                }, u.createElement("div", null, r, " [", t, " x ", s, "]"), u.createElement(pr, {
                    zoom: e,
                    onZoomChange: this.onZoomChange
                }))
            }
        }
        class gr {
            constructor(e, t) {
                this._signals = {
                    exit: n.M.create()
                }, this._id = e, this._label = t
            }
            deactivate() {
                this._signals.exit.removeAll()
            }
            addExitListener(e) {
                this._signals.exit.addOnce(e)
            }
            exit() {
                this._signals.exit.dispatch()
            }
            onKeyDown(e) {
                return !1
            }
            get id() {
                return this._id
            }
            get label() {
                return this._label
            }
        }
        class _r extends gr {
            constructor(e) {
                super("pan", "Pan"), this._renderer = e
            }
            activate() {
                this.setCursorToGrab();
                var e = this._renderer.navigation.gestures;
                e.pointerDetector.signals.down.add(this.onPointerDown, this), e.pointerDetector.signals.up.add(this.onPointerUp, this)
            }
            deactivate() {
                this._renderer.cursor.clear();
                var e = this._renderer.navigation.gestures;
                e.pointerDetector.signals.down.remove(this.onPointerDown, this), e.pointerDetector.signals.up.remove(this.onPointerUp, this), super.deactivate()
            }
            onPointerDown() {}
            onPointerUp() {
                this.setCursorToGrab()
            }
            setCursorToGrab() {}
        }
        class fr extends u.PureComponent {
            constructor() {
                super(...arguments), this.onClick = e => {
                    var t, s;
                    this.props.selected || null == (s = (t = this.props).onChange) || s.call(t, this.props.id)
                }
            }
            render() {
                var {
                    iconUrl: e,
                    selected: t,
                    disabled: s,
                    title: r
                } = this.props, s = h({
                    ToggleIcon: !0,
                    selected: t,
                    disabled: s
                });
                return u.createElement("div", {
                    className: s,
                    onClick: this.onClick,
                    title: r,
                    style: this.props.render ? {} : {
                        backgroundImage: `url("${e}")`
                    }
                }, null == (r = (s = this.props).render) ? void 0 : r.call(s, Boolean(t)))
            }
        }
        class vr extends u.PureComponent {
            constructor() {
                super(...arguments), this.onIconClick = e => {
                    var t, s;
                    null != (s = (t = this.props).onChange) && s.call(t, e)
                }
            }
            render() {
                const {
                    options: e,
                    selected: s
                } = this.props;
                return u.createElement("div", {
                    className: "ToggleBar"
                }, e.map((e, t) => u.createElement(fr, {
                    key: t,
                    id: e.id,
                    iconUrl: e.iconUrl,
                    title: e.title,
                    selected: e.id === s,
                    onChange: this.onIconClick,
                    render: e.render
                })))
            }
        }
        class br extends gr {
            constructor(e, t, s) {
                super(e, t), this._pointerIsDown = !1, this._renderer = s
            }
            activate() {
                this.gestures.pointerDetector.signals.down.add(this.onPointerDown, this, 2)
            }
            deactivate() {
                var e = this.gestures;
                e.pointerDetector.signals.down.remove(this.onPointerDown, this), e.pointerDetector.signals.move.remove(this.onPointerMove, this), e.pointerDetector.signals.up.remove(this.onPointerUp, this)
            }
            onPointerDown(e, t) {
                e.button <= 0 && (this._pointerIsDown = !0, t.halt(), (t = this.gestures).pointerDetector.signals.move.add(this.onPointerMove, this, 2), t.pointerDetector.signals.up.add(this.onPointerUp, this, 2), this._downPoint = this.pointer2world(e), this._currentPoint = re.K.clone(this._downPoint), this.down(e))
            }
            onPointerMove(e, t) {
                this._currentPoint = this.pointer2world(e), this.move(e)
            }
            onPointerUp(e, t) {
                this._pointerIsDown = !1, this.up(e);
                e = this.gestures;
                e.pointerDetector.signals.move.remove(this.onPointerMove, this), e.pointerDetector.signals.up.remove(this.onPointerUp, this)
            }
            down(e) {}
            move(e) {}
            up(e, t) {}
            pointer2world(e, t = !0) {
                e = this.convertToWorld([e.localX, e.localY]);
                return t && (e[0] = Math.round(e[0]), e[1] = Math.round(e[1])), e
            }
            convertToWorld(e) {
                var t = [this._renderer.adapter.canvas.width, this._renderer.adapter.canvas.height],
                    s = this._renderer.camera,
                    r = s.right - s.left,
                    i = s.top - s.bottom,
                    e = (e[1] = t[1] - e[1], [e[0] / t[0], e[1] / t[1]]);
                return [e[0] * r + s.left, e[1] * i + s.bottom]
            }
            get gestures() {
                return this._renderer.navigation.gestures
            }
        }
        class xr {
            constructor(e) {
                var t;
                this.signals = {
                    size: n.M.create(),
                    hardness: n.M.create()
                }, this._size = [0, 0], this._hardness = 1, this._color = 16777215, this._dirty = !0, this._texture = null != (t = e.texture) ? t : new I({
                    context: e.adapter.context,
                    width: 256,
                    height: 256,
                    source: ce.P.inst.createCircle(128, 16711680),
                    premultipliedAlpha: !0,
                    magFilter: _.g.LINEAR
                }), this._tile = new Bt(e.adapter, this._texture, new d.A(0, 0, 1, 1), 0, 0, null), this.setSize(e.size), this.setHardness(100)
            }
            setPos(e) {
                this._tile.oRect.x = e[0], this._tile.oRect.y = e[1], this._tile.updateRectangle()
            }
            render(e) {
                this.updateBrush();
                var t = this._tile.adapter.context,
                    e = (t.enableStandardBlend(!0), this._tile.render(e));
                return t.blend(!1), e
            }
            updateBrush() {
                var e;
                this._dirty && (e = ce.P.inst.createCircle(128, this._color), this._texture.uploadSource(e), this._texture.generateMipmap(), this._dirty = !1)
            }
            setSize(e) {
                this._size && f.M.equals(e, this._size) || (this._size = e, this._tile.oRect.width = e[0], this._tile.oRect.height = e[1], this._tile.updateRectangle(), this.signals.size.dispatch(this))
            }
            setHardness(e) {
                void 0 === this._hardness && this._hardness === e || (this._hardness = e, this._dirty = !0)
            }
            getSize() {
                return this._size
            }
            getHardness() {
                return this._hardness
            }
            setColor(e) {
                void 0 === this._color && this._color === e || (this._color = e, this._dirty = !0)
            }
        }
        class Tr {
            constructor(e, t) {
                this._brush = e, this._renderer = t, this._canvas = t.canvas.ownerDocument.createElement("canvas")
            }
            activate() {
                this._brush.signals.size.add(this.onBrushSizeChange, this), this._renderer.navigation.signals.zoom.add(this.onZoomChange, this), this._renderer.cursor.updateDom(this._canvas), this.updateSize()
            }
            deactivate() {
                this._renderer.cursor.clear(), this._brush.signals.size.remove(this.onBrushSizeChange, this), this._renderer.navigation.signals.zoom.remove(this.onZoomChange, this)
            }
            onBrushSizeChange() {
                this.updateSize()
            }
            onZoomChange() {
                this.updateSize()
            }
            updateSize() {
                var e = this._renderer.navigation.getZoom(),
                    e = this._brush.getSize()[0] / 2 * e,
                    t = e / Math.sqrt(2);
                this._renderer.canvasSize[0] > t || this._renderer.canvasSize[1] > t ? this.drawToCanvas(e) : this.drawToCanvas(10)
            }
            drawToCanvas(e) {
                var t = 2 * e,
                    t = (this._canvas.width = 2 + t, this._canvas.height = 2 + t, t / this._renderer.dpr),
                    t = (this._canvas.style.width = t + "px", this._canvas.style.height = t + "px", this._canvas.getContext("2d"));
                if (!t) throw new Error("Failed to get 2d context");
                t.beginPath(), t.arc(e + 1, e + 1, e, 0, 2 * Math.PI, !0), t.closePath(), t.lineWidth = 2, t.strokeStyle = "rgba(255, 255, 255, 0.4)", t.stroke(), t.lineWidth = 1, t.strokeStyle = "#000000", t.stroke()
            }
        }
        class wr {
            static interpolate2d(e, t, s, r) {
                return e[0] = t[0] + (s[0] - t[0]) * r, e[1] = t[1] + (s[1] - t[1]) * r, e
            }
            static distanceLineLine(e, t, s, r, i) {
                var a = M.R.sub(M.R.create(), s, e),
                    n = M.R.dot(t, t),
                    o = M.R.dot(r, r),
                    l = M.R.dot(t, r),
                    h = l * l - n * o;
                if (Math.abs(h) > Number.MIN_VALUE) {
                    h = 1 / h;
                    const c = M.R.dot(a, t),
                        d = M.R.dot(a, r),
                        u = (l * d - o * c) * h,
                        p = (n * d - l * c) * h,
                        m = M.R.scaleAndAdd(M.R.create(), e, t, u),
                        g = M.R.scaleAndAdd(M.R.create(), s, r, p);
                    return i && (i[0] = u, i[1] = p), M.R.magnitude(M.R.sub(M.R.create(), m, g))
                }
                const c = M.R.cross(M.R.create(), a, t);
                return Math.sqrt(M.R.dot(c, c) / n)
            }
        }
        class Er extends br {
            constructor(e) {
                super("brush", "Brush", e), this._lastTexel = null, this._brush = new xr({
                    adapter: e.adapter,
                    size: [20, 20]
                }), this._cursor = new Tr(this._brush, e)
            }
            activate() {
                super.activate(), this._cursor.activate()
            }
            deactivate() {
                this._cursor.deactivate(), super.deactivate()
            }
            onColorChange() {}
            down(e) {
                this.drawAtPointer(e)
            }
            move(e) {
                this.drawAtPointer(e)
            }
            up(e) {
                this._lastTexel = null
            }
            drawAtPointer(e) {
                e = this._renderer.navigation.findTexelUnderMouse(e.pointerData, !1);
                this._lastTexel ? this.drawInterpolated(e) : this.draw(e), this._lastTexel = e
            }
            drawInterpolated(t) {
                if (this._lastTexel) {
                    var e = re.K.len(re.K.sub([], this._lastTexel, t));
                    if (0 < e) {
                        var s = [0, 0],
                            r = Math.min(2, this._brush.getSize()[0] / 8),
                            i = Math.floor(e / r);
                        if (1 < i)
                            for (let e = 1; e < i; ++e) wr.interpolate2d(s, this._lastTexel, t, e / (i - 1)), this.draw(s);
                        else this.draw(t)
                    }
                }
            }
            draw(e) {
                this._brush.setPos(e), null != (e = this._renderer.texture) && e.eachTile(e => {
                    this._brush.render(e) && e.texture.generateMipmap()
                }), this._renderer.adapter.context.unbindFramebuffer(), this._renderer.adapter.context.viewportToFull(), this._renderer.invalidate()
            }
            get brush() {
                return this._brush
            }
        }
        const Cr = e => {
            const t = e.brush,
                s = (0, u.useCallback)(e => {
                    t.setSize([e, e])
                }, []);
            return u.createElement("div", {
                className: "BrushOptions"
            }, u.createElement(G, {
                label: "Brush size",
                value: t.getSize()[0],
                onChange: s
            }))
        };
        class yr {
            constructor(e, t, s, r) {
                this._xSign = 0, this._ySign = 0, this._element = e, this._cropTool = r, this._xSign = t, this._ySign = s;
                e = new Tt({
                    element: this._element,
                    parent: this._cropTool.parent,
                    maxPointers: 1
                });
                e.signals.down.add(this.onPointerDown, this), e.signals.move.add(this.onPointerMove, this)
            }
            onPointerDown(e) {
                e.originalEvent.stopImmediatePropagation(), this.saveDownPos()
            }
            onPointerMove(e) {
                e.originalEvent.stopImmediatePropagation(), this._cropTool.scaleEdge(e, this._xSign, this._ySign)
            }
            saveDownPos() {
                this._cropTool.startScaleEdge()
            }
        }
        class Ar {
            static createDivFromHTML(e, t = document) {
                e = e.trim(), Ar.temp = Ar.temp || t.createElement("div"), Ar.temp.innerHTML = e;
                let s, r = Ar.temp.childNodes;
                return 1 === r.length && Ar.temp.children[0] ? (s = r[0], Ar.temp.removeChild(s)) : (s = Ar.temp, Ar.temp = null), s
            }
        }
        class Mr {
            constructor(e) {
                this._document = e, this._element = Ar.createDivFromHTML('<div class="cropRectangle">\n\t\t\t\t<div id="center"    class="center"                 style="cursor: move"></div>\n\t\t\t\t<div id="side_l"    class="side vertical left"     style="cursor: ew-resize"></div>\n\t\t\t\t<div id="side_r"    class="side vertical right"    style="cursor: ew-resize"></div>\n\t\t\t\t<div id="side_b"    class="side horizontal bottom" style="cursor: ns-resize"></div>\n\t\t\t\t<div id="side_t"    class="side horizontal top"    style="cursor: ns-resize"></div>\n\t\t\t\t<div id="corner_bl" class="corner bottom left"     style="cursor: nesw-resize"></div>\n\t\t\t\t<div id="corner_br" class="corner bottom right"    style="cursor: nwse-resize"></div>\n\t\t\t\t<div id="corner_tl" class="corner top left"        style="cursor: nwse-resize"></div>\n\t\t\t\t<div id="corner_tr" class="corner top right"       style="cursor: nesw-resize"></div>\n\t\t\t</div>', e)
            }
            update(e, t, s, r) {
                var i = null != (i = null != (i = null == (i = this._document.defaultView) ? void 0 : i.devicePixelRatio) ? i : window.devicePixelRatio) ? i : 1;
                e /= i, t /= i, r /= i, this._element.style.width = (s /= i) + "px", this._element.style.height = r + "px", yt.translate(this._element, e, t)
            }
            getChild(e) {
                var t = this._element.querySelector("#" + e);
                if (t) return t;
                throw new Error(`Element with id "${e}" not found`)
            }
            get element() {
                return this._element
            }
        }
        class Rr {
            constructor(e) {
                var t = [{
                    name: "a_position",
                    size: 3,
                    semantic: A.p.POSITION
                }];
                this._drawUnit = new fs({
                    adapter: e,
                    technique: new ws({
                        adapter: e,
                        program: new W({
                            context: e.context,
                            vertSource: "\n\t\t\t\t\t\n\t\t\t\t\t\tuniform mat4 u_viewProjectionMatrix;\n\t\t\t\t\t\tuniform mat4 u_modelMatrix;\n\t\t\t\t\t\n\t\t\t\t\t\tvoid main()\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvec4 pos = u_viewProjectionMatrix * u_modelMatrix * vec4(a_position, 1.0);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// Convert from [-1, 1] to [0, 1] for the texture read\n\t\t\t\t\t\t\tv_screenPos = (pos.xy / pos.w + vec2(1.0, 1.0)) / 2.0;\n\t\t\t\t\t\t\tgl_Position = pos;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t//v_screenPos = (a_position.xy + vec2(1.0, 1.0)) / 2.0;\n\t\t\t\t\t\t\t//gl_Position = vec4(a_position, 1.0);\n\t\t\t\t\t\t}\n\t\t\t\t\t",
                            fragSource: "\n\t\t\t\t\t\n\t\t\t\t\t\tuniform sampler2D u_canvasTexture;\n\t\t\t\t\t\t\n\t\t\t\t\t\tvoid main()\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvec4 color = texture2D(u_canvasTexture, v_screenPos);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// We want:\n\t\t\t\t\t\t\t// black transparent pixels\n\t\t\t\t\t\t\t// white on out of bounds pixels\n\t\t\t\t\t\t\t// black or white on the rest, depending on brightness\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tfloat brightness = max(max(color.r, color.g), color.b);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tfloat c = 1.0 - floor(brightness + 0.5); // 0.0 or 1.0\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (color.a == 0.0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tc = 0.5;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t\tgl_FragColor = vec4(c, c, c, 1.0);\n\t\t\t\t\t\t\t//gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\n\t\t\t\t\t\t}\n\t\t\t\t\t",
                            attributes: t,
                            varyings: {
                                v_screenPos: "vec2"
                            },
                            uniforms: {
                                u_viewProjectionMatrix: {
                                    type: W.TYPE_MAT4
                                },
                                u_modelMatrix: {
                                    type: W.TYPE_MAT4
                                },
                                u_canvasTexture: {
                                    type: W.TYPE_SAMPLER_2D
                                }
                            }
                        }),
                        uniforms: {}
                    }),
                    geometry: new Z.Z({
                        mode: _.g.LINES,
                        buffers: [new b.t({
                            buffer: new w.f({
                                data: this.createLineData()
                            }),
                            attributes: t
                        })]
                    })
                })
            }
            createLineData() {
                var t = [];
                for (let e = 0; e < 4; ++e) {
                    var s = 2 * (e / 3 - .5);
                    t.push(-.5, .5 * s, 0), t.push(.5, .5 * s, 0)
                }
                for (let e = 0; e < 4; ++e) {
                    var r = 2 * (e / 3 - .5);
                    t.push(.5 * r, -.5, 0), t.push(.5 * r, .5, 0)
                }
                return new Float32Array(t)
            }
            render(e, t, s) {
                this.updateRectangle(e), this._drawUnit.technique.getProgram().setUniform("u_viewProjectionMatrix", t.getViewProjectionMatrix()), this._drawUnit.technique.getProgram().setUniform("u_canvasTexture", s), this._drawUnit.draw()
            }
            updateRectangle(e) {
                var t = e[0] + e[2] / 2,
                    s = e[1] + e[3] / 2,
                    r = S._.create();
                S._.translate(r, r, [t, s, 0]), S._.setScale(r, [e[2], e[3], 1]), this._drawUnit.technique.getProgram().setUniform("u_modelMatrix", r)
            }
        }
        class Sr {
            constructor(e) {
                var t = [{
                    name: "a_position",
                    size: 3,
                    semantic: A.p.POSITION
                }];
                this._drawUnit = new fs({
                    adapter: e,
                    technique: new ws({
                        adapter: e,
                        program: new W({
                            context: e.context,
                            vertSource: "\n\t\t\t\t\t\tuniform mat4 u_viewProjectionMatrix;\n\t\t\t\t\t\tuniform mat4 u_modelMatrix;\n\t\t\t\t\t\n\t\t\t\t\t\tvoid main()\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tgl_Position = u_viewProjectionMatrix * u_modelMatrix * vec4(a_position, 1.0);\n\t\t\t\t\t\t}\n\t\t\t\t\t",
                            fragSource: "\n\t\t\t\t\t\tvoid main()\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tgl_FragColor = vec4(0.0, 0.0, 0.0, 0.75);\n\t\t\t\t\t\t}\n\t\t\t\t\t",
                            attributes: t,
                            uniforms: {
                                u_viewProjectionMatrix: {
                                    type: W.TYPE_MAT4
                                },
                                u_modelMatrix: {
                                    type: W.TYPE_MAT4
                                }
                            }
                        })
                    }),
                    geometry: Ts.getInstance()
                })
            }
            render(e, t, s, r) {
                r.blend(!0);
                var i = t.left,
                    a = e[0],
                    n = e[0] + e[2],
                    o = t.right,
                    l = t.bottom,
                    h = e[1],
                    e = e[1] + e[3],
                    c = t.top;
                this.drawRect([i, a, l, c], t), this.drawRect([n, o, l, c], t), this.drawRect([a, n, l, h], t), this.drawRect([a, n, e, c], t), r.blend(!1)
            }
            drawRect(e, t) {
                var e = [(e[0] + e[1]) / 2, (e[2] + e[3]) / 2, e[1] - e[0], e[3] - e[2]],
                    s = S._.create();
                S._.translate(s, s, [e[0], e[1], 0, 0]), S._.setScale(s, [e[2], e[3], 1]), this._drawUnit.technique.getProgram().setUniform("u_modelMatrix", s), this._drawUnit.technique.getProgram().setUniform("u_viewProjectionMatrix", t.getViewProjectionMatrix()), this._drawUnit.draw()
            }
        }
        class Nr {
            constructor(e) {
                this._rectangleView = new Rr(e), this._shadingView = new Sr(e)
            }
            render(e, t, s, r) {
                var i = r.context;
                i.depthTest = !1, i.depthMask = !1, i.unbindFramebuffer(), this._shadingView.render(t, s, e, r.context), this._rectangleView.render(t, s, r), i.depthTest = !0, i.depthMask = !0
            }
        }
        class Ir extends gr {
            constructor(e, t) {
                super("crop", "Crop"), this.signals = {
                    update: n.M.create()
                }, this._cropArea = [0, 0, 0, 0], this._downPoint = [0, 0], this._downArea = [0, 0, 0, 0], this._snap = !0, this._first = !0, this.onKeyDown = e => "Enter" === e.key ? (this.apply(), !0) : "Escape" === e.key && (this.exit(), !0), this.updateView = () => {
                    var e, t = this._renderer.canvasSize,
                        s = this._cropArea,
                        r = this.world2camera([s[0], s[1]]),
                        s = this.world2camera([s[0] + s[2], s[1] + s[3]]),
                        i = r[0] * t[0],
                        r = r[1] * t[1];
                    null != (e = this._controls) && e.update(i, t[1] - s[1] * t[1], s[0] * t[0] - i, s[1] * t[1] - r), null != (e = this._view) && e.render(t, this._cropArea, this._renderer.camera, this._renderer.getCanvasTexture())
                }, this._renderer = e, this._onChangeTexture = t
            }
            activate() {
                this._first && (this._first = !1, this.init());
                var e = [(null == (e = this._renderer.texture) ? void 0 : e.width) || 0, (null == (e = this._renderer.texture) ? void 0 : e.height) || 0];
                this.updateArea(g.v.fromValues(0, 0, e[0], e[1])), null != (e = null == (e = this._renderer.canvas.parentNode) ? void 0 : e.querySelector(".scrollDiv")) && e.appendChild(this._controls.element), this._renderer.signals.rendered.add(this.updateView, this)
            }
            init() {
                this._controls = new Mr(this._renderer.canvas.ownerDocument || document), this._view = new Nr(this._renderer.adapter);
                var e = new Tt({
                    element: this._controls.element,
                    parent: this.parent,
                    maxPointers: 1
                });
                e.signals.down.add(this.onPointerDown, this), e.signals.move.add(this.onPointerMove, this), this.addScaler(-1, -1, this._controls.getChild("corner_bl")), this.addScaler(1, -1, this._controls.getChild("corner_br")), this.addScaler(-1, 1, this._controls.getChild("corner_tl")), this.addScaler(1, 1, this._controls.getChild("corner_tr")), this.addScaler(-1, 0, this._controls.getChild("side_l")), this.addScaler(1, 0, this._controls.getChild("side_r")), this.addScaler(0, -1, this._controls.getChild("side_b")), this.addScaler(0, 1, this._controls.getChild("side_t"))
            }
            deactivate() {
                var e;
                null != (e = null == (e = this._renderer.canvas.parentNode) ? void 0 : e.querySelector(".scrollDiv")) && e.removeChild(this._controls.element), this._renderer.signals.rendered.remove(this.updateView, this), this._renderer.invalidate(), super.deactivate()
            }
            addScaler(e, t, s) {
                new yr(s, e, t, this)
            }
            onPointerDown(e) {
                this._downPoint = this.pointer2world(e), this._downArea = g.v.clone(this._cropArea)
            }
            onPointerMove(e) {
                var t = this.pointer2world(e),
                    s = g.v.clone(this._downArea);
                s[0] += t[0] - this._downPoint[0], s[1] += t[1] - this._downPoint[1], this.snapMove(s, e), this.updateAreaByPointer(s, e)
            }
            update(e, t, s, r) {
                void 0 !== e && (this._cropArea[0] = e), void 0 !== t && (this._cropArea[1] = t), void 0 !== s && (this._cropArea[2] = s), void 0 !== r && (this._cropArea[3] = r), this.updateArea(this._cropArea, !1)
            }
            apply() {
                var e;
                this._renderer.texture && (e = this._renderer.texture.crop({
                    rectangle: this._cropArea,
                    resample: !0
                }), this._onChangeTexture(e)), this.exit()
            }
            snapMove(e, t) {
                var s = e[0],
                    r = e[0] + e[2],
                    i = this.snapEdge(s, void 0, t),
                    r = this.snapEdge(r, void 0, t),
                    s = (e[0] = i !== s ? i : r - e[2], e[1]),
                    i = e[1] + e[3],
                    r = this.snapEdge(void 0, s, t),
                    i = this.snapEdge(void 0, i, t);
                e[1] = r !== s ? r : i - e[3]
            }
            snapEdge(e, t, s) {
                var r = this._renderer.camera;
                let i = 10 * this._renderer.dpr;
                var s = !s.originalEvent.ctrlKey && this._snap,
                    a = [
                        [0, (null == (a = this._renderer.texture) ? void 0 : a.width) || 0],
                        [0, (null == (a = this._renderer.texture) ? void 0 : a.height) || 0]
                    ];
                if (void 0 !== e) {
                    if (i *= (r.right - r.left) / this._renderer.canvasSize[0], s)
                        for (const t of a[0])
                            if (Math.abs(e - t) < i) return t;
                    return e
                }
                if (void 0 === t) throw new Error("Need to specify either x or y");
                if (i *= (r.top - r.bottom) / this._renderer.canvasSize[1], s)
                    for (var n of a[1])
                        if (Math.abs(t - n) < i) return n;
                return t
            }
            startScaleEdge() {
                this._downArea = g.v.clone(this._cropArea)
            }
            scaleEdge(e, t, s) {
                var r = this.pointer2world(e),
                    i = this._cropArea,
                    a = this._downArea;
                if (0 !== t && (r[0] = this.snapEdge(r[0], void 0, e)), 0 !== s && (r[1] = this.snapEdge(void 0, r[1], e)), t < 0) {
                    const e = a[0] + a[2];
                    e - r[0] < 1 && (r[0] = e - 1), i[0] = r[0], i[2] = e - r[0]
                } else 0 < t && (i[2] = Math.max(1, r[0] - a[0]));
                if (s < 0) {
                    const e = a[1] + a[3];
                    e - r[1] < 1 && (r[1] = e - 1), i[1] = r[1], i[3] = e - r[1]
                } else 0 < s && (i[3] = Math.max(1, r[1] - a[1]));
                this.updateAreaByPointer(this._cropArea, e)
            }
            updateAreaByPointer(e, t) {
                this.updateArea(e, !1)
            }
            updateArea(e, t = !0) {
                g.v.copy(this._cropArea, e);
                e = this._cropArea;
                e[0] = Math.round(e[0]), e[1] = Math.round(e[1]), e[2] = Math.round(e[2]), e[3] = Math.round(e[3]), t ? this.updateView() : this._renderer.invalidate(), this.signals.update.dispatch()
            }
            pointer2world(e, t = !0) {
                var s = this._renderer.dpr,
                    r = e.localX * s,
                    e = e.localY * s,
                    s = this.screen2world([r, e]);
                return t && (s[0] = Math.round(s[0]), s[1] = Math.round(s[1])), s
            }
            world2camera(e) {
                var t = this._renderer.camera,
                    s = t.right - t.left,
                    r = t.top - t.bottom;
                return [(e[0] - t.left) / s, (e[1] - t.bottom) / r]
            }
            screen2world(e) {
                var t = this._renderer.canvasSize,
                    s = this._renderer.camera,
                    r = s.right - s.left,
                    i = s.top - s.bottom,
                    e = (e[1] = t[1] - e[1], [e[0] / t[0], e[1] / t[1]]);
                return [e[0] * r + s.left, e[1] * i + s.bottom]
            }
            set snap(e) {
                this._snap = e
            }
            get snap() {
                return this._snap
            }
            get parent() {
                return this._renderer.canvas
            }
            get area() {
                return this._cropArea
            }
        }
        class Pr extends u.PureComponent {
            constructor(e) {
                super(e), this.onUpdate = () => {
                    this.forceUpdate()
                }, this.onChangeX = e => {
                    this.props.tool.update(e, void 0, void 0, void 0), this.forceUpdate()
                }, this.onChangeY = e => {
                    this.props.tool.update(void 0, e, void 0, void 0), this.forceUpdate()
                }, this.onChangeWidth = e => {
                    this.props.tool.update(void 0, void 0, e, void 0), this.forceUpdate()
                }, this.onChangeHeight = e => {
                    this.props.tool.update(void 0, void 0, void 0, e), this.forceUpdate()
                }, this.onSnapChange = e => {
                    this.props.tool.snap = e, this.forceUpdate()
                }, this.onApply = () => {
                    this.props.tool.apply(), this.props.tool.exit()
                }, this.onCancel = () => {
                    this.props.tool.exit()
                }, this._activeTool = this.listenTool(e.tool)
            }
            listenTool(e) {
                return e !== this._activeTool && (this._activeTool && this._activeTool.signals.update.remove(this.onUpdate), this._activeTool = e, this._activeTool) && e.signals.update.add(this.onUpdate), e
            }
            render() {
                var e = this.props.tool,
                    [t, s, r, i] = (this.listenTool(e), e.area);
                return u.createElement("div", {
                    className: "CropUI"
                }, u.createElement("div", {
                    className: "header"
                }, "Crop area"), u.createElement("div", {
                    className: "cropArea"
                }, u.createElement(G, {
                    label: "x",
                    value: t,
                    decimals: 0,
                    onChange: this.onChangeX
                }), u.createElement(G, {
                    label: "y",
                    value: s,
                    decimals: 0,
                    onChange: this.onChangeY
                }), u.createElement(G, {
                    label: "width",
                    value: r,
                    decimals: 0,
                    onChange: this.onChangeWidth
                }), u.createElement(G, {
                    label: "height",
                    value: i,
                    decimals: 0,
                    onChange: this.onChangeHeight
                })), u.createElement("br", null), u.createElement(k, {
                    label: "Snap"
                }, u.createElement(U, {
                    value: e.snap,
                    onChange: this.onSnapChange
                })), u.createElement("br", null), u.createElement("div", {
                    className: "hbox"
                }, u.createElement(Rt, {
                    label: "Cancel",
                    onClick: this.onCancel
                }), u.createElement(Rt, {
                    label: "Apply",
                    onClick: this.onApply
                })))
            }
        }
        class Fr extends gr {
            constructor(e) {
                super("colorpicker", "Color Picker"), this.signals = {
                    onMouseMove: n.M.create(),
                    colorChange: n.M.create()
                }, this.onMouseOut = () => {
                    this._renderer.cursor.clear(), this.signals.onMouseMove.dispatch(void 0, [0, 0], [0, 0])
                }, this._renderer = e
            }
            activate() {
                this._renderer.cursor.updateCSS("assets/ui/input/color/circle_magnifier.svg", [7, 7]);
                var e = this._renderer.navigation.gestures;
                e.pointerDetector.signals.hoverMove.add(this.hoverMove, this, 2), e.pointerDetector.config.element.addEventListener("mouseout", this.onMouseOut)
            }
            deactivate() {
                this._renderer.cursor.clear();
                var e = this._renderer.navigation.gestures;
                e.pointerDetector.signals.hoverMove.add(this.hoverMove, this, 2), e.pointerDetector.config.element.addEventListener("mouseout", this.onMouseOut), super.deactivate()
            }
            updateColor(e) {
                this.signals.colorChange.dispatch(e)
            }
            hoverMove(e) {
                var t, s;
                0 == e.originalEvent.buttons && this._renderer.texture && (t = [e.localX, this._renderer.canvasSize[1] - e.localY], s = this._renderer.canvas.ownerDocument.body, e = Tt.getLocalCoords(e.pointerData, s), this._renderer.cursor.updateCSS("assets/ui/input/color/circle_magnifier.svg", [7, 7]), this.signals.onMouseMove.dispatch(this._renderer.getCanvasTexture(), t, e))
            }
            get color() {
                return "#ff0000"
            }
            onPointerDown() {}
            onPointerUp() {
                this.setCursorToGrab()
            }
            setCursorToGrab() {}
        }
        const Lr = e => {
            const [t, s] = u.useState(0), r = (0, u.useCallback)(e => {
                s(e)
            }, []);
            (0, u.useEffect)(() => (e.tool && e.tool.signals.colorChange.add(r), () => {
                e.tool && e.tool.signals.colorChange.remove(r)
            }), [e.tool]);
            var i = m.I.removeAlpha(t).toString(16),
                [a, n, o, , ] = m.I.hexRGBA2array(t),
                l = m.I.getAlpha(t),
                h = `rgba(${a/255}, ${n/255}, ${o/255}, ${l})`;
            return u.createElement("div", {
                className: "ColorPickerUI"
            }, u.createElement("div", {
                className: "hbox vcenter"
            }, u.createElement(At, {
                label: "Hex",
                placeholder: "Untitled",
                value: i
            }), u.createElement(G, {
                label: "A",
                value: Math.round(100 * l),
                decimals: 0,
                postfix: "%"
            })), u.createElement("div", {
                className: "hbox"
            }, u.createElement(G, {
                label: "R",
                value: a,
                decimals: 0
            }), u.createElement(G, {
                label: "G",
                value: n,
                decimals: 0
            }), u.createElement(G, {
                label: "B",
                value: o,
                decimals: 0
            }), u.createElement(G, {
                label: "A",
                value: l,
                decimals: 2
            })), u.createElement(At, {
                label: "CSS",
                value: h
            }))
        };
        class Dr {
            constructor() {
                if (this._canvas = document.createElement("canvas"), this._ctx = this._canvas.getContext("2d"), !this._ctx) throw new Error("Failed to get 2d context")
            }
            update(s, r, i, a) {
                var n = this._ctx,
                    o = a + 1;
                this._canvas.width = r * o, this._canvas.height = i * o, n.fillStyle = "#cccccc", n.fillRect(0, 0, this._canvas.width, this._canvas.height), n.fillStyle = "#ff0000", n.fillRect((r - 1) / 2 * o - 1, (i - 1) / 2 * o - 1, o + 1, o + 1);
                for (let t = 0; t < r; ++t)
                    for (let e = 0; e < i; ++e) {
                        const i = e * r * 4 + 4 * t,
                            l = m.I.rgb2hex(s[i], s[1 + i], s[2 + i]);
                        n.fillStyle = m.I.getCSSFromNumber(l), n.fillRect(t * o, this._canvas.height - (e + 1) * o, a, a)
                    }
                n.globalCompositeOperation = "destination-in", n.fillStyle = "#ffffff", n.beginPath(), n.arc(this._canvas.width / 2, this._canvas.height / 2, this._canvas.width / 2, 0, 2 * Math.PI, !0), n.closePath(), n.fill(), n.globalCompositeOperation = "source-over", n.strokeStyle = "#666666", n.beginPath(), n.arc(this._canvas.width / 2, this._canvas.height / 2, this._canvas.width / 2, 0, 2 * Math.PI, !0), n.closePath(), n.stroke()
            }
            get element() {
                return this._canvas
            }
        }
        const Or = e => {
            const t = (0, u.useRef)(null),
                s = (0, u.useRef)(new Dr),
                [r, i] = (0, u.useState)(re.K.create()),
                [a, n] = (0, u.useState)(re.K.create()),
                [o, l] = (0, u.useState)(),
                h = (0, u.useCallback)((e, t, s) => {
                    i(t), l(e), n(s)
                }, []);
            if ((0, u.useEffect)(() => {
                    t.current && t.current.appendChild(s.current.element), e.tool.signals.onMouseMove.add(h)
                }, []), o) {
                const u = 11,
                    t = 11,
                    i = r[0] - 5,
                    a = r[1] - 5,
                    n = v.O.readPixelsWebGL({
                        texture: o,
                        rect: [i, a, 11, 11]
                    }),
                    l = (s.current.update(n, 11, 11, 9), 240),
                    h = m.I.rgba2hex(n[240], n[241], n[242], n[243]);
                e.tool.updateColor(h)
            }
            return u.createElement("div", {
                className: "ColorPickerMagnifier",
                ref: t,
                style: {
                    display: o ? "initial" : "none",
                    transform: `translate(${a[0]}px, ${a[1]}px)`
                }
            })
        };
        class Br extends u.PureComponent {
            constructor(e) {
                super(e), this._tools = [new _r(this.props.renderer), new Er(this.props.renderer), new Ir(this.props.renderer, this.props.onChangeTexture), new Fr(this.props.renderer)], this.onActivateTool = t => {
                    var e = this._tools.find(e => e.id === this.state.activeTool),
                        e = (null != e && e.deactivate(), this._tools.find(e => e.id === t));
                    null != e && e.activate(), null != e && e.addExitListener(() => this.onResetTool()), this.setState({
                        activeTool: t
                    })
                }, this.onResetTool = () => {
                    var e = this._tools.find(e => e.id === this.state.activeTool);
                    null != e && e.deactivate(), this.setState({
                        activeTool: (null == (e = this._tools[0]) ? void 0 : e.id) || ""
                    })
                }, this.onKeyDown = e => {
                    var t = this._tools.find(e => e.id === this.state.activeTool);
                    return (null == t ? void 0 : t.onKeyDown(e)) || !1
                }, this.renderIcon = e => {}, this.state = {
                    activeTool: (null == (e = this._tools[0]) ? void 0 : e.id) || ""
                }
            }
            render() {
                var e = this._tools.find(e => e.id === this.state.activeTool);
                return u.createElement("div", {
                    className: "TextureToolsPanel"
                }, u.createElement(vr, {
                    options: this._tools.map(e => ({
                        id: e.id,
                        title: e.label,
                        iconUrl: `assets/ui/texture/tools/${e.id}.svg`,
                        render: this.renderIcon(e)
                    })),
                    selected: this.state.activeTool,
                    onChange: this.onActivateTool
                }), e instanceof Er && u.createElement(Cr, {
                    brush: e.brush
                }), e instanceof Ir && u.createElement(Pr, {
                    tool: e
                }), e instanceof Fr && u.createElement(u.Fragment, null, u.createElement(Lr, {
                    tool: e
                }), u.createElement(Or, {
                    tool: e
                })))
            }
        }
        class Ur extends u.Component {
            constructor(e) {
                super(e), this.onPopupClose = () => {
                    this.setState({
                        window: null,
                        props: null
                    }), this.props.keyboardListener.signals.down.remove(this.onKeyDown, this)
                }, this.state = {
                    window: null,
                    props: {}
                }
            }
            open(e, t) {
                this.setState({
                    window: e,
                    props: t
                }), this.props.keyboardListener.signals.down.add(this.onKeyDown, this)
            }
            onKeyDown(e) {
                e.keyCode === P.KEY_ESCAPE && (this.onEscapeKeyPressed(), e.preventDefault(), this.props.keyboardListener.signals.down.halt())
            }
            onEscapeKeyPressed() {
                this.onPopupClose()
            }
            render() {
                var e;
                
                return this.state.window ? (e = this.state.window, u.createElement(e, { ...this.state.props,
                    keyboardListener: this.props.keyboardListener,
                    onClose: this.onPopupClose
                })) : null
            }
        }
        class kr extends u.PureComponent {
            constructor(e) {
                super(e), this._contextMenu = null, this._mouseDownPos = [0, 0], this._mouseMoved = !1, this.onMouseDown = e => {
                    this._mouseDownPos = [e.screenX, e.screenY], this._mouseMoved = !1
                }, this.onMouseMove = e => {
                    e = [e.screenX, e.screenY];
                    2 < re.K.dist(this._mouseDownPos, e) && (this._mouseMoved = !0)
                }, this.onMouseUp = e => {
                    this._mouseMoved || 2 !== e.button || this._target && (e.preventDefault(), this.setState({
                        openedPosition: [e.pageX, e.pageY]
                    }))
                }, this.onMenuRef = e => {
                    e ? y.listen(e, this.onFocusLoss) : this._contextMenu && y.stopListen(this._contextMenu, this.onFocusLoss), this._contextMenu = e
                }, this.onFocusLoss = () => {
                    this.setState({
                        openedPosition: void 0
                    })
                }, this.onDomRef = e => {
                    e && (this._target = e, null != (e = this._target) && e.addEventListener("mousedown", this.onMouseDown), null != (e = this._target) && e.addEventListener("mousemove", this.onMouseMove), null != (e = this._target)) && e.addEventListener("mouseup", this.onMouseUp)
                }, this.onChildRef = e => {
                    var t;
                    e instanceof((null == (t = null == e ? void 0 : e.ownerDocument) ? void 0 : t.defaultView) || window).HTMLElement && this.onDomRef(e), "function" == typeof this._originalRef ? this._originalRef(e) : this._originalRef && (this._originalRef.current = e)
                }, this.state = {
                    openedPosition: void 0
                }
            }
            render() {
                var e = u.Children.only(this.props.children);
                return this._originalRef = null == e ? void 0 : e.ref, u.createElement(u.Fragment, null, u.cloneElement(e, { ..."string" == typeof e.type ? {} : {
                        domRef: this.onDomRef
                    },
                    ref: this.onChildRef
                }), this.state.openedPosition && u.createElement("div", {
                    ref: this.onMenuRef,
                    className: "ContextMenu",
                    style: {
                        position: "fixed",
                        top: this.state.openedPosition[1],
                        left: this.state.openedPosition[0]
                    }
                }, this.props.options.map((e, t) => "separator" == e.type ? u.createElement("div", {
                    key: t,
                    className: "separator"
                }) : u.createElement("div", {
                    key: t,
                    className: "item",
                    onClick: () => {
                        this.setState({
                            openedPosition: void 0
                        }), e.onSelect(e.id)
                    }
                }, e.label))))
            }
        }
        class zr {
            constructor(e) {
                this._id = e
            }
            get id() {
                return this._id
            }
        }
        class Vr extends zr {
            constructor(e) {
                super(e)
            }
            importFile(e, t, s) {
                this._file = e, this._onImageCreated = s;
                const r = new Image;
                this._image = r, t && (r.onload = () => {
                    t(r), this._image = void 0
                }), this._image.onerror = e => {
                    console.warn("Error loading image", e)
                }, this.readFile(e)
            }
            readFile(e) {
                const t = new FileReader;
                t.onload = () => {
                    this.parseBuffer(t.result)
                }, t.readAsArrayBuffer(e)
            }
            createImageData(e, t) {
                return this._canvas = this._canvas || document.createElement("canvas"), this._canvas.width = e, this._canvas.height = t, this._canvas.getContext("2d").createImageData(e, t)
            }
            completeImageData(e) {
                this._canvas.getContext("2d").putImageData(e, 0, 0), this.setImageSource(this._canvas.toDataURL())
            }
            setImageSource(e) {
                if (!this._image) throw new Error("Image not created");
                this._image.src = e, null != (e = this._onImageCreated) && e.call(this, this._image)
            }
        }
        class Gr extends Vr {
            constructor() {
                super("tif")
            }
            supportsFile(e) {
                return "image/tiff" === e.type || "image/x-tiff" === e.type
            }
            parseBuffer(e) {
                var e = V.decode(e)[0],
                    t = V.toRGBA8(e),
                    s = this.createImageData(e.width, e.height);
                for (let e = 0; e < t.length; ++e) s.data[e] = t[e];
                this.completeImageData(s)
            }
        }
        class Wr extends Vr {
            constructor() {
                super("tga")
            }
            supportsFile(e) {
                if ("" === e.type) {
                    var t = e.name.split("."),
                        t = t[t.length - 1].toUpperCase();
                    if ("TGA" === t || "ICB" === t || "VDA" === t || "VST" === t) return !0
                }
                return "image/x-tga" === e.type || "image/x-targa" === e.type
            }
            parseBuffer(r) {
                var r = new Uint8Array(r),
                    e = r[2];
                let t;
                if (2 === e) t = !1;
                else {
                    if (10 !== e) return void console.log("Unknown image format.");
                    t = !0
                }
                var e = r[16],
                    i = r[17];
                if (32 !== e && 24 !== e) console.log("Unknown image format.");
                else {
                    var i = 32 !== i,
                        a = 32 === e ? 4 : 3,
                        n = 255 & r[12] | (255 & r[13]) << 8,
                        o = 255 & r[14] | (255 & r[15]) << 8;
                    let s = r.slice(18);
                    var l = this.createImageData(n, o);
                    if (t) {
                        s = class {
                            static decodeRLEData(t, e, s, r) {
                                var i = r;
                                let a = 0,
                                    n = 0;
                                for (var o = i ? 4 : 3, l = e * s, h = []; a < l;) {
                                    var c = 255 & t[n];
                                    if (n++, c < 128) {
                                        var d = 1 + c;
                                        for (let e = 0; e < d; e++) h.push(t[n + 2]), h.push(t[n + 1]), h.push(t[n]), i && h.push(t[n + 3]), n += o, a++
                                    } else {
                                        c -= 127;
                                        for (let e = 0; e < c; e++) h.push(t[n + 2]), h.push(t[n + 1]), h.push(t[n]), i && h.push(t[n + 3]), a++;
                                        n += o
                                    }
                                }
                                var u = new Uint8Array(h.length);
                                for (let e = 0; e < u.length; ++e) u[e] = h[e];
                                return u
                            }
                        }.decodeRLEData(s, n, o, 32 === e);
                        const r = n * o * 4;
                        for (let e = 0, t = 0; e < r; e += 4) l.data[e + 0] = s[t++], l.data[e + 1] = s[t++], l.data[e + 2] = s[t++], 4 == a ? l.data[e + 3] = s[t++] : 3 == a && (l.data[e + 3] = 255)
                    } else {
                        const r = n * o * 4;
                        for (let e = 0, t = 0; e < r; e += 4) l.data[e + 2] = s[t++], l.data[e + 1] = s[t++], l.data[e + 0] = s[t++], 4 == a ? l.data[e + 3] = s[t++] : 3 == a && (l.data[e + 3] = 255)
                    }
                    i && ce.P.inst.flipDataArray(l.data, n, o), this.completeImageData(l)
                }
            }
        }
        class Hr extends Vr {
            constructor() {
                super("bmp")
            }
            supportsFile(e) {
                return "image/bmp" === e.type
            }
            parseBuffer(e) {
                if (!this._file) throw new Error("File not set");
                var t = new Uint8Array(e);
                if (32 === t[28]) {
                    const e = 255 & t[18] | (255 & t[19]) << 8 | (255 & t[20]) << 16 | (255 & t[21]) << 24,
                        i = 255 & t[22] | (255 & t[23]) << 8 | (255 & t[24]) << 16 | (255 & t[25]) << 24,
                        a = t.slice(54);
                    ce.P.inst.flipDataArray(a, e, i);
                    var s = this.createImageData(e, i),
                        r = e * i * 4;
                    for (let e = 0; e < r; e += 4) s.data[e] = a[e + 2], s.data[e + 1] = a[e + 1], s.data[e + 2] = a[e], s.data[e + 3] = a[e + 3];
                    this.completeImageData(s)
                } else this.setImageSource(URL.createObjectURL(this._file))
            }
        }
        class Yr extends Vr {
            constructor(e = "ico") {
                super(e), this._hotspot = [0, 0]
            }
            supportsFile(e) {
                return "image/x-icon" === e.type || "image/vnd.microsoft.icon" === e.type
            }
            parseBuffer(e) {
                if (!this._file) throw new Error("File not set");
                var t = new Uint8Array(e);
                let s = "unknown";
                s = 0 === t[38] && 0 === t[39] && 0 === t[40] && 0 === t[41] ? "bmp" : "png";
                const r = 255 & t[10] | (255 & t[11]) << 8,
                    i = 255 & t[12] | (255 & t[13]) << 8;
                if (this._hotspot[0] = r, this._hotspot[1] = i, "png" === s) {
                    const e = t.slice(22),
                        s = new File([e], this._file.name, {
                            type: "image/png",
                            lastModified: Date.now()
                        });
                    this.setImageSource(URL.createObjectURL(s))
                } else if ("bmp" === s) {
                    const e = "ico" === this._id ? i : 32,
                        s = 255 & t[26] | (255 & t[27]) << 8 | (255 & t[28]) << 16 | (255 & t[29]) << 24,
                        r = (255 & t[30] | (255 & t[31]) << 8 | (255 & t[32]) << 16 | (255 & t[33]) << 24) / 2,
                        a = this.createImageData(s, r),
                        n = 32 == e ? 4 : 3,
                        o = s * r * 4,
                        l = t.slice(62);
                    if (s * r * 4 > l.length) this.setImageSource(URL.createObjectURL(this._file));
                    else {
                        if (ce.P.inst.flipDataArray(l, s, r), 4 == n)
                            for (let e = 0; e < o; e += 4) a.data[e] = l[e + 2], a.data[e + 1] = l[e + 1], a.data[e + 2] = l[e], a.data[e + 3] = l[e + 3];
                        else {
                            let t = 0;
                            for (let e = 0; e < o; e += 4) a.data[e] = l[o - t + 2], a.data[e + 1] = l[o - t + 1], a.data[e + 2] = l[o - t + 0], a.data[e + 3] = 255, t += 3
                        }
                        this.completeImageData(a)
                    }
                }
            }
            get hotspot() {
                return this._hotspot
            }
        }
        class jr extends Yr {
            constructor() {
                super("cur")
            }
            supportsFile(e) {
                return "" === e.type && "CUR" === p.P.getExtension(e.name).toUpperCase() || "com.microsoft.cur" === e.type
            }
        }
        class Kr extends zr {
            constructor() {
                super("default")
            }
            supportsFile(e) {
                return !0
            }
            importFile(e, t, s) {
                const r = URL.createObjectURL(e),
                    i = new Image;
                i.src = r, s && s(i), t && (i.onload = () => {
                    t(i)
                })
            }
        }
        class qr {
            constructor() {
                this._list = [new Gr, new Wr, new Hr, new Yr, new jr, new Kr]
            }
            importFile(e, t) {
                for (const s of this._list)
                    if (s.supportsFile(e)) return void s.importFile(e, e => {
                        t(e, s)
                    });
                const s = this._list.find(e => "default" === e.id);
                if (!s) throw new Error("Default importer not found");
                s.importFile(e, e => {
                    t(e, s)
                })
            }
        }
        class $r extends u.PureComponent {
            constructor(e) {
                super(e), this._toolsPanel = u.createRef(), this._popups = u.createRef(), this._importers = new qr, this._contextOptions = [{
                    label: "Rotate 90 (CW)",
                    onSelect: () => {
                        this.state.texture && this.onChangeTexture(this.state.texture.rotate90(!0))
                    }
                }, {
                    label: "Rotate 90 (CCW)",
                    onSelect: () => {
                        this.state.texture && this.onChangeTexture(this.state.texture.rotate90(!1))
                    }
                }, {
                    type: "separator"
                }, {
                    label: "Flip horizontal",
                    onSelect: () => {
                        this.state.texture && this.onChangeTexture(this.state.texture.flip(!0))
                    }
                }, {
                    label: "Flip Vertical",
                    onSelect: () => {
                        this.state.texture && this.onChangeTexture(this.state.texture.flip(!1))
                    }
                }], this.onCanvasRef = t => {
                    if (t) {
                        this._document = t.ownerDocument;
                        const s = new ur(t);
                        if (s.navigation.signals.change.add(this.invalidate), this.props.source.blobUrl) {
                            const t = new Image;
                            t.src = this.props.source.blobUrl, t.onload = () => {
                                var e = new kt({
                                    adapter: s.adapter,
                                    source: t,
                                    file: void 0,
                                    transparent: !0,
                                    magFilter: _.g.NEAREST,
                                    name: this.props.source.name
                                });
                                e.updateStructure(), this.setState({
                                    texture: e
                                }), s.updateImage(e)
                            }
                        } else {
                            const t = new kt({
                                adapter: s.adapter,
                                source: null,
                                width: this.props.source.resolution[0],
                                height: this.props.source.resolution[1],
                                file: void 0,
                                transparent: !0,
                                magFilter: _.g.NEAREST,
                                name: this.props.source.name
                            });
                            t.updateStructure(), this.setState({
                                texture: t
                            }), s.updateImage(t)
                        }
                        this.props.keyboardListener.signals.down.add(this.onKeyDown, void 0, -1), this.setState({
                            renderer: s
                        })
                    }
                }, this.invalidate = () => {
                    this.forceUpdate()
                }, this.onKeyDown = e => {
                    var t;
                    null != (t = this._toolsPanel.current) && t.onKeyDown(e) || "Escape" === e.key && this.props.onClose()
                }, this.onChangeTexture = e => {
                    var t;
                    this.setState({
                        texture: e
                    }), null != (t = this.state.renderer) && t.updateImage(e)
                }, this.onSaveTexture = e => {
                    this.props.onSaveTexture(e)
                }, this.onClose = () => {
                    this.props.onClose()
                }, this.state = {
                    texture: void 0,
                    renderer: void 0
                }
            }
            get popups() {
                return this._popups.current
            }
            get document() {
                return this._document
            }
            get adapter() {
                var e;
                return null == (e = this.state.renderer) ? void 0 : e.adapter
            }
            get importers() {
                return this._importers
            }
            render() {
                return u.createElement("div", {
                    className: "TextureEditor"
                }, u.createElement(us, {
                    app: this.props.app,
                    editor: this,
                    texture: this.state.texture,
                    onChangeTexture: this.onChangeTexture,
                    onClose: this.onClose,
                    onSaveTexture: this.onSaveTexture
                }), u.createElement(mr, {
                    texture: this.state.texture,
                    renderer: this.state.renderer
                }), u.createElement("div", {
                    className: "hbox flex_1",
                    style: {
                        overflow: "hidden",
                        flexDirection: "row-reverse"
                    }
                }, u.createElement("div", {
                    className: "flex_1",
                    style: {
                        position: "relative"
                    }
                }, u.createElement(kr, {
                    options: this._contextOptions
                }, u.createElement("canvas", {
                    className: "canvas",
                    ref: this.onCanvasRef
                })), u.createElement("div", {
                    className: "scrollDiv"
                })), this.state.renderer && u.createElement(Br, {
                    renderer: this.state.renderer,
                    ref: this._toolsPanel,
                    onChangeTexture: this.onChangeTexture
                })), u.createElement(Ur, {
                    ref: this._popups,
                    keyboardListener: this.props.keyboardListener
                }))
            }
        }
        class Xr extends u.Component {
            constructor(e) {
                super(e), this._window = null, this._objectUrlNeedsRevoke = !1, this.onTextureLoaded = () => {
                    this.updateBlob()
                }, this.onEdit = () => {
                    var e = [null != (e = null == (e = this._texture) ? void 0 : e.image.width) ? e : 1024, null != (e = null == (e = this._texture) ? void 0 : e.image.height) ? e : 1024],
                        t = f.M.fitInto([Math.max(300, e[0] / window.devicePixelRatio), Math.max(300, e[1] / window.devicePixelRatio)], [screen.width, screen.height]),
                        s = {
                            name: (null == (s = this._texture) ? void 0 : s.image.name) || "Untitled",
                            blobUrl: this.state.blobUrl,
                            resolution: e
                        }; {
                        this._window && this._window.close();
                        const i = this._window = window.open("about:blank", "_blank", `width=${t[0]},height=${t[1]},popup=yes,toolbar=yes,menubar=yes,scrollbars=yes`);

                        function r() {
                            null != i && i.close()
                        }
                        i && (setTimeout(() => {
                            i.document.title = "Texture Editor"
                        }, 0), i.document.head.innerHTML = '<link href="css/main.css" rel="stylesheet" type="text/css">', (e = i.document.createElement("div")).style.width = "100%", e.style.height = "100%", i.document.body.appendChild(e), (0, te.s)(e).render(u.createElement($r, {
                            app: Y.inst,
                            source: s,
                            onSaveTexture: this.onSaveEditedTexture,
                            onClose: r,
                            keyboardListener: new P(i.document.body)
                        })), window.addEventListener("beforeunload", r))
                    }
                }, this.onSaveEditedTexture = e => {
                    var t = e.readPixels(!0, !0, !0);
                    this.changeTextureSource({
                        source: t,
                        width: e.width,
                        height: e.height
                    })
                }, this.onDownload = () => {
                    var e = this.state.blobUrl;
                    e && p.P.downloadFileFromUrl(e, this.getName())
                }, this.onUpload = () => {
                    p.P.openFileDialogue(!1, null, e => {
                        e = e.item(0);
                        e && this.changeTextureFile(e)
                    })
                }, this.onRemove = () => {
                    var e;
                    null != (e = this.props) && e.onTextureSourceChange(null)
                }, this.onDropFiles = async e => {
                    var t = null == (e = e.dataTransfer) ? void 0 : e.items;
                    if (t) {
                        const e = await (new Lt).load(t);
                        e[0] && this.changeTextureFile(e[0])
                    }
                }, this.onDroppingChange = e => {
                    this.setState({
                        dropping: e
                    })
                }, this.state = {
                    blobUrl: "",
                    dropping: !1
                }
            }
            updateBlob() {
                var e = this.props.texture;
                e ? e !== this._texture && (e.image.isLoaded() ? (this._texture = e, v.O.getPreviewUrl({
                    texture: e
                }, (e, t) => {
                    this.setBlobUrl(e, t)
                })) : e.image.signals.load.addOnce(this.onTextureLoaded)) : "" !== this.state.blobUrl && (this._objectUrlNeedsRevoke && (URL.revokeObjectURL(this.state.blobUrl), this._objectUrlNeedsRevoke = !1), this._texture = void 0, this.setBlobUrl(""))
            }
            setBlobUrl(e, t = !1) {
                setTimeout(() => {
                    this.setState({
                        blobUrl: e
                    }), this._objectUrlNeedsRevoke = t
                }, 0)
            }
            getName() {
                var e;
                return (null == (e = this.props.texture) ? void 0 : e.image.name) || ""
            }
            getTitle() {
                let e = "";
                var t;
                return this.props.texture && (t = this.props.texture, e = `${this.getName()} (${t.image.width}x${t.image.height}) - id: ` + t.id), e
            }
            changeTextureFile(e) {
                p.P.loadImageFile(e, e => {
                    this.changeTextureSource(e)
                })
            }
            changeTextureSource(e) {
                var t;
                this._texture = void 0, null != (t = this.props) && t.onTextureSourceChange(null), null != (t = this.props) && t.onTextureSourceChange(e)
            }
            render() {
                this.updateBlob();
                var e = `url('${this.state.blobUrl}')`,
                    t = this.getTitle();
                return u.createElement("div", {
                    className: "TextureInput"
                }, u.createElement(Ft, {
                    onDragOver: e => !0,
                    onDrop: this.onDropFiles,
                    onDroppingChange: this.onDroppingChange
                }, u.createElement("div", {
                    className: h("texture", {
                        dropping: this.state.dropping
                    }),
                    title: t,
                    onClick: this.onEdit
                }, this.props.texture && u.createElement("div", {
                    className: "checkerboard"
                }), u.createElement("div", {
                    className: "image",
                    style: {
                        backgroundImage: e
                    }
                }), u.createElement("div", {
                    className: "hover"
                }, u.createElement("div", {
                    className: "hoverLabel"
                }, this.props.texture ? "Edit" : "New")))), u.createElement(It, {
                    texture: this.props.texture,
                    onDownload: this.onDownload,
                    onUpload: this.onUpload,
                    onRemove: this.onRemove
                }))
            }
        }
        class Zr extends u.Component {
            constructor() {
                super(...arguments), this.onTextureScaleXChange = e => {
                    this.props.transform.sx = e, this.update()
                }, this.onTextureScaleYChange = e => {
                    this.props.transform.sy = e, this.update()
                }, this.onTextureTranslationXChange = e => {
                    this.props.transform.tx = e, this.update()
                }, this.onTextureTranslationYChange = e => {
                    this.props.transform.ty = e, this.update()
                }, this.onTextureRotationChange = e => {
                    this.props.transform.rotation = e * f.M.DEG2RAD, this.update()
                }
            }
            update() {
                Y.inst.invalidate(), this.forceUpdate()
            }
            render() {
                let e = [1, 1],
                    t = [0, 0],
                    s = 0,
                    r = this.props.transform;
                return r && (e = r.scale, t = r.translation, s = r.rotation * f.M.RAD2DEG), u.createElement("div", {
                    className: "TextureTransform"
                }, u.createElement("div", {
                    className: "hbox fullWidth"
                }, u.createElement(G, {
                    className: "scale",
                    label: "SX",
                    value: e[0],
                    step: 1e-4,
                    decimals: 4,
                    disabled: !r,
                    onChange: this.onTextureScaleXChange
                }), u.createElement(G, {
                    className: "scale",
                    label: "SY",
                    value: e[1],
                    step: 1e-4,
                    decimals: 4,
                    disabled: !r,
                    onChange: this.onTextureScaleYChange
                })), u.createElement(G, {
                    label: "TX",
                    value: t[0],
                    step: .01,
                    disabled: !r,
                    onChange: this.onTextureTranslationXChange
                }), u.createElement(G, {
                    label: "TY",
                    value: t[1],
                    step: .01,
                    disabled: !r,
                    onChange: this.onTextureTranslationYChange
                }), u.createElement(G, {
                    label: "R",
                    value: s,
                    decimals: 0,
                    step: 1,
                    postfix: "",
                    disabled: !r,
                    onChange: this.onTextureRotationChange
                }))
            }
        }
        class Jr extends u.Component {
            constructor(e) {
                super(e), this._wrapOptions = [{
                    label: "CLAMP_TO_EDGE",
                    value: _.g.CLAMP_TO_EDGE
                }, {
                    label: "REPEAT",
                    value: _.g.REPEAT
                }, {
                    label: "MIRRORED_REPEAT",
                    value: _.g.MIRRORED_REPEAT
                }], this._minFilterOptions = [{
                    label: "LINEAR",
                    value: _.g.LINEAR
                }, {
                    label: "NEAREST",
                    value: _.g.NEAREST
                }, {
                    label: "NEAREST_MIPMAP_NEAREST",
                    value: _.g.NEAREST_MIPMAP_NEAREST
                }, {
                    label: "LINEAR_MIPMAP_NEAREST",
                    value: _.g.LINEAR_MIPMAP_NEAREST
                }, {
                    label: "NEAREST_MIPMAP_LINEAR",
                    value: _.g.NEAREST_MIPMAP_LINEAR
                }, {
                    label: "LINEAR_MIPMAP_LINEAR",
                    value: _.g.LINEAR_MIPMAP_LINEAR
                }], this._magFilterOptions = [{
                    label: "LINEAR",
                    value: _.g.LINEAR
                }, {
                    label: "NEAREST",
                    value: _.g.NEAREST
                }], this.onChangeWrapS = e => {
                    this.props.texture.texture && (this.props.texture.texture.sampler.wrapS = e.value, this.update())
                }, this.onChangeWrapT = e => {
                    this.props.texture.texture && (this.props.texture.texture.sampler.wrapT = e.value, this.update())
                }, this.onChangeMinFilter = e => {
                    this.props.texture.texture && (this.props.texture.texture.sampler.minFilter = e.value, this.update())
                }, this.onChangeMagFilter = e => {
                    this.props.texture.texture && (this.props.texture.texture.sampler.magFilter = e.value, this.update())
                }
            }
            update() {
                Y.inst.invalidate(), this.forceUpdate()
            }
            render() {
                var e = null == (e = this.props.texture) ? void 0 : e.texture;
                let t = _.g.CLAMP_TO_EDGE,
                    s = _.g.CLAMP_TO_EDGE,
                    r = (e && (t = e.sampler.wrapS, s = e.sampler.wrapT), _.g.NEAREST_MIPMAP_LINEAR),
                    i = _.g.LINEAR;
                e && (i = e.sampler.magFilter, r = e.sampler.minFilter);
                var a = this._wrapOptions;
                return u.createElement("div", {
                    className: h("TextureInfo", {
                        disabled: !e
                    })
                }, u.createElement(k, {
                    label: "S: "
                }, u.createElement(F, {
                    options: a,
                    render: F.renderLabel,
                    disabled: !e,
                    selected: a.find(e => e.value === t),
                    onChange: this.onChangeWrapS
                })), u.createElement(k, {
                    label: "T: "
                }, u.createElement(F, {
                    options: a,
                    render: F.renderLabel,
                    disabled: !e,
                    selected: a.find(e => e.value === s),
                    onChange: this.onChangeWrapT
                })), u.createElement(k, {
                    label: "Min: "
                }, u.createElement(F, {
                    options: this._minFilterOptions,
                    render: F.renderLabel,
                    disabled: !e,
                    selected: this._minFilterOptions.find(e => e.value === r),
                    onChange: this.onChangeMinFilter
                })), u.createElement(k, {
                    label: "Mag: "
                }, u.createElement(F, {
                    options: this._magFilterOptions,
                    render: F.renderLabel,
                    disabled: !e,
                    selected: this._magFilterOptions.find(e => e.value === i),
                    onChange: this.onChangeMagFilter
                })), u.createElement(Zr, {
                    transform: this.props.texture.transform
                }))
            }
        }
        class Qr extends u.Component {
            render() {
                var {
                    channel: e,
                    availableChannels: t,
                    disabled: s,
                    onChange: r
                } = this.props;
                return u.createElement(k, {
                    label: "Channel",
                    className: "TextureChannel"
                }, u.createElement(F, {
                    options: t,
                    disabled: s,
                    selected: e,
                    onChange: r
                }))
            }
        }
        class ei extends u.Component {
            constructor(e) {
                super(e), this.onHeaderClick = () => {
                    this.toggle()
                }, this.onTextureChange = e => {
                    this.props.texture.texture ? e ? (0, v.JZ)(e) ? this.props.texture.texture.image.setMediaSource(e) : this.props.texture.texture.image.setDataSource(e.source, e.width, e.height) : this.props.texture.texture = void 0 : (0, v.JZ)(e) ? this.props.texture.texture = e ? new X.x(new X.c(e)) : void 0 : this.props.texture.texture = e ? X.x.from({
                        source: e.source,
                        width: e.width,
                        height: e.height
                    }) : void 0, Y.inst.invalidate(), this.forceUpdate()
                }, this.onChannelChange = e => {
                    this.props.texture.channel = e, Y.inst.invalidate(), this.forceUpdate()
                }, this.state = {
                    collapsed: !e.texture.texture,
                    prevTexture: e.texture.texture
                }
            }
            toggle() {
                this.setState(e => ({
                    collapsed: !e.collapsed
                }))
            }
            render() {
                var e, {
                        texture: t,
                        children: s,
                        label: r
                    } = this.props,
                    i = this.state["collapsed"];
                return u.createElement("div", {
                    className: h("TexturePanel vbox " + (null != (e = this.props.cls) ? e : ""), {
                        collapsed: i
                    })
                }, u.createElement("div", {
                    className: "header",
                    onClick: this.onHeaderClick
                }, u.createElement("span", {
                    className: "toggle"
                }), u.createElement("span", null, r)), u.createElement("div", {
                    className: "hbox body",
                    style: {
                        height: i ? "0" : ""
                    }
                }, u.createElement("div", {
                    className: "flex_1"
                }, u.createElement(Xr, {
                    texture: t.texture,
                    onTextureSourceChange: this.onTextureChange
                })), u.createElement("div", {
                    className: "custom"
                }, u.createElement(Jr, {
                    texture: t
                }), u.createElement(Qr, {
                    channel: t.channel,
                    availableChannels: this.props.availableChannels,
                    disabled: !t.texture,
                    onChange: this.onChannelChange
                }), s)))
            }
        }
        class ti extends u.Component {
            constructor() {
                super(...arguments), this.onBaseColorFactorChange = e => {
                    this.material.baseColorFactor = e, this.update()
                }, this.onSheenColorFactorChange = e => {
                    this.material.sheenColorFactor = e, this.update()
                }, this.onSpecularColorFactorChange = e => {
                    this.material.specularColorFactor = e, this.update()
                }, this.onBaseColorAlphaChange = e => {
                    this.material.baseColorAlpha = e, this.update()
                }, this.onMetallicFactorChange = e => {
                    this.material.metallicFactor = e, this.update()
                }, this.onRoughnessFactorChange = e => {
                    this.material.roughnessFactor = e, this.update()
                }, this.onNormalScaleChange = e => {
                    this.material.normalScale = e, this.update()
                }, this.onClearcoatNormalScaleChange = e => {
                    this.material.clearcoatNormalScale = e, this.update()
                }, this.onOcclusionStrengthChange = e => {
                    this.material.occlusionStrength = e, this.update()
                }, this.onEmissiveFactorChange = e => {
                    this.material.emissiveFactor = e, this.update()
                }, this.onEmissiveStrengthChange = e => {
                    this.material.emissiveStrength = e, this.update()
                }, this.onTransmissionFactorChange = e => {
                    this.material.transmissionFactor = e, this.update()
                }, this.onSpecularFactorChange = e => {
                    this.material.specularFactor = e, this.update()
                }, this.onSheenRoughnessFactorChange = e => {
                    this.material.sheenRoughnessFactor = e, this.update()
                }, this.onClearCoatFactorChange = e => {
                    this.material.clearcoatFactor = e, this.update()
                }, this.onClearCoatRoughnessFactorChange = e => {
                    this.material.clearcoatRoughnessFactor = e, this.update()
                }, this.onThicknessFactorChange = e => {
                    this.material.thicknessFactor = e, this.update()
                }, this.onAnisotropyStrengthChange = e => {
                    this.material.anisotropyStrength = e, this.update()
                }, this.onAnisotropyRotationChange = e => {
                    this.material.anisotropyRotation = e, this.update()
                }, this.onAttenuationColorChange = e => {
                    this.material.attenuationColor = e, this.update()
                }, this.onAttenuationDistanceChange = e => {
                    this.material.attenuationDistance = e, this.update()
                }
            }
            get material() {
                return this.props.renderNode.material
            }
            update() {
                Y.inst.invalidate(), this.forceUpdate()
            }
            render() {
                var e = this.props.renderNode,
                    t = this.material,
                    e = e.geometry.getUVChannels();
                return u.createElement("div", null, u.createElement(ei, {
                    label: "Base",
                    texture: t.baseColorTextureInfo,
                    availableChannels: e
                }, u.createElement(k, {
                    label: "Color"
                }, u.createElement(Nt, {
                    value: t.baseColorFactor,
                    onChange: this.onBaseColorFactorChange
                })), u.createElement(G, {
                    label: "Alpha",
                    value: t.baseColorAlpha,
                    min: 0,
                    step: .01,
                    onChange: this.onBaseColorAlphaChange
                })), u.createElement(ei, {
                    label: "Metallic Roughness",
                    texture: t.metallicRoughnessTextureInfo,
                    availableChannels: e
                }, u.createElement(G, {
                    label: "Metal",
                    value: t.metallicFactor,
                    min: 0,
                    max: 1,
                    step: .01,
                    onChange: this.onMetallicFactorChange
                }), u.createElement(G, {
                    label: "Rough",
                    value: t.roughnessFactor,
                    min: 0,
                    max: 1,
                    step: .01,
                    onChange: this.onRoughnessFactorChange
                })), u.createElement(ei, {
                    label: "Normal",
                    texture: t.normalTextureInfo,
                    availableChannels: e
                }, u.createElement(G, {
                    label: "Scale",
                    value: t.normalScale,
                    step: .01,
                    onChange: this.onNormalScaleChange
                })), u.createElement(ei, {
                    label: "Occlusion",
                    texture: t.occlusionTextureInfo,
                    availableChannels: e
                }, u.createElement(G, {
                    label: "Str",
                    value: t.occlusionStrength,
                    min: 0,
                    step: .01,
                    onChange: this.onOcclusionStrengthChange
                })), u.createElement(ei, {
                    label: "Emissive",
                    texture: t.emissiveTextureInfo,
                    availableChannels: e
                }, u.createElement(k, {
                    label: "Factor "
                }, u.createElement(Nt, {
                    value: t.emissiveFactor,
                    onChange: this.onEmissiveFactorChange
                })), u.createElement(G, {
                    label: "Str:",
                    title: "Strength",
                    value: t.emissiveStrength,
                    step: .01,
                    min: 0,
                    onChange: this.onEmissiveStrengthChange
                })), u.createElement(ei, {
                    label: "Transmission",
                    texture: t.transmissionTextureInfo,
                    availableChannels: e
                }, u.createElement(G, {
                    label: "Factor ",
                    title: "Factor",
                    value: t.transmissionFactor,
                    step: .01,
                    min: 0,
                    max: 1,
                    onChange: this.onTransmissionFactorChange
                })), u.createElement(ei, {
                    label: "Specular",
                    texture: t.specularTextureInfo,
                    availableChannels: e
                }, u.createElement(G, {
                    label: "Factor",
                    title: "Factor",
                    value: t.specularFactor,
                    step: .01,
                    min: 0,
                    max: 1,
                    onChange: this.onSpecularFactorChange
                })), u.createElement(ei, {
                    label: "Specular Color",
                    texture: t.specularColorTextureInfo,
                    availableChannels: e
                }, u.createElement(k, {
                    label: "Factor "
                }, u.createElement(Nt, {
                    value: t.specularColorFactor,
                    onChange: this.onSpecularColorFactorChange
                }))), u.createElement(ei, {
                    label: "Sheen Color",
                    texture: t.sheenColorTextureInfo,
                    availableChannels: e
                }, u.createElement(k, {
                    label: "Color"
                }, u.createElement(Nt, {
                    value: t.sheenColorFactor,
                    onChange: this.onSheenColorFactorChange
                }))), u.createElement(ei, {
                    label: "Sheen Roughness",
                    texture: t.sheenRoughnessTextureInfo,
                    availableChannels: e
                }, u.createElement(G, {
                    label: "Factor",
                    value: t.sheenRoughnessFactor,
                    min: 0,
                    step: .01,
                    onChange: this.onSheenRoughnessFactorChange
                })), u.createElement(ei, {
                    label: "ClearCoat",
                    texture: t.clearcoatTextureInfo,
                    availableChannels: e
                }, u.createElement(G, {
                    label: "Factor",
                    value: t.clearcoatFactor,
                    min: 0,
                    step: .01,
                    onChange: this.onClearCoatFactorChange
                })), u.createElement(ei, {
                    label: "ClearCoat Roughness",
                    texture: t.clearcoatRoughnessTextureInfo,
                    availableChannels: e
                }, u.createElement(G, {
                    label: "Factor",
                    value: t.clearcoatRoughnessFactor,
                    min: 0,
                    step: .01,
                    onChange: this.onClearCoatRoughnessFactorChange
                })), u.createElement(ei, {
                    label: "ClearCoat Normal",
                    texture: t.clearcoatNormalTextureInfo,
                    availableChannels: e
                }, u.createElement(G, {
                    label: "Scale",
                    value: t.clearcoatNormalScale,
                    step: .01,
                    onChange: this.onClearcoatNormalScaleChange
                })), u.createElement(ei, {
                    label: "Volume",
                    texture: t.thicknessTextureInfo,
                    availableChannels: e,
                    cls: "tall"
                }, u.createElement(G, {
                    label: "Factor ",
                    title: "Thickness Factor",
                    value: t.thicknessFactor,
                    step: .01,
                    min: 0,
                    max: 1,
                    onChange: this.onThicknessFactorChange
                }), u.createElement("div", {
                    className: "attenuation"
                }, u.createElement("label", null, "Attenuation: "), u.createElement("div", {
                    className: "inputs"
                }, u.createElement(Nt, {
                    title: "Attenuation Color",
                    value: t.attenuationColor,
                    onChange: this.onAttenuationColorChange
                }), u.createElement(G, {
                    label: "Dist",
                    title: " Attenutation Distance",
                    value: t.attenuationDistance,
                    onChange: this.onAttenuationDistanceChange
                })))), u.createElement(ei, {
                    label: "Anisotropy",
                    texture: t.anisotropyTextureInfo,
                    availableChannels: e,
                    cls: "tall"
                }, u.createElement(G, {
                    label: "Str:",
                    title: "Strength",
                    value: t.anisotropyStrength,
                    step: .01,
                    min: 0,
                    max: 1,
                    onChange: this.onAnisotropyStrengthChange
                }), u.createElement(G, {
                    label: "Rotation ",
                    title: "Rotation",
                    value: t.anisotropyRotation,
                    step: .01,
                    min: 0,
                    max: 3.15,
                    onChange: this.onAnisotropyRotationChange
                })))
            }
        }
        class si extends u.Component {
            constructor() {
                super(...arguments), this.onBaseColorFactorChange = e => {
                    this.material.baseColorFactor = e, this.update()
                }, this.onBaseColorAlphaChange = e => {
                    this.material.baseColorAlpha = e, this.update()
                }
            }
            update() {
                Y.inst.invalidate(), this.forceUpdate()
            }
            get material() {
                return this.props.renderNode.material
            }
            render() {
                var e = this.props.renderNode,
                    t = this.material,
                    e = e.geometry.getUVChannels();
                return u.createElement("div", null, u.createElement(ei, {
                    label: "Base",
                    texture: t.baseColorTextureInfo,
                    availableChannels: e
                }, u.createElement(k, {
                    label: "Color"
                }, u.createElement(Nt, {
                    value: t.baseColorFactor,
                    onChange: this.onBaseColorFactorChange
                })), u.createElement(G, {
                    label: "Alpha",
                    value: t.baseColorAlpha,
                    min: 0,
                    step: .01,
                    onChange: this.onBaseColorAlphaChange
                })))
            }
        }
        class ri extends u.Component {
            constructor(e) {
                super(e), this._materialOptions = [{
                    label: "PBR Metallic Roughness",
                    materialClass: o.q,
                    panel: ti
                }, {
                    label: "Unlit",
                    materialClass: ve.z,
                    panel: si
                }], this._materialCache = new Map, this._lastNormalColor = 16711680, this.onDoubleSidedChange = e => {
                    var t = this.getMaterial();
                    t && (t.side = e ? fe.N.DOUBLE : fe.N.FRONT, this.update())
                }, this.onWireframeChange = e => {
                    var t = this.getMaterial();
                    t && (t.wireframe = e, this.update())
                }, this.onAlphaModeChange = e => {
                    var t = this.getMaterial();
                    null !== e && t && (t.alphaMode = e, this.update())
                }, this.onAlphaCutoffChange = e => {
                    var t = this.getMaterial();
                    t && (t.alphaCutoff = e, this.update())
                }, this.onIORChange = e => {
                    var t = this.getMaterial();
                    t && (t.ior = e, this.update())
                }, this.onMaterialChange = t => {
                    var s = this.props.node;
                    if (s && null !== t) {
                        this.saveMaterialToCache(s);
                        let e = this.getCachedMaterial(s, t.materialClass);
                        e = e || this.createMaterial(t.materialClass, s.material), s.setMaterial(e)
                    }
                    this.update()
                }, this.onChangeNormal = e => {
                    e = Y.inst.engine.debugTools.toggleVertexNormals(this.props.node, e);
                    e && (void 0 !== this._lastNormalScale && (e.scale = this._lastNormalScale), e.color = this._lastNormalColor), this.update()
                }, this.onChangeMaterialName = e => {
                    this.props.node.material.name = e, this.forceUpdate()
                }, this.onDuplicateMaterialClick = () => {
                    var e = this.props.node;
                    e.setMaterial(e.material.clone()), this.forceUpdate()
                }
            }
            getPanel(e) {
                var t = this.getOption(e.material).panel;
                return u.createElement(t, {
                    renderNode: e
                })
            }
            getOption(t) {
                return this._materialOptions.filter(e => e.materialClass === t.constructor)[0]
            }
            createMaterial(e, t) {
                return t instanceof o.q && e === ve.z ? new ve.z({
                    baseColorTexture: t.baseColorTextureInfo,
                    baseColorFactor: t.baseColorFactor,
                    baseColorAlpha: t.baseColorAlpha,
                    baseColorTextureChannel: t.baseColorTextureInfo.channel
                }) : t instanceof ve.z && e === o.q ? new o.q({
                    baseColorTexture: t.baseColorTextureInfo,
                    baseColorFactor: t.baseColorFactor,
                    baseColorAlpha: t.baseColorAlpha
                }) : new e
            }
            saveMaterialToCache(e) {
                return this.getMapForMaterial(e).set(e.material.constructor, e.material)
            }
            getCachedMaterial(e, t) {
                return this.getMapForMaterial(e).get(t)
            }
            getMapForMaterial(e) {
                let t = this._materialCache.get(e);
                return t || (t = new Map, this._materialCache.set(e, t)), t
            }
            getMaterial() {
                return this.props.node.material
            }
            renderNormalDebugger() {
                const e = Y.inst.engine.debugTools,
                    t = this.props["node"],
                    s = e.getVertexNormalRenderer(t);
                s && (this._lastNormalScale = s.scale, this._lastNormalColor = s.color);
                var r = e.isVertexNormalRendererSupported(t);
                return u.createElement("div", {
                    className: "normalSection"
                }, u.createElement(k, {
                    label: "Normal"
                }, u.createElement(U, {
                    value: !!s && r,
                    enabled: r,
                    onChange: this.onChangeNormal
                })), u.createElement("div", {
                    style: {
                        width: 20
                    }
                }), u.createElement(G, {
                    label: "Scale",
                    className: "normalScale",
                    value: s ? s.scale : this._lastNormalScale,
                    onChange: e => {
                        s && (s.scale = e, this.update())
                    },
                    disabled: !s,
                    step: .001,
                    decimals: 3
                }), u.createElement(Nt, {
                    value: s ? s.color : this._lastNormalColor,
                    onChange: e => {
                        s && (s.color = e, this.update())
                    },
                    disabled: !s
                }))
            }
            update() {
                Y.inst.invalidate(), this.forceUpdate()
            }
            render() {
                var e = this.props.node,
                    t = e.material;
                return t ? (e = this.getPanel(e), u.createElement("div", {
                    className: "MaterialPanel"
                }, u.createElement("div", {
                    className: "header"
                }, u.createElement(At, {
                    label: "Name",
                    value: t.name,
                    onInput: this.onChangeMaterialName,
                    className: "nameField"
                }), u.createElement(k, {
                    label: "ID:"
                }, u.createElement(At, {
                    placeholder: "ID",
                    value: t.id.toString(),
                    disabled: !0
                }), u.createElement("span", {
                    title: "Duplicate material",
                    className: "duplicateMaterial",
                    onClick: this.onDuplicateMaterialClick
                })), u.createElement(k, {
                    label: "Double sided"
                }, u.createElement(U, {
                    value: t.doubleSided,
                    onChange: this.onDoubleSidedChange
                })), u.createElement(k, {
                    label: "Wireframe"
                }, u.createElement(U, {
                    value: t.wireframe,
                    onChange: this.onWireframeChange
                })), this.renderNormalDebugger(), u.createElement(k, {
                    label: "Alpha mode: "
                }, u.createElement(F, {
                    options: pe.B.values2array(_e.mM),
                    selected: t.alphaMode,
                    onChange: this.onAlphaModeChange
                })), u.createElement(G, {
                    label: "Alpha cutoff: ",
                    value: t.alphaCutoff,
                    onChange: this.onAlphaCutoffChange,
                    min: 0,
                    step: .01,
                    disabled: t.alphaMode !== _e.mM.MASK
                }), u.createElement(G, {
                    label: "IOR: ",
                    title: "Index Of Refraction",
                    value: t.ior,
                    onChange: this.onIORChange,
                    min: 0,
                    step: .01
                }), u.createElement(k, {
                    label: "Type: "
                }, u.createElement(F, {
                    selected: this.getOption(t),
                    options: this._materialOptions,
                    onChange: this.onMaterialChange,
                    render: e => e.label
                }))), u.createElement("br", null), e)) : u.createElement("div", null)
            }
        }
        class ii extends u.Component {
            constructor(e) {
                super(e), this.onHeaderClick = () => {
                    this.toggle()
                }, this.onDeleteClick = e => {
                    var t;
                    e.stopPropagation(), null != (t = (e = this.props).onDelete) && t.call(e)
                }, this.state = {
                    collapsed: e.collapsed || !1
                }
            }
            toggle() {
                this.setState(e => ({
                    collapsed: !e.collapsed
                }))
            }
            render() {
                var {
                    children: e,
                    label: t,
                    onDelete: s
                } = this.props, r = this.state["collapsed"];
                return u.createElement("div", {
                    className: h("TogglePanel vbox", {
                        collapsed: r
                    })
                }, u.createElement("div", {
                    className: "header",
                    onClick: this.onHeaderClick
                }, u.createElement("span", {
                    className: "toggle"
                }), u.createElement("span", null, t), s && u.createElement("div", {
                    onClick: this.onDeleteClick,
                    className: "btn remove",
                    title: "Remove"
                })), u.createElement("div", {
                    className: "vbox body",
                    style: {
                        height: r ? "0" : ""
                    }
                }, e))
            }
        }
        class ai extends u.PureComponent {
            constructor() {
                super(...arguments), this.onClick = e => {
                    this.props.onChange && this.props.onChange(this.props.value)
                }
            }
            render() {
                var e = h({
                    button: !0,
                    [this.props.selectedClassName || "selected"]: this.props.value,
                    disabled: this.props.disabled
                });
                return u.createElement("div", {
                    className: e,
                    onClick: this.onClick
                }, this.props.label)
            }
        }
        ai.defaultProps = {
            disabled: !1
        };
        var Ee = c(9959);
        class ni extends u.Component {
            constructor(e) {
                super(e), this._transformDirtyCount = 0, this._globalTransform = new Ee.j, this.onAnimationChange = () => {
                    this._transformDirtyCount < this.props.node.transform.dirty && (this._transformDirtyCount = this.props.node.transform.dirty, this.forceUpdate())
                }, this.onChangeX = e => {
                    this.state.local ? this.props.node.transform.translation.x = e : (this._globalTransform.translation.x = e, this.props.node.transform.translation.x = this.convertToLocalTranslation()[0]), this.update()
                }, this.onChangeY = e => {
                    this.state.local ? this.props.node.transform.translation.y = e : (this._globalTransform.translation.y = e, this.props.node.transform.translation.y = this.convertToLocalTranslation()[1]), this.update()
                }, this.onChangeZ = e => {
                    this.state.local ? this.props.node.transform.translation.z = e : (this._globalTransform.translation.z = e, this.props.node.transform.translation.z = this.convertToLocalTranslation()[2]), this.update()
                }, this.onChangeRotationX = e => {
                    this.state.local ? this.props.node.transform.setEuler(e * f.M.DEG2RAD, void 0, void 0) : (this._globalTransform.setEuler(e * f.M.DEG2RAD, void 0, void 0), this.props.node.transform.setEuler(this.convertToLocalEulerRadians()[0], void 0, void 0)), this.update()
                }, this.onChangeRotationY = e => {
                    this.state.local ? this.props.node.transform.setEuler(void 0, e * f.M.DEG2RAD, void 0) : (this._globalTransform.setEuler(void 0, e * f.M.DEG2RAD, void 0), this.props.node.transform.setEuler(void 0, this.convertToLocalEulerRadians()[1], void 0)), this.update()
                }, this.onChangeRotationZ = e => {
                    this.state.local ? this.props.node.transform.setEuler(void 0, void 0, e * f.M.DEG2RAD) : (this._globalTransform.setEuler(void 0, void 0, e * f.M.DEG2RAD), this.props.node.transform.setEuler(void 0, void 0, this.convertToLocalEulerRadians()[2])), this.update()
                }, this.onChangeScaleX = e => {
                    this.state.local ? this.props.node.transform.scale.x = e : (this._globalTransform.scale.x = e, this.props.node.transform.scale.x = this.convertToLocalScale()[0]), this.update()
                }, this.onChangeScaleY = e => {
                    this.state.local ? this.props.node.transform.scale.y = e : (this._globalTransform.scale.y = e, this.props.node.transform.scale.y = this.convertToLocalScale()[1]), this.update()
                }, this.onChangeScaleZ = e => {
                    this.state.local ? this.props.node.transform.scale.z = e : (this._globalTransform.scale.z = e, this.props.node.transform.scale.z = this.convertToLocalScale()[2]), this.update()
                }, this.onSwitchToLocalClick = () => {
                    this.setState({
                        local: !0
                    })
                }, this.onSwitchToGlobalClick = () => {
                    this.setState({
                        local: !1
                    })
                }, this.state = {
                    local: !0
                }, null != (e = Y.inst.project.animationEngine) && e.signals.change.add(this.onAnimationChange)
            }
            convertToLocalTranslation() {
                var e = E.x.matrix_world2local(this._globalTransform.mat, this.props.node);
                return S._.getTranslation(M.R.create(), e)
            }
            convertToLocalEulerRadians() {
                var e = E.x.matrix_world2local(this._globalTransform.mat, this.props.node),
                    e = S._.getRotation(Te.g.create(), e);
                return Te.g.toEuler(M.R.create(), e)
            }
            convertToLocalScale() {
                var e = E.x.matrix_world2local(this._globalTransform.mat, this.props.node);
                return S._.getScaling(M.R.create(), e)
            }
            update() {
                Y.inst.invalidate(), this.forceUpdate()
            }
            render() {
                var e = this.props["node"],
                    t = this.state["local"];
                let s = this.props.node.transform;
                t || (s = this._globalTransform).setFromMatrix(e.calculateWorldMatrix());
                e = Te.g.toEulerDegrees(M.R.create(), s.rotation.vec);
                return u.createElement(ii, {
                    label: "Transform"
                }, u.createElement("div", {
                    className: "TransformPanel"
                }, u.createElement("div", {
                    className: "hbox flexEnd"
                }, u.createElement(ai, {
                    label: "Local",
                    value: t,
                    onChange: this.onSwitchToLocalClick
                }), u.createElement(ai, {
                    label: "Global",
                    value: !t,
                    onChange: this.onSwitchToGlobalClick
                })), u.createElement("div", {
                    className: "block"
                }, u.createElement("label", null, "Translation"), u.createElement("div", {
                    className: "props"
                }, u.createElement(G, {
                    label: "X",
                    value: s.translation.x,
                    decimals: 3,
                    step: .01,
                    onChange: this.onChangeX
                }), u.createElement(G, {
                    label: "Y",
                    value: s.translation.y,
                    decimals: 3,
                    step: .01,
                    onChange: this.onChangeY
                }), u.createElement(G, {
                    label: "Z",
                    value: s.translation.z,
                    decimals: 3,
                    step: .01,
                    onChange: this.onChangeZ
                }))), u.createElement("div", {
                    className: "block"
                }, u.createElement("label", null, "Rotation"), u.createElement("div", {
                    className: "props"
                }, u.createElement(G, {
                    label: "X",
                    postfix: "",
                    value: e[0],
                    step: 1,
                    decimals: 0,
                    shiftRound: 5,
                    onChange: this.onChangeRotationX
                }), u.createElement(G, {
                    label: "Y",
                    postfix: "",
                    value: e[1],
                    step: 1,
                    decimals: 0,
                    shiftRound: 5,
                    onChange: this.onChangeRotationY
                }), u.createElement(G, {
                    label: "Z",
                    postfix: "",
                    value: e[2],
                    step: 1,
                    decimals: 0,
                    shiftRound: 5,
                    onChange: this.onChangeRotationZ
                }))), u.createElement("div", {
                    className: "block"
                }, u.createElement("label", null, "Scale"), u.createElement("div", {
                    className: "props"
                }, u.createElement(G, {
                    label: "X",
                    value: s.scale.x,
                    step: .001,
                    decimals: 3,
                    onChange: this.onChangeScaleX
                }), u.createElement(G, {
                    label: "Y",
                    value: s.scale.y,
                    step: .001,
                    decimals: 3,
                    onChange: this.onChangeScaleY
                }), u.createElement(G, {
                    label: "Z",
                    value: s.scale.z,
                    step: .001,
                    decimals: 3,
                    onChange: this.onChangeScaleZ
                })))))
            }
        }
        var Ce = c(4375),
            ye = c(8244);
        class oi extends u.Component {
            render() {
                let e = this.props.value.toString();
                return this.props.decimals && 0 < this.props.decimals && (e = this.props.value.toFixed(this.props.decimals) || ""), u.createElement("span", null, e)
            }
        }
        oi.defaultProps = {
            value: 0,
            decimals: 2
        };
        class li extends u.Component {
            constructor() {
                super(...arguments), this.onNearChange = e => {
                    this.props.camera.near = e, this.update()
                }, this.onFarChange = e => {
                    this.props.camera.far = e, this.update()
                }, this.onFovYChange = e => {
                    this.props.camera.fovY = e * f.M.DEG2RAD, this.update()
                }
            }
            update() {
                Y.inst.invalidate(), this.forceUpdate()
            }
            render() {
                var e = this.props.camera;
                return u.createElement("div", {
                    className: "cameraPanel"
                }, u.createElement(G, {
                    label: "Near",
                    value: e.near,
                    min: 0,
                    decimals: 5,
                    step: .01,
                    onChange: this.onNearChange
                }), u.createElement(G, {
                    label: "Far",
                    value: e.far,
                    min: 0,
                    step: 100,
                    onChange: this.onFarChange
                }), u.createElement(G, {
                    label: "Fov (vertical)",
                    value: e.fovY * f.M.RAD2DEG,
                    step: 1,
                    onChange: this.onFovYChange
                }), u.createElement("div", null, u.createElement("label", null, "Viewport: "), u.createElement(oi, {
                    decimals: 0,
                    value: e.viewportWidth
                }), u.createElement("span", null, " x "), u.createElement(oi, {
                    decimals: 0,
                    value: e.viewportHeight
                })), u.createElement(k, {
                    label: "Aspect: "
                }, u.createElement(oi, {
                    value: e.aspect
                })))
            }
        }
        class hi extends u.Component {
            constructor() {
                super(...arguments), this.onNearChange = e => {
                    this.props.camera.near = e, this.update()
                }, this.onFarChange = e => {
                    this.props.camera.far = e, this.update()
                }, this.onLeftChange = e => {
                    this.props.camera.left = e, this.update()
                }, this.onRightChange = e => {
                    this.props.camera.right = e, this.update()
                }, this.onBottomChange = e => {
                    this.props.camera.bottom = e, this.update()
                }, this.onTopChange = e => {
                    this.props.camera.top = e, this.update()
                }
            }
            update() {
                Y.inst.invalidate(), this.forceUpdate()
            }
            render() {
                var e = this.props.camera;
                return u.createElement("div", {
                    className: "cameraPanel"
                }, u.createElement(G, {
                    label: "Near",
                    value: e.near,
                    onChange: this.onNearChange,
                    decimals: 6
                }), u.createElement(G, {
                    label: "Far",
                    value: e.far,
                    onChange: this.onFarChange
                }), u.createElement(G, {
                    label: "Left",
                    value: e.left,
                    onChange: this.onLeftChange
                }), u.createElement(G, {
                    label: "Right",
                    value: e.right,
                    onChange: this.onRightChange
                }), u.createElement(G, {
                    label: "Bottom",
                    value: e.bottom,
                    onChange: this.onBottomChange
                }), u.createElement(G, {
                    label: "Top",
                    value: e.top,
                    onChange: this.onTopChange
                }))
            }
        }
        class ci extends u.Component {
            constructor() {
                super(...arguments), this._options = [{
                    label: "Perspective",
                    cameraClass: ye.c,
                    panel: li
                }, {
                    label: "Orthographic",
                    cameraClass: ge.i,
                    panel: hi
                }], this._cache = new Map, this.onCameraChange = e => {
                    this.saveToCache(this.props.camera);
                    let t = this.getCached(e.cameraClass);
                    t = t || new e.cameraClass, this.props.onChange(t)
                }
            }
            saveToCache(e) {
                return this._cache.set(e.constructor, e)
            }
            getCached(e) {
                return this._cache.get(e)
            }
            getPanel(e) {
                var t = this.getOption(e).panel;
                return u.createElement(t, {
                    camera: e
                })
            }
            getOption(t) {
                return this._options.filter(e => e.cameraClass === t.constructor)[0]
            }
            render() {
                var e = this.props.camera,
                    t = this.getPanel(e);
                return u.createElement("div", {
                    className: "cameraPanel"
                }, u.createElement(k, {
                    label: "Type "
                }, u.createElement(F, {
                    selected: this.getOption(e),
                    options: this._options,
                    onChange: this.onCameraChange,
                    render: F.renderLabel
                })), t)
            }
        }
        class di extends u.Component {
            constructor(e) {
                super(e), this.state = {
                    selectedIndex: this.props.selectedIndex || 0
                }
            }
            findSelectedIndex(t) {
                let s = this.state.selectedIndex;
                if (t[s].props.disabled)
                    for (let e = 0; e < t.length; ++e)
                        if (!t[e].props.disabled) {
                            s = e;
                            break
                        }
                return s
            }
            render() {
                const e = u.Children.toArray(this.props.children).filter(e => !!e),
                    i = this.findSelectedIndex(e),
                    a = [],
                    t = e.map((e, t) => {
                        var s = i === t,
                            r = u.createElement(ai, {
                                key: t,
                                label: e.props.title,
                                disabled: e.props.disabled,
                                value: s,
                                onChange: () => {
                                    this.setState({
                                        selectedIndex: t
                                    })
                                }
                            });
                        return a.push(r), e.props.disabled ? null : u.cloneElement(e, {
                            active: s
                        })
                    });
                return u.createElement("div", {
                    className: "TabView " + this.props.className,
                    style: this.props.style
                }, u.createElement("div", {
                    className: "buttons"
                }, a), u.createElement("div", {
                    className: "views"
                }, t))
            }
        }
        di.defaultProps = {
            className: "",
            selectedIndex: 0
        };
        class ui extends u.Component {
            constructor(e) {
                super(e)
            }
            render() {
                var {
                    active: e,
                    toggleMount: t
                } = this.props;
                return u.createElement("div", {
                    className: h({
                        active: this.props.active
                    })
                }, (e || !t) && this.props.children)
            }
        }
        ui.defaultProps = {
            title: "",
            active: !1,
            disabled: !1,
            toggleMount: !1
        };
        class pi extends u.Component {
            constructor() {
                super(...arguments), this.onAmbientColorChange = e => {
                    this.props.scene.lights.ambient.color = e, this.update()
                }, this.onAmbientIntensityChange = e => {
                    this.props.scene.lights.ambient.intensity = e, this.update()
                }, this.onSunColorChange = e => {
                    this.props.scene.lights.sun.color = e, this.update()
                }, this.onSunIntensityChange = e => {
                    this.props.scene.lights.sun.intensity = e, this.update()
                }, this.onIBLIntensityChange = e => {
                    this.props.scene.lights.ibl.intensity = e, this.update()
                }, this.onChangeGammaEnabled = e => {
                    this.props.engine.adapter.gammaEnabled = e, this.update()
                }
            }
            update() {
                Y.inst.invalidate(), this.forceUpdate()
            }
            render() {
                const e = this.props.scene,
                    t = this.props.engine,
                    s = t.adapter,
                    r = e.lights,
                    i = r.sun,
                    a = i.direction,
                    n = r.ambient;
                return u.createElement("div", {
                    className: "EnvironmentPanel paddedContent"
                }, u.createElement("span", {
                    className: "sectionTitle"
                }, "Ambient Light"), u.createElement("div", {
                    className: "block"
                }, u.createElement("div", {
                    className: "props"
                }, u.createElement(G, {
                    label: "Insensity",
                    value: n.intensity,
                    min: 0,
                    onChange: this.onAmbientIntensityChange
                }), u.createElement(Nt, {
                    value: n.color,
                    onChange: this.onAmbientColorChange
                }))), u.createElement("br", null), u.createElement("span", {
                    className: "sectionTitle"
                }, "Directional Light"), u.createElement("div", {
                    className: "block"
                }, u.createElement("div", {
                    className: "props"
                }, u.createElement(G, {
                    label: "X",
                    value: a[0],
                    onChange: e => {
                        a[0] = e, this.update()
                    }
                }), u.createElement(G, {
                    label: "Y",
                    value: a[1],
                    onChange: e => {
                        a[1] = e, this.update()
                    }
                }), u.createElement(G, {
                    label: "Z",
                    value: a[2],
                    onChange: e => {
                        a[2] = e, this.update()
                    }
                })), u.createElement("div", {
                    className: "props"
                }, u.createElement(G, {
                    label: "Intensity",
                    value: i.intensity,
                    min: 0,
                    onChange: this.onSunIntensityChange
                }), u.createElement(Nt, {
                    value: i.color,
                    onChange: this.onSunColorChange
                }))), u.createElement("br", null), u.createElement("br", null), u.createElement(G, {
                    label: "IBL Intensity",
                    value: r.ibl.intensity,
                    min: 0,
                    onChange: this.onIBLIntensityChange
                }), u.createElement("br", null), u.createElement("br", null), t && u.createElement(k, {
                    label: "Gamma: "
                }, u.createElement(U, {
                    value: s.gammaEnabled,
                    onChange: this.onChangeGammaEnabled
                }), u.createElement(G, {
                    value: s.gammaFactor,
                    onChange: e => {
                        s.gammaFactor = e, this.update()
                    },
                    step: .1,
                    disabled: !s.gammaEnabled
                })))
            }
        }
        class mi extends u.Component {
            update() {
                Y.inst.invalidate(), this.forceUpdate()
            }
            render() {
                const t = this.props.background;
                return u.createElement(u.Fragment, null, u.createElement("span", null, "Background color"), u.createElement(Nt, {
                    value: t.color,
                    onChange: e => {
                        t.color = e, this.update()
                    }
                }))
            }
        }
        class gi extends u.Component {
            update() {
                Y.inst.invalidate(), this.forceUpdate()
            }
            render() {
                const t = this.props.background;
                return u.createElement("div", null, u.createElement(k, {
                    label: "Colors: "
                }, u.createElement(Nt, {
                    value: t.color1,
                    onChange: e => {
                        t.color1 = e, this.update()
                    }
                }), u.createElement(Nt, {
                    value: t.color2,
                    onChange: e => {
                        t.color2 = e, this.update()
                    }
                })), u.createElement(G, {
                    label: "Noise alpha",
                    min: 0,
                    value: t.noiseAlpha,
                    onChange: e => {
                        t.noiseAlpha = e, this.update()
                    }
                }), u.createElement(G, {
                    label: "Grain scale",
                    min: 0,
                    value: t.grainScale,
                    onChange: e => {
                        t.grainScale = e, this.update()
                    }
                }))
            }
        }
        class _i extends u.Component {
            constructor() {
                super(...arguments), this._options = [{
                    label: "Solid",
                    backgroundClass: Q.$
                }, {
                    label: "Vignette",
                    backgroundClass: As
                }], this._optionCache = new Map, this.onTypeChange = e => {
                    var t = this.props.scene;
                    t.background && this.saveToCache(t.background), t.background = this.getCached(e.backgroundClass) || new e.backgroundClass, this.update()
                }
            }
            saveToCache(e) {
                return this._optionCache.set(e.constructor, e)
            }
            getCached(e) {
                return this._optionCache.get(e)
            }
            getPanel(e) {
                return e instanceof Q.$ ? u.createElement(mi, {
                    background: e
                }) : e instanceof As ? u.createElement(gi, {
                    background: e
                }) : null
            }
            update() {
                Y.inst.invalidate(), this.forceUpdate()
            }
            render() {
                const t = this.props.scene.background;
                return u.createElement("div", {
                    className: "paddedContent"
                }, u.createElement(k, {
                    label: "Type: "
                }, u.createElement(F, {
                    selected: this._options.find(e => e.backgroundClass === t.constructor),
                    options: this._options,
                    onChange: this.onTypeChange,
                    render: F.renderLabel
                })), this.getPanel(t))
            }
        }
        const fi = {
                [_.g.INT]: "INT",
                [_.g.UNSIGNED_INT]: "UNSIGNED_INT",
                [_.g.BYTE]: "BYTE",
                [_.g.SHORT]: "SHORT",
                [_.g.UNSIGNED_BYTE]: "UNSIGNED_BYTE",
                [_.g.UNSIGNED_SHORT]: "UNSIGNED_SHORT",
                [_.g.FLOAT]: "FLOAT",
                [_.g.HALF_FLOAT]: "HALF_FLOAT"
            },
            vi = {
                [_.g.TRIANGLES]: "Triangles",
                [_.g.TRIANGLE_STRIP]: "Triangle strips",
                [_.g.TRIANGLE_FAN]: "Triangle fans",
                [_.g.POINTS]: "Points",
                [_.g.LINES]: "Lines",
                [_.g.LINE_STRIP]: "Line strips",
                [_.g.LINE_LOOP]: "Line loops"
            };
        class bi extends u.Component {
            renderTitle(e) {
                let t = "";
                for (const r in e) {
                    var s = e[r];
                    null != s && (t && (t += "\n"), t += r + ": " + s)
                }
                return t
            }
            render() {
                var e = this.props.node.geometry;
                return u.createElement(ii, {
                    label: `Geometry (${e.name||e.id})`
                }, u.createElement("div", {
                    className: "GeometryPanel"
                }, u.createElement("div", {
                    className: "layout"
                }, e.buffers.map((e, t) => u.createElement("div", {
                    key: t,
                    className: "buffer"
                }, u.createElement("div", {
                    className: "title",
                    title: this.renderTitle({
                        name: e.buffer.name,
                        byteStride: e.byteStride,
                        byteLength: e.buffer.data.byteLength,
                        count: e.count
                    })
                }, "BufferView ", e.buffer.id), u.createElement("div", {
                    className: "attributes"
                }, e.attributes.map((e, t) => {
                    var s = this.renderTitle({
                        byteOffset: e.byteOffset,
                        count: e.count,
                        componentType: `${e.componentType}(${fi[e.componentType]})`,
                        name: e.name
                    });
                    return u.createElement("div", {
                        key: t,
                        className: "attribute"
                    }, u.createElement("div", {
                        className: "semantic",
                        title: s
                    }, (t = e.semantic, A.p.isTexCoord(t) ? "UV" + A.p.decomposeTexCoord(t)["index"] : t.substr(0, 3).toUpperCase())), u.createElement("div", {
                        className: "components"
                    }, 1 <= e.size && u.createElement("div", {
                        className: "component"
                    }, "X"), 2 <= e.size && u.createElement("div", {
                        className: "component"
                    }, "Y"), 3 <= e.size && u.createElement("div", {
                        className: "component"
                    }, "Z"), 4 <= e.size && u.createElement("div", {
                        className: "component"
                    }, "W")))
                }))))), e.indexBuffer && u.createElement("div", {
                    className: "buffer indexBuffer",
                    title: this.renderTitle({
                        name: e.indexBuffer.name,
                        start: e.start,
                        count: e.indexBuffer.count,
                        byteOffset: e.indexBuffer.byteOffset,
                        type: `${e.indexBuffer.componentType}(${fi[e.indexBuffer.componentType]})`
                    })
                }, u.createElement("div", {
                    className: "title"
                }, "IndexBuffer ", e.indexBuffer.buffer.id)), u.createElement("br", null), u.createElement("br", null), "Vertices: ", e.vertexCount, u.createElement("br", null), vi[e.mode], ": ", ue.oY.calculateNumberOfPrimitives(e.count, e.mode), u.createElement("br", null), "[Start: ", e.start, ", Count: ", e.count, "]"))
            }
        }
        class xi extends u.Component {
            constructor(e) {
                super(e), this._refreshInterval = 1e3, this._lastTime = 0, this._frames = 0, this._interval = -1, this._raf = -1, this.onFrame = () => {
                    this._frames++, this._raf = requestAnimationFrame(this.onFrame)
                }, this.onRefresh = () => {
                    var e, t;
                    document.hidden || (e = (t = window.performance.now()) - this._lastTime, this._lastTime = t, t = Math.round(1e3 * this._frames / e), this.setState({
                        frameRate: t
                    }), this._frames = 0)
                }, this.state = {
                    frameRate: 0
                }
            }
            update() {
                Y.inst.invalidate(), this.forceUpdate()
            }
            componentDidMount() {
                this._lastTime = window.performance.now(), this._interval = window.setInterval(this.onRefresh, this._refreshInterval), this._raf = requestAnimationFrame(this.onFrame)
            }
            componentWillUnmount() {
                window.clearInterval(this._interval), cancelAnimationFrame(this._raf), this._interval = -1, this._raf = -1
            }
            render() {
                var {} = this.props, e = this.state["frameRate"];
                return u.createElement("div", null, u.createElement(G, {
                    label: "FPS",
                    disabled: !0,
                    value: e,
                    decimals: 0
                }))
            }
        }
        class Ti extends u.Component {
            constructor(e) {
                super(e), this.onCopyrightInput = e => {
                    Y.inst.project.asset.copyright = e, this.update()
                }, this.onGeneratorInput = e => {
                    Y.inst.project.asset.generator = e, this.update()
                }, this.onVersionInput = e => {
                    Y.inst.project.asset.version = e, this.update()
                }, this.onMinVersionInput = e => {
                    Y.inst.project.asset.minVersion = e, this.update()
                }
            }
            update() {
                this.forceUpdate()
            }
            render() {
                var {} = this.props, e = Y.inst.project.asset;
                return u.createElement("div", {
                    className: "paddedContent"
                }, u.createElement(At, {
                    label: "Copyright",
                    value: e.copyright,
                    onInput: this.onCopyrightInput
                }), u.createElement(At, {
                    label: "Generator",
                    value: e.generator,
                    onInput: this.onGeneratorInput
                }), u.createElement(At, {
                    label: "Version",
                    value: e.version,
                    onInput: this.onVersionInput
                }), u.createElement(At, {
                    label: "Min version",
                    value: e.minVersion,
                    onInput: this.onMinVersionInput
                }))
            }
        }
        class wi extends u.Component {
            constructor() {
                super(...arguments), this.onResolutionScaleChange = e => {
                    this.props.engine.resolutionScale = e / 100, this.update()
                }, this.onSelectionColorChange = e => {
                    this.props.engine.debugTools.selectionColor = e, this.update()
                }, this.onSelectionThicknessChange = e => {
                    this.props.engine.debugTools.selectionThickness = e, this.update()
                }, this.onWireframeColorChange = e => {
                    this.props.engine.debugTools.wireframeMaterial.color = e, this.update()
                }
            }
            update() {
                Y.inst.invalidate(), this.forceUpdate()
            }
            getEngineOptions() {
                return this.props.engine, ["WebGL 1", "WebGL 2"]
            }
            render() {
                var e = this.props["engine"],
                    t = e.adapter;
                return u.createElement("div", {
                    className: "paddedContent"
                }, u.createElement(k, {
                    label: "Engine"
                }, u.createElement(F, {
                    options: this.getEngineOptions(),
                    disabled: !0,
                    selected: t instanceof Js ? 2 === t.context.version ? "WebGL 2" : "WebGL 1" : "WebGPU"
                })), u.createElement(G, {
                    label: "Resolution",
                    value: 100 * e.resolutionScale,
                    min: 0,
                    postfix: "%",
                    onChange: this.onResolutionScaleChange,
                    step: 1,
                    decimals: 0
                }), u.createElement(k, {
                    label: "Selection color"
                }, u.createElement(Nt, {
                    value: e.debugTools.selectionColor,
                    onChange: this.onSelectionColorChange
                })), u.createElement(G, {
                    label: "Thickness",
                    value: e.debugTools.selectionThickness,
                    step: .01,
                    min: 0,
                    onChange: this.onSelectionThicknessChange
                }), u.createElement(k, {
                    label: "Wireframe color"
                }, u.createElement(Nt, {
                    value: e.debugTools.wireframeMaterial.color,
                    onChange: this.onWireframeColorChange
                })), u.createElement("hr", null), u.createElement(Ti, null), u.createElement("hr", null), u.createElement(xi, {
                    engine: e
                }))
            }
        }
        var Ae = c(1644);
        class Ei extends u.Component {
            constructor() {
                super(...arguments), this.onNameChange = e => {
                    var t = this.props.node.light;
                    t && (t.name = e, this.invalidate())
                }, this.onTypeChange = e => {
                    var t = this.props.node.light;
                    t && null !== e && (t.type = e.value, this.invalidate())
                }, this.onIntensityChange = e => {
                    var t = this.props.node.light;
                    t && (t.data.intensity = e, this.invalidate())
                }, this.onColorChange = e => {
                    var t = this.props.node.light;
                    t && (t.data.color = m.I.decomposeAndNormalizeRGB(e), this.invalidate())
                }, this.onRangeChange = e => {
                    var t = this.props.node.light;
                    t && (t.data.range = e, this.invalidate())
                }, this.onToggleInfiniteRange = e => {
                    var t = this.props.node.light;
                    t && (t.data.range = void 0 === t.data.range ? 99 : void 0, this.invalidate())
                }, this.onInnerConeAngleChange = e => {
                    var t = this.props.node.light;
                    t && (t.data.spot.innerConeAngle = e * f.M.DEG2RAD, this.invalidate())
                }, this.onOuterConeAngleChange = e => {
                    var t = this.props.node.light;
                    t && (t.data.spot.outerConeAngle = e * f.M.DEG2RAD, this.invalidate())
                }, this.onDeleteClicked = () => {
                    this.props.node.light = void 0, this.invalidate()
                }, this.onAddClicked = () => {
                    this.props.node.light = new Ae.a(this.props.node, {
                        type: "point"
                    }), this.invalidate()
                }
            }
            invalidate() {
                Y.inst.invalidate(), this.forceUpdate()
            }
            render() {
                const t = this.props.node.light;
                return t ? u.createElement(ii, {
                    label: "Light",
                    onDelete: this.onDeleteClicked
                }, u.createElement(At, {
                    label: "Name",
                    value: t.name,
                    onInput: this.onNameChange
                }), u.createElement(k, {
                    label: "Type"
                }, u.createElement(F, {
                    options: Ei.types,
                    render: e => e.label,
                    selected: Ei.types.find(e => e.value === t.type),
                    onChange: this.onTypeChange
                })), u.createElement("div", {
                    className: "hbox"
                }, u.createElement(G, {
                    label: "Intensity",
                    value: t.data.intensity,
                    onChange: this.onIntensityChange,
                    step: .01,
                    decimals: 2
                }), u.createElement("span", null, t.getIntensityUnit()), u.createElement(Nt, {
                    value: m.I.vec3_to_hex(t.data.color),
                    onChange: this.onColorChange
                })), ("spot" === t.type || "point" === t.type) && u.createElement(u.Fragment, null, u.createElement(G, {
                    label: "Range",
                    value: t.data.range,
                    onChange: this.onRangeChange,
                    min: .01,
                    step: .01,
                    decimals: 2,
                    disabled: void 0 === t.data.range
                }), u.createElement(k, {
                    label: "Infinite"
                }, u.createElement(U, {
                    value: void 0 === t.data.range,
                    onChange: this.onToggleInfiniteRange
                }))), "spot" === t.type && t.data.spot && u.createElement(u.Fragment, null, u.createElement(G, {
                    label: "Inner Cone Angle",
                    value: t.data.spot.innerConeAngle * f.M.RAD2DEG,
                    onChange: this.onInnerConeAngleChange,
                    min: 0,
                    max: t.data.spot.outerConeAngle - .01,
                    step: .1,
                    decimals: 1
                }), u.createElement(G, {
                    label: "Outer Cone Angle",
                    value: t.data.spot.outerConeAngle * f.M.RAD2DEG,
                    onChange: this.onOuterConeAngleChange,
                    min: t.data.spot.innerConeAngle,
                    max: Math.PI / 2 * f.M.RAD2DEG,
                    step: .1,
                    decimals: 1
                }))) : u.createElement(Rt, {
                    label: "Add light",
                    onClick: this.onAddClicked
                })
            }
        }
        Ei.types = [{
            label: "Directional",
            value: "directional"
        }, {
            label: "Point",
            value: "point"
        }, {
            label: "Spot",
            value: "spot"
        }];
        class Ci extends u.Component {
            constructor() {
                super(...arguments), this.onChange = e => {
                    var t, s, e = Number(e.currentTarget.value);
                    null != (s = (t = this.props).onChange) && s.call(t, e)
                }
            }
            render() {
                var e = null == (e = this.props.value) ? void 0 : e.toString();
                return u.createElement("input", {
                    type: "range",
                    min: this.props.min,
                    max: this.props.max,
                    step: this.props.step,
                    value: e,
                    onChange: this.onChange
                })
            }
        }
        Ci.defaultProps = {
            value: 0,
            min: 0,
            max: 1,
            step: .01
        };
        class yi extends u.Component {
            constructor(e) {
                super(e), this.onAnimationChange = () => {
                    this.forceUpdate()
                }, this.onChangeWeight = (e, t) => {
                    this.props.node.morphWeights && (this.props.node.morphWeights[t] = e, Y.inst.invalidate(), this.forceUpdate())
                }, this.state = {
                    local: !0
                }, null != (e = Y.inst.project.animationEngine) && e.signals.change.add(this.onAnimationChange)
            }
            componentWillUnmount() {
                var e;
                null != (e = Y.inst.project.animationEngine) && e.signals.change.remove(this.onAnimationChange)
            }
            render() {
                var e = this.props.node.morphWeights;
                return e ? u.createElement(ii, {
                    label: "Morph weights",
                    collapsed: !0
                }, u.createElement("div", {
                    className: "MorphTargetsPanel vbox"
                }, e.map((e, t) => u.createElement(Ci, {
                    key: t,
                    value: e,
                    onChange: e => this.onChangeWeight(e, t),
                    min: 0,
                    max: 1,
                    step: .01
                })))) : null
            }
        }
        class Ai extends u.Component {
            render() {
                var e = this.props.node.getBoundingBox().getSize(),
                    t = this.props.node.getBoundingBoxWorld(),
                    t = (null == t ? void 0 : t.getSize()) || M.R.fromValues(0, 0, 0);
                return u.createElement(ii, {
                    label: "Bounding Box"
                }, u.createElement("div", {
                    className: "BoundingBoxPanel"
                }, u.createElement("div", {
                    className: "block"
                }, u.createElement("label", {
                    title: "Axis Aligned Bounding Box"
                }, "AABB"), u.createElement("div", {
                    className: "props"
                }, u.createElement(G, {
                    label: "X",
                    value: e[0],
                    decimals: 3,
                    disabled: !0
                }), u.createElement(G, {
                    label: "Y",
                    value: e[1],
                    decimals: 3,
                    disabled: !0
                }), u.createElement(G, {
                    label: "Z",
                    value: e[2],
                    decimals: 3,
                    disabled: !0
                }))), u.createElement("div", {
                    className: "block"
                }, u.createElement("label", {
                    title: "Axis Aligned World Bounding Box"
                }, "AABB World"), u.createElement("div", {
                    className: "props"
                }, u.createElement(G, {
                    label: "X",
                    value: t[0],
                    decimals: 3,
                    disabled: !0
                }), u.createElement(G, {
                    label: "Y",
                    value: t[1],
                    decimals: 3,
                    disabled: !0
                }), u.createElement(G, {
                    label: "Z",
                    value: t[2],
                    decimals: 3,
                    disabled: !0
                })))))
            }
        }
        class Mi {
            static getNode(e) {
                return e instanceof T.j || e instanceof Ae.a ? e.node : e
            }
            constructor(e) {
                this._app = e
            }
            getSelectedNode() {
                return Mi.getNode(this._app.state.selected)
            }
            getSelectedNodeTarget() {
                return this.getSelectedNode() || this._app.state.scene
            }
            getSelectedRenderNode() {
                const e = this._app.state.selected;
                if (e instanceof T.j) return e; {
                    const e = this.getSelectedNode();
                    return e instanceof K.x ? void 0 : null == e ? void 0 : e.renderNodes[0]
                }
            }
            getTarget() {
                var e = this._app.state.selected;
                return e instanceof T.j ? e : e instanceof Ae.a ? e.node : e || this._app.state.scene
            }
        }
        class Ri extends u.Component {
            constructor() {
                super(...arguments), this.onChangeNodeName = e => {
                    var t = this.props["node"];
                    t && (t.name = e, this.forceUpdate())
                }
            }
            render() {
                var {
                    node: e,
                    scene: t,
                    engine: s
                } = this.props, r = e instanceof T.j ? e : e instanceof q.B ? e.renderNodes[0] : null, i = Mi.getNode(e);
                return u.createElement(di, {
                    className: "PropertyPanel"
                }, u.createElement(ui, {
                    title: "Material",
                    disabled: !r
                }, r && u.createElement(ri, {
                    node: r
                })), u.createElement(ui, {
                    title: "Node",
                    disabled: !e
                }, e instanceof q.B && u.createElement(At, {
                    label: "Name",
                    placeholder: "Untitled",
                    value: e.name,
                    onInput: this.onChangeNodeName
                }), (null == i ? void 0 : i.isRealSceneNode()) && u.createElement(ni, {
                    node: i
                }), r && u.createElement(bi, {
                    node: r
                }), r && u.createElement(Ai, {
                    node: r
                }), r && i && u.createElement(yi, {
                    node: i
                }), (null == i ? void 0 : i.isRealSceneNode()) && u.createElement(Ei, {
                    node: i
                }), e instanceof Ce.h && u.createElement(ci, {
                    camera: e,
                    scene: t,
                    onChange: () => {}
                })), u.createElement(ui, {
                    title: "Lights"
                }, u.createElement(pi, {
                    scene: t,
                    engine: s
                })), u.createElement(ui, {
                    title: "Background"
                }, u.createElement(_i, {
                    scene: t
                })), u.createElement(ui, {
                    title: "Settings",
                    toggleMount: !0
                }, u.createElement(wi, {
                    engine: s
                })))
            }
        }
        class Si {
            static toggle(e = null, t = !1) {
                Si.isFullscreen() ? Si.cancel() : (e = e || Si.target) && Si.request(e, t)
            }
            static request(e, t = 0) {
                (e = e || document.documentElement).requestFullscreen ? e.requestFullscreen() : e.webkitRequestFullscreen ? e.webkitRequestFullscreen() : e.mozRequestFullScreen ? e.mozRequestFullScreen() : e.msRequestFullscreen && e.msRequestFullscreen(), Si.target = e
            }
            static cancel() {
                document.exitFullscreen ? document.exitFullscreen() : document.webkitCancelFullScreen ? document.webkitCancelFullScreen() : document.mozCancelFullScreen ? document.mozCancelFullScreen() : document.cancelFullScreen ? document.cancelFullScreen() : document.msExitFullscreen && document.msExitFullscreen(), this.target = null
            }
            static isFullscreen() {
                return !!(document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement)
            }
        }
        Si.target = null;
        class Ni {
            static unifyMaterials(e) {
                const i = new Set,
                    a = {};
                return H.traverseRenderNodesOnce(e, e => {
                    var t = e.material,
                        s = (i.has(t) || i.add(t), t.getEqualsKey()),
                        r = a[s];
                    r ? r !== e.material && e.setMaterial(r) : a[s] = t
                }), {
                    materialsChecked: i.size,
                    newMaterialCount: Object.keys(a).length
                }
            }
            static findEmptyNodes(e) {
                const s = new Set,
                    r = e => {
                        let t = !0;
                        this.hasRenderNode(e) && (t = !1);
                        for (const s of e.children) r(s) || (t = !1);
                        return t && s.add(e), t
                    };
                return r(e), s
            }
            static hasRenderNode(e) {
                return 0 < e.renderNodes.length
            }
        }
        class Ii extends u.Component {
            constructor(e) {
                super(e), this.onRunClick = () => {
                    var e = Ni.unifyMaterials(this.props.app.state.scene);
                    this.setState({
                        result: e
                    })
                }, this.onCloseClick = () => {
                    this.close()
                }, this.onMount = e => {
                    y.listenPopup(e, this.onCloseClick)
                }, this.state = {}, this.props.keyboardListener.signals.down.add(this.onKeyDown, this)
            }
            close() {
                this.props.keyboardListener.signals.down.remove(this.onKeyDown, this), this.props.onClose()
            }
            onKeyDown(e) {
                e.keyCode === P.KEY_ESCAPE ? this.close() : e.keyCode === P.KEY_ENTER && this.onRunClick()
            }
            render() {
                var e = this.state["result"];
                return u.createElement("div", {
                    className: "popup dark-panel",
                    ref: this.onMount
                }, u.createElement("div", {
                    className: "panel-header"
                }, u.createElement("div", {
                    className: "panel-title"
                }, "Merge Materials"), u.createElement("div", {
                    className: "panel-close",
                    onClick: this.onCloseClick
                })), u.createElement("div", {
                    className: "panel-content vbox",
                    style: {
                        minHeight: 140
                    }
                }, e ? u.createElement("div", {
                    className: "flex_1"
                }, u.createElement("p", null, "Materials before: ", e.materialsChecked), u.createElement("p", null, "Materials removed: ", e.materialsChecked - e.newMaterialCount), u.createElement("p", null, "Materials after: ", e.newMaterialCount)) : u.createElement("div", {
                    className: "flex_1"
                }, u.createElement("p", null, "Optimize materials by finding and removing identical duplicates. If multiple materials have the same properties, only one will be kept.")), u.createElement("div", {
                    className: "hbox hcenter"
                }, e ? u.createElement(Rt, {
                    label: "Close",
                    onClick: this.onCloseClick
                }) : u.createElement(Rt, {
                    label: "Run",
                    onClick: this.onRunClick
                }))))
            }
        }
        var C = c(8255),
            Me = c(1219);
        class Pi {
            static merge(e, t = {}) {
                return new Pi(e, t).result
            }
            constructor(e, t) {
                this._nodes = new Map, this.prePass = e => {
                    var t;
                    this.filterNode(e) && ((t = this.getMergedNode(e)).material = t.material || e.material, t.totalCount += e.geometry.count, e.geometry.indexBuffer && (t.indexBuffer = t.indexBuffer || {
                        byteSize: 0
                    }, t.indexBuffer.byteSize += e.geometry.indexBuffer.count * ue._Z[_.g.UNSIGNED_INT]), t.vertexBuffers = t.vertexBuffers || [{
                        attributes: e.geometry.getAttributes().slice(0).map(e => ({
                            semantic: e.semantic,
                            componentType: e.componentType,
                            size: e.size,
                            normalized: e.normalized
                        })),
                        byteSize: 0
                    }], t.vertexBuffers[0].byteSize += e.geometry.getTotalVertexByteSize())
                }, this.parseRenderNode = e => {
                    var t;
                    if (this.filterNode(e)) {
                        const s = this.getMergedNode(e);
                        for (const e of s.vertexBuffers) e.data = e.data || new Me.c(e.byteSize);
                        null != (t = s.indexBuffer) && t.byteSize && (s.indexBuffer.data = s.indexBuffer.data || new Me.c(s.indexBuffer.byteSize)); {
                            const t = s.vertexBuffers[0],
                                r = e.geometry.getAttribute(A.p.POSITION);
                            if (!r) return;
                            const n = new N.s(r),
                                i = e.geometry.getAttribute(A.p.NORMAL),
                                o = i ? new N.s(i) : void 0,
                                l = M.R.create(),
                                h = M.R.create(),
                                c = g.v.create(),
                                d = e.node.calculateWorldMatrix(),
                                u = E.x.getNormalMatrix(e.node.transform),
                                p = e.geometry.getAttributes().map(e => new N.s(e));
                            let a = t.data;
                            a && C.O.iterateVertices(e.geometry, t => {
                                for (const i of p)
                                    if (i.attribute.semantic === A.p.POSITION) {
                                        var e = n.readToVec3(t, l),
                                            e = M.R.transformMat4(h, e, d);
                                        a.writeVec(e, 3)
                                    } else if (o && i.attribute.semantic === A.p.NORMAL) {
                                    var e = o.readToVec3(t, c),
                                        s = g.v.transformDirection(e, e, u);
                                    a.writeVec(s, 3)
                                } else {
                                    var r = ue.rg[i.attribute.componentType];
                                    for (let e = 0; e < i.attribute.size; ++e) {
                                        const n = i.readAt(t, e);
                                        r.call(a.dataView, a.byteOffset, n, !0), a.byteOffset += ue._Z[i.attribute.componentType]
                                    }
                                }
                            })
                        }
                        e.geometry.indexBuffer && C.O.iterateIndices(e.geometry, e => {
                            s.indexBuffer.data.writeUint32(e + s.currentVertexCount)
                        }), s.currentVertexCount += e.geometry.vertexCount
                    }
                }, this._options = t, H.traverseRenderNodes(e, this.prePass), H.traverseRenderNodes(e, this.parseRenderNode), this.result = this.buildNewScene()
            }
            filterNode(e) {
                return e.geometry.mode === _.g.TRIANGLES && !!e.geometry.hasAttribute(A.p.POSITION)
            }
            buildNewScene() {
                const t = new K.x;
                return this._nodes.forEach(e => {
                    e = new q.B({
                        renderNodes: [new T.j({
                            material: e.material,
                            geometry: new Z.Z({
                                count: e.totalCount,
                                buffers: e.vertexBuffers.map(e => new b.t({
                                    buffer: new w.f({
                                        data: new Float32Array(e.data.dataView.buffer)
                                    }),
                                    attributes: e.attributes
                                })),
                                indexBuffer: e.indexBuffer ? x.Y.fromData(new Uint32Array(e.indexBuffer.data.dataView.buffer)) : void 0
                            })
                        })]
                    });
                    t.add(e)
                }), this.result = t, this.result
            }
            getKey(e) {
                var t = e.geometry;
                return `${this.getAttributesKey(t)}-${t.indexBuffer?"i1":"i0"}-` + e.material.getEqualsKey()
            }
            getAttributesKey(e) {
                var t;
                let s = "",
                    r = e.getAttributes().sort((e, t) => e.semantic > t.semantic ? 1 : -1);
                for (const e of r) s += `${e.semantic}-${e.size}-${e.sizeY||1}-${e.componentType}-${null!=(t=e.normalized)&&t}|`;
                return s
            }
            getMergedNode(e) {
                e = this.getKey(e);
                let t = this._nodes.get(e);
                return t || (t = {
                    vertexBuffers: void 0,
                    indexBuffer: void 0,
                    material: void 0,
                    totalCount: 0,
                    currentVertexCount: 0
                }, this._nodes.set(e, t)), t
            }
        }
        class Fi extends u.Component {
            constructor(e) {
                super(e), this.onRunClick = () => {
                    this.setState({
                        loading: !0
                    }), setTimeout(() => {
                        var e = Pi.merge(this.props.app.state.scene);
                        this.props.app.project.setScene(e), this.props.app.project.signals.change.dispatch(this.props.app.project), this.close()
                    }, 400)
                }, this.onCloseClick = () => {
                    this.close()
                }, this.onMount = e => {
                    y.listenPopup(e, this.onCloseClick)
                }, this.state = {
                    loading: !1
                }, this.props.keyboardListener.signals.down.add(this.onKeyDown, this)
            }
            close() {
                this.props.keyboardListener.signals.down.remove(this.onKeyDown, this), this.props.onClose()
            }
            onKeyDown(e) {
                e.keyCode === P.KEY_ESCAPE ? this.close() : e.keyCode === P.KEY_ENTER && this.onRunClick()
            }
            render() {
                var e = this.state["loading"];
                return u.createElement("div", {
                    className: "popup dark-panel",
                    ref: this.onMount
                }, u.createElement("div", {
                    className: "panel-header"
                }, u.createElement("div", {
                    className: "panel-title"
                }, "Merge Geometries"), u.createElement("div", {
                    className: "panel-close",
                    onClick: this.onCloseClick
                })), u.createElement("div", {
                    className: "panel-content vbox",
                    style: {
                        minHeight: 140
                    }
                }, u.createElement("div", {
                    className: "flex_1"
                }, u.createElement("p", null, "Merge geometries by finding ones with the same materials and writing them into the same big geometry buffer by converting vertices to world space.", u.createElement("br", null), u.createElement("br", null), "Note! This operation may take a long time and will freeze your browser. It might result in a huge buffer which may not be possible to upload depending on the model and your GPU.")), u.createElement("div", {
                    className: "hbox hcenter"
                }, u.createElement(Rt, {
                    label: e ? "Loading..." : "Run",
                    onClick: this.onRunClick,
                    disabled: e
                }))))
            }
        }
        class Li extends z {
            constructor(e) {
                super(e), this.addShortcut({
                    keyCode: P.KEY_TAB
                })
            }
            execute(e) {
                var t = this._app; {
                    const e = t.state.scene,
                        s = !t.state.wireframe;
                    e && (Hs.traverse(e, e => {
                        for (const t of e.renderNodes) t.material.wireframe = s
                    }), t.invalidate(), t.setState({
                        wireframe: s
                    }))
                }
            }
        }
        Li.ID = "toggle_wireframe";
        class Di extends z {
            constructor(e) {
                super(e), this.addShortcut({
                    keyCode: P.KEY_N
                })
            }
            execute(e) {
                const t = this._app,
                    s = t.selection.getSelectedRenderNode();
                if (s) {
                    const e = !t.engine.debugTools.getVertexNormalRenderer(s);
                    this.enableNormals(s, e), t.invalidate(), t.invalidateUI()
                } else {
                    const e = t.state.scene;
                    if (e) {
                        const s = !t.state.viewNormals;
                        H.traverseRenderNodesOnce(e, e => {
                            this.enableNormals(e, s)
                        }), t.invalidate(), t.setState({
                            viewNormals: s
                        })
                    }
                }
            }
            enableNormals(e, t) {
                this._app.engine.debugTools.toggleVertexNormals(e, t)
            }
        }
        Di.ID = "toggle_view_normals";
        class Oi extends z {
            constructor(e) {
                super(e)
            }
            execute() {
                const e = this._app,
                    t = e.selection.getSelectedNodeTarget(),
                    s = Ni.findEmptyNodes(t);
                s.has(e.state.selected) && e.setState({
                    selected: null
                });
                for (const e of s) e.detach();
                e.invalidate(), e.invalidateUI()
            }
        }
        Oi.ID = "remove_empty_nodes";
        class Bi extends z {
            constructor(e) {
                super(e)
            }
            execute() {
                const e = this._app,
                    t = e.selection.getSelectedNodeTarget(),
                    s = H.filterNodes(t, e => !e.visible, e => !e.visible);
                s.includes(e.state.selected) && e.setState({
                    selected: null
                });
                for (const e of s) e.detach();
                e.invalidate(), e.invalidateUI()
            }
        }
        Bi.ID = "remove_invisible_nodes";
        class Ui extends z {
            constructor(e) {
                super(e)
            }
            execute(e = 0) {
                var t = this._app;
                t.selection.getTarget(), t.invalidate(), t.invalidateUI()
            }
        }
        Ui.ID = "collapse_hierarchy";
        class ki {
            static packOcclusionIntoMetallicRoughness(e) {
                H.traverseRenderNodes(e, e => {
                    e = e.material;
                    e instanceof o.q && e.metallicRoughnessTextureInfo.texture && e.occlusionTextureInfo.texture && e.metallicRoughnessTextureInfo.texture !== e.occlusionTextureInfo.texture && (e.metallicRoughnessTextureInfo.texture = this.pack(e.metallicRoughnessTextureInfo.texture, e.occlusionTextureInfo.texture), e.occlusionTextureInfo.texture = e.metallicRoughnessTextureInfo.texture)
                })
            }
            static unpackOcclusionFromMetallicRoughness(e) {
                H.traverseRenderNodes(e, e => {
                    var t = e.material;
                    if (t instanceof o.q && t.metallicRoughnessTextureInfo.texture && t.occlusionTextureInfo.texture && t.metallicRoughnessTextureInfo.texture === t.occlusionTextureInfo.texture) {
                        const {
                            metallicRoughnessTexture: e,
                            occlusionTexture: s
                        } = this.unpack(t.metallicRoughnessTextureInfo.texture);
                        t.metallicRoughnessTextureInfo.texture = e, t.occlusionTextureInfo.texture = s
                    }
                })
            }
            static pack(e, t) {
                var s = v.O.readIntoCanvas({
                        texture: e
                    }),
                    t = v.O.readIntoCanvas({
                        texture: t
                    }),
                    r = document.createElement("canvas"),
                    i = (r.width = Math.max(s.width, t.width), r.height = Math.max(s.height, t.height), r.getContext("2d", {
                        willReadFrequently: !0
                    })),
                    a = (i.drawImage(s, 0, 0, r.width, r.height), i.getImageData(0, 0, r.width, r.height).data),
                    n = (i.drawImage(t, 0, 0, r.width, r.height), i.getImageData(0, 0, r.width, r.height).data),
                    o = r.width * r.height,
                    l = new Uint8ClampedArray(4 * o);
                for (let e = 0; e < 4 * o; e += 4) l[e + 0] = n[e + 0], l[e + 1] = a[e + 1], l[e + 2] = a[e + 2], l[e + 3] = 255;
                s = ce.P.createCanvasFromData(l, r.width, r.height);
                return e.clone(s)
            }
            static unpack(e) {
                const t = v.O.readIntoCanvas({
                        texture: e
                    }),
                    s = document.createElement("canvas");
                s.width = t.width, s.height = t.height;
                var r = s.getContext("2d", {
                        willReadFrequently: !0
                    }),
                    i = (r.drawImage(t, 0, 0, s.width, s.height), r.getImageData(0, 0, s.width, s.height).data),
                    a = s.width * s.height,
                    n = new Uint8ClampedArray(4 * a),
                    o = new Uint8ClampedArray(4 * a);
                for (let e = 0; e < 4 * a; e += 4) {
                    const t = i[e + 0];
                    o[e + 0] = t, o[e + 1] = t, o[e + 2] = t, o[e + 3] = 255, n[e + 1] = i[e + 1], n[e + 2] = i[e + 2], n[e + 3] = 255
                }
                r = document.createElement("canvas"); {
                    r.width = s.width, r.height = s.height;
                    const e = r.getContext("2d"),
                        t = new ImageData(n, s.width, s.height);
                    e.putImageData(t, 0, 0)
                }
                var l = document.createElement("canvas"); {
                    l.width = s.width, l.height = s.height;
                    const e = l.getContext("2d"),
                        t = new ImageData(o, s.width, s.height);
                    e.putImageData(t, 0, 0)
                }
                return {
                    metallicRoughnessTexture: e.clone(r),
                    occlusionTexture: e.clone(l)
                }
            }
        }
        class zi extends u.Component {
            constructor(e) {
                super(e), this.onRunClick = () => {
                    this.setState({
                        loading: !0
                    }), setTimeout(() => {
                        this.state.pack ? ki.packOcclusionIntoMetallicRoughness(this.props.app.state.scene) : ki.unpackOcclusionFromMetallicRoughness(this.props.app.state.scene), this.props.app.invalidate(), this.props.app.invalidateUI(), this.close()
                    }, 400)
                }, this.onCloseClick = () => {
                    this.close()
                }, this.onMount = e => {
                    y.listenPopup(e, this.onCloseClick)
                }, this.state = {
                    loading: !1,
                    pack: !0
                }, this.props.keyboardListener.signals.down.add(this.onKeyDown, this)
            }
            close() {
                this.props.keyboardListener.signals.down.remove(this.onKeyDown, this), this.props.onClose()
            }
            onKeyDown(e) {
                e.keyCode === P.KEY_ESCAPE && this.close()
            }
            render() {
                var e = this.state["loading"];
                return u.createElement("div", {
                    className: "popup dark-panel",
                    ref: this.onMount
                }, u.createElement("div", {
                    className: "panel-header"
                }, u.createElement("div", {
                    className: "panel-title"
                }, "Pack Textures"), u.createElement("div", {
                    className: "panel-close",
                    onClick: this.onCloseClick
                })), u.createElement("div", {
                    className: "panel-content vbox",
                    style: {
                        minHeight: 140
                    }
                }, u.createElement("div", {
                    className: "flex_1"
                }, u.createElement(k, {
                    label: "Pack Occlusion into Metallic-Roughness"
                }, u.createElement(U, {
                    type: "radio",
                    value: this.state.pack,
                    onChange: e => this.setState({
                        pack: e
                    })
                })), u.createElement(k, {
                    label: "Unpack Occlusion from Metallic-Roughness"
                }, u.createElement(U, {
                    type: "radio",
                    value: !this.state.pack,
                    onChange: e => this.setState({
                        pack: !e
                    })
                }))), u.createElement("div", {
                    className: "hbox hcenter"
                }, u.createElement(Rt, {
                    label: e ? "Loading..." : "Run",
                    onClick: this.onRunClick,
                    disabled: e
                }))))
            }
        }

        function Re(e) {
            var t = M.R.create();
            for (const s of e) M.R.add(t, t, s);
            return M.R.scale(t, t, 1 / Math.max(e.length, 1)), t
        }

        function Se(e) {
            const s = [],
                t = e.getAttribute(A.p.POSITION);
            if (t) {
                const r = new N.s(t);
                C.O.iterateIndexedVerticesOnce(e, (e, t) => {
                    e = r.readToVec3(e, M.R.create());
                    s.push(e)
                })
            } else console.warn("No position attribute found in geometry");
            return s
        }
        zi.id = "packTexturesWindow";
        const Vi = (e, t = !0, s = !0, r, i) => {
            t = void 0 === t || t, s = void 0 === s || s, i = 1e-64 / (r = r || Math.pow(2, -52));
            var a = [
                    [e[0], e[1], e[2]],
                    [e[3], e[4], e[5]],
                    [e[6], e[7], e[8]]
                ],
                n = a[0].length,
                o = a.length;
            if (o < n) throw new TypeError("Invalid matrix: m < n");
            let l = 0,
                h = 0,
                c = 0,
                d = 0,
                u, p = 0,
                m = 0,
                g = 0,
                _ = 0,
                f = 0,
                v = 0,
                b = 0,
                x = 0;
            g = 0, v = 0;
            var T = [],
                w = [],
                E = [],
                C = "f" === t ? o : n;
            for (l = 0; l < o; l++) w[l] = new Array(C).fill(0);
            for (l = 0; l < n; l++) E[l] = new Array(n).fill(0);
            var y = new Array(n).fill(0);
            for (l = 0; l < o; l++)
                for (h = 0; h < n; h++) w[l][h] = a[l][h];
            for (l = 0; l < n; l++) {
                for (T[l] = g, f = 0, d = l + 1, h = l; h < o; h++) f += Math.pow(w[h][l], 2);
                if (f < i) g = 0;
                else
                    for (m = w[l][l], g = m < 0 ? Math.sqrt(f) : -Math.sqrt(f), _ = m * g - f, w[l][l] = m - g, h = d; h < n; h++) {
                        for (f = 0, c = l; c < o; c++) f += w[c][l] * w[c][h];
                        for (m = f / _, c = l; c < o; c++) w[c][h] = w[c][h] + m * w[c][l]
                    }
                for (y[l] = g, f = 0, h = d; h < n; h++) f += Math.pow(w[l][h], 2);
                if (f < i) g = 0;
                else {
                    for (m = w[l][l + 1], g = m < 0 ? Math.sqrt(f) : -Math.sqrt(f), _ = m * g - f, w[l][l + 1] = m - g, h = d; h < n; h++) T[h] = w[l][h] / _;
                    for (h = d; h < o; h++) {
                        for (f = 0, c = d; c < n; c++) f += w[h][c] * w[l][c];
                        for (c = d; c < n; c++) w[h][c] = w[h][c] + f * T[c]
                    }
                }(b = Math.abs(y[l]) + Math.abs(T[l])) > v && (v = b)
            }
            if (s)
                for (l = n - 1; 0 <= l; l--) {
                    if (0 !== g) {
                        for (_ = w[l][l + 1] * g, h = d; h < n; h++) E[h][l] = w[l][h] / _;
                        for (h = d; h < n; h++) {
                            for (f = 0, c = d; c < n; c++) f += w[l][c] * E[c][h];
                            for (c = d; c < n; c++) E[c][h] = E[c][h] + f * E[c][l]
                        }
                    }
                    for (h = d; h < n; h++) E[l][h] = 0, E[h][l] = 0;
                    E[l][l] = 1, g = T[l], d = l
                }
            if (t) {
                if ("f" === t)
                    for (l = n; l < o; l++) {
                        for (h = n; h < o; h++) w[l][h] = 0;
                        w[l][l] = 1
                    }
                for (l = n - 1; 0 <= l; l--) {
                    for (d = l + 1, g = y[l], h = d; h < C; h++) w[l][h] = 0;
                    if (0 !== g) {
                        for (_ = w[l][l] * g, h = d; h < C; h++) {
                            for (f = 0, c = d; c < o; c++) f += w[c][l] * w[c][h];
                            for (m = f / _, c = l; c < o; c++) w[c][h] = w[c][h] + m * w[c][l]
                        }
                        for (h = l; h < o; h++) w[h][l] = w[h][l] / g
                    } else
                        for (h = l; h < o; h++) w[h][l] = 0;
                    w[l][l] = w[l][l] + 1
                }
            }
            let A;
            for (r *= v, c = n - 1; 0 <= c; c--)
                for (let e = 0; e < 50; e++) {
                    for (A = !1, d = c; 0 <= d; d--) {
                        if (Math.abs(T[d]) <= r) {
                            A = !0;
                            break
                        }
                        if (Math.abs(y[d - 1]) <= r) break
                    }
                    if (!A)
                        for (p = 0, f = 1, u = d - 1, l = d; l < c + 1 && (m = f * T[l], T[l] = p * T[l], !(Math.abs(m) <= r)); l++)
                            if (g = y[l], y[l] = Math.sqrt(m * m + g * g), _ = y[l], p = g / _, f = -m / _, t)
                                for (h = 0; h < o; h++) b = w[h][u], x = w[h][l], w[h][u] = b * p + x * f, w[h][l] = -b * f + x * p;
                    if (x = y[c], d === c) {
                        if (x < 0 && (y[c] = -x, s))
                            for (h = 0; h < n; h++) E[h][c] = -E[h][c];
                        break
                    }
                    for (v = y[d], b = y[c - 1], g = T[c - 1], _ = T[c], m = ((b - x) * (b + x) + (g - _) * (g + _)) / (2 * _ * b), g = Math.sqrt(m * m + 1), m = ((v - x) * (v + x) + _ * (b / (m < 0 ? m - g : m + g) - _)) / v, p = 1, f = 1, l = d + 1; l < c + 1; l++) {
                        if (g = T[l], b = y[l], _ = f * g, g *= p, x = Math.sqrt(m * m + _ * _), T[l - 1] = x, p = m / x, f = _ / x, m = v * p + g * f, g = -v * f + g * p, _ = b * f, b *= p, s)
                            for (h = 0; h < n; h++) v = E[h][l - 1], x = E[h][l], E[h][l - 1] = v * p + x * f, E[h][l] = -v * f + x * p;
                        if (x = Math.sqrt(m * m + _ * _), y[l - 1] = x, p = m / x, f = _ / x, m = p * g + f * b, v = -f * g + p * b, t)
                            for (h = 0; h < o; h++) b = w[h][l - 1], x = w[h][l], w[h][l - 1] = b * p + x * f, w[h][l] = -b * f + x * p
                    }
                    T[d] = 0, T[c] = m, y[c] = v
                }
            for (l = 0; l < n; l++) y[l] < r && (y[l] = 0);
            return {
                u: Ne(w),
                q: y,
                v: Ne(E)
            }
        };

        function Ne(e) {
            return [e[0][0], e[0][1], e[0][2], e[1][0], e[1][1], e[1][2], e[2][0], e[2][1], e[2][2]]
        }
        class Gi {
            static getMeshClusters(e) {
                let o = [];
                var t = e.getAttribute(A.p.POSITION);
                if (t) {
                    const l = new N.s(t);
                    C.O.iterateTriangles(e, (e, t, s) => {
                        const r = l.readToVec3(e),
                            i = l.readToVec3(t),
                            a = l.readToVec3(s),
                            n = o.map((e, t) => e.some(e => {
                                e = l.readToVec3(e);
                                return f.M.equals(e, r, .01) || f.M.equals(e, i, .01) || f.M.equals(e, a, .01)
                            }) ? t : -1).filter(e => -1 !== e);
                        if (0 === n.length) o.push([e, t, s]);
                        else if (1 === n.length) o[n[0]].push(e, t, s);
                        else {
                            const l = n.map(e => o[e]),
                                r = [];
                            l.forEach((e, t) => {
                                r.push(...e)
                            }), (o = o.filter((e, t) => !n.includes(t))).push(r), r.push(e, t, s)
                        }
                    })
                }
                return console.log("clusters", o.length), o
            }
            static tryMergingClusters(r) {
                for (;;) {
                    let s = !1;
                    for (let t = 0; t < r.length; ++t) {
                        var i = r[t];
                        for (let e = t + 1; e < r.length; ++e) {
                            var a = r[e];
                            if (this.isClusterMergable(i, a)) {
                                s = !0, r.splice(e, 1), r.splice(t, 1, i.concat(a));
                                break
                            }
                        }
                        if (s) break
                    }
                    if (!s) break
                }
            }
            static isClusterMergable(e, t) {
                return !1
            }
        }
        class Wi {
            static removeDuplicates(t, s, r) {
                var i, a;
                const n = H.flattenRenderNodes(t),
                    o = new Map;
                for (const t of n) {
                    const s = t.geometry;
                    for (const [s, r] of o.entries())
                        if (s !== t.geometry) {
                            const i = Wi.getTransformBetweenGeometries(s, t.geometry);
                            if (i) {
                                r.add([t, i]);
                                break
                            }
                        }
                    const r = Re(Se(t.geometry));
                    o.set(s, new Set([
                        [t, S._.fromTranslation(S._.create(), r)]
                    ]))
                }
                let l = 0;
                for (const t of o.values()) {
                    const s = Array.from(t),
                        r = null == (i = s[0]) ? void 0 : i[0].geometry;
                    S._.getTranslation(M.R.create(), null == (a = s[0]) ? void 0 : a[1]);
                    for (let e = 1; e < s.length; ++e) {
                        const i = s[e][0],
                            a = s[e][1],
                            n = i.node,
                            o = (i.setGeometry(r), n.transform.mat);
                        if (1 === n.renderNodes.length) {
                            const t = S._.mul(S._.create(), o, a);
                            n.transform.setFromMatrix(t)
                        } else {
                            const t = S._.mul(S._.create(), n.calculateWorldMatrix(), a),
                                s = (i.detach(), new q.B({
                                    renderNodes: [i]
                                })),
                                r = n.getParent() || n.scene;
                            if (!r) {
                                console.warn("Couldn't find parent for node.");
                                continue
                            } {
                                r.add(s);
                                const i = S._.invert(S._.create(), r.calculateWorldMatrix());
                                if (i) {
                                    const r = S._.mul(S._.create(), i, t);
                                    s.transform.setFromMatrix(r)
                                } else console.warn("Couldn't invert parent world matrix.")
                            }
                        }
                        i.setGeometry(r), l++
                    }
                }
                if (console.log("Removed duplicates: " + l), r) {
                    const t = s.getSelectedRenderNode();
                    if (t instanceof T.j) {
                        const s = Gi.getMeshClusters(t.geometry);
                        1 < s.length && ([].some(e => 1 < e.length), console.log("clusters", s))
                    }
                }
            }
            static getTransformBetweenGeometries(t, s) {
                if (t === s) return S._.identity(S._.create());
                if (t.count === s.count && t.mode === s.mode && Boolean(t.indexBuffer) === Boolean(s.indexBuffer)) {
                    const n = t.getAttributes().sort((e, t) => e.semantic > t.semantic ? 1 : -1),
                        o = s.getAttributes().sort((e, t) => e.semantic > t.semantic ? 1 : -1);
                    if (n.length === o.length) {
                        for (let e = 0; e < n.length; ++e) {
                            const s = n[e],
                                l = o[e];
                            if (s.semantic !== l.semantic || s.size !== l.size || s.sizeY !== l.sizeY || s.componentType !== l.componentType || s.normalized !== l.normalized || s.count !== l.count || s.byteOffset !== l.byteOffset || s.byteStride !== l.byteStride || s.divisor !== l.divisor) return
                        }
                        const l = Wi.calculateTransformation(t, s);
                        if (l) {
                            var r = n.map(e => new N.s(e)),
                                i = o.map(e => new N.s(e)),
                                a = E.x.getNormalMat(l);
                            for (let e = 0; e < t.count; e++) {
                                const o = t.indexBuffer ? t.indexBuffer.data[t.start + e] : e,
                                    h = s.indexBuffer ? s.indexBuffer.data[s.start + e] : e;
                                for (let e = 0; e < r.length; ++e) {
                                    const s = r[e],
                                        n = i[e];
                                    if (s.attribute.semantic === A.p.POSITION) {
                                        const t = s.readPointToVec4(o, g.v.create()),
                                            c = n.readPointToVec4(h, g.v.create()),
                                            d = g.v.transformMat4(g.v.create(), t, l);
                                        if (!f.M.equals(d, c, .01)) return
                                    } else if (s.attribute.semantic === A.p.NORMAL) {
                                        const t = s.readToVec3(o, g.v.create()),
                                            l = n.readToVec3(h, g.v.create()),
                                            u = g.v.transformDirection(g.v.create(), t, a);
                                        if (!f.M.equals(u, l, .01)) return
                                    }
                                }
                            }
                            return l
                        }
                    }
                }
            }
            static calculateTransform2(e, t) {
                const s = e.getAttribute(A.p.POSITION),
                    r = t.getAttribute(A.p.POSITION);
                if (s && r) {
                    const s = Se(e),
                        r = Se(t),
                        i = (Math.min(s.length, r.length), Re(s)),
                        a = Re(r),
                        n = (s.map(e => M.R.sub(M.R.create(), e, i)), r.map(e => M.R.sub(M.R.create(), e, a)), M.R.sub(M.R.create(), a, i));
                    return S._.clone([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, n[0], n[1], n[2], 1])
                }
            }
            static calculateTransformation(t, s) {
                const r = t.getAttribute(A.p.POSITION),
                    i = s.getAttribute(A.p.POSITION);
                if (r && i) {
                    new N.s(r), new N.s(i);
                    const d = Se(t),
                        u = Se(s),
                        p = Math.min(d.length, u.length),
                        m = Re(d),
                        g = Re(u);
                    console.log("centroidA", m), console.log("centroidB", g);
                    var a = t.getAttribute(A.p.NORMAL),
                        n = s.getAttribute(A.p.NORMAL);
                    let e;
                    if (a && n) {
                        const t = new N.s(a),
                            s = new N.s(n),
                            [r, i, _] = function(t) {
                                const s = t.attribute.count;
                                var r = t.readToVec3(0, M.R.create());
                                let i, a = 1 / 0;
                                for (let e = 1; e < s; ++e) {
                                    const s = Ie(r, t.readToVec3(e, M.R.create()));
                                    (void 0 === i || s < a) && (a = s, i = e)
                                }
                                var n = i || 1,
                                    o = t.readToVec3(n, M.R.create());
                                i = void 0, a = 1 / 0;
                                for (let e = 1; e < s; ++e)
                                    if (e !== n) {
                                        const s = t.readToVec3(e, M.R.create()),
                                            l = Ie(r, s),
                                            h = Ie(o, s),
                                            c = l * l + h * h;
                                        (void 0 === i || c < a) && (a = c, i = e)
                                    }
                                return [0, n, i || 2]
                            }(t),
                            f = t.readToVec3(r, M.R.create()),
                            v = t.readToVec3(i, M.R.create()),
                            b = t.readToVec3(_, M.R.create()),
                            x = s.readToVec3(r, M.R.create()),
                            A = s.readToVec3(i, M.R.create()),
                            T = s.readToVec3(_, M.R.create()),
                            w = R.w.transpose(R.w.create(), R.w.fromValues(f[0], v[0], b[0], f[1], v[1], b[1], f[2], v[2], b[2])),
                            E = R.w.transpose(R.w.create(), R.w.fromValues(x[0], A[0], T[0], x[1], A[1], T[1], x[2], A[2], T[2])),
                            C = R.w.invert(R.w.create(), E) || R.w.create();
                        e = R.w.mul(R.w.create(), C, w);
                        var a = R.w.mul(R.w.create(), w, R.w.transpose(R.w.create(), E)),
                            {
                                u: n,
                                q: o,
                                v: l
                            } = Vi(a);
                        console.log(n, o, l); {
                            const t = R.w.transpose(R.w.create(), a),
                                {
                                    u: s,
                                    q: r,
                                    v: i
                                } = Vi(t);
                            console.log(s, r, i)
                        }
                        e = R.w.mul(R.w.create(), R.w.transpose(R.w.create(), n), R.w.copy(R.w.create(), l))
                    } else {
                        const t = d.map(e => M.R.sub(M.R.create(), e, m)),
                            s = d.map(e => M.R.sub(M.R.create(), e, g)),
                            r = R.w.zero();
                        for (let e = 0; e < p; ++e) {
                            var h = t[e],
                                c = s[e];
                            R.w.add(r, r, M.R.mul_3x1_1x3(R.w.zero(), h, c))
                        }
                        const {
                            u: i,
                            v: y
                        } = Vi(r);
                        e = R.w.mul(R.w.create(), R.w.copy(R.w.create(), y), R.w.transpose(R.w.create(), i))
                    }
                    t = d[0], s = u[0], o = M.R.transformMat3(M.R.create(), t, e), a = M.R.sub(M.R.create(), s, o), n = (console.log("translation", a), S._.clone([e[0], e[1], e[2], 0, e[3], e[4], e[5], 0, e[6], e[7], e[8], 0, a[0], a[1], a[2], 1])), l = Te.g.create(), t = M.R.create(), s = M.R.create(), o = (S._.getRotation(l, n), S._.getScaling(t, n), S._.getTranslation(s, n), M.R.create());
                    return Te.g.toEuler(o, l), console.log("rot", o), console.log("sc", t), console.log("tr", s), n
                }
            }
        }

        function Ie(e, t) {
            return Math.abs(Math.PI / 2 - (e = e, t = t, Math.acos(M.R.dot(e, t) / (M.R.len(e) * M.R.len(t)))))
        }
        class Hi extends u.Component {
            constructor(e) {
                super(e), this.onRunClick = () => {
                    this.setState({
                        loading: !0
                    }), setTimeout(() => {
                        Wi.removeDuplicates(this.props.app.state.scene, this.props.app.selection, this.state.searchWithinMesh), this.close()
                    }, 400)
                }, this.onCloseClick = () => {
                    this.close()
                }, this.onMount = e => {
                    y.listenPopup(e, this.onCloseClick)
                }, this.onChangeSearchWithinMesh = e => {
                    this.setState({
                        searchWithinMesh: e
                    })
                }, this.state = {
                    loading: !1,
                    searchWithinMesh: !1
                }, this.props.keyboardListener.signals.down.add(this.onKeyDown, this)
            }
            close() {
                this.props.keyboardListener.signals.down.remove(this.onKeyDown, this), this.props.onClose()
            }
            onKeyDown(e) {
                e.keyCode === P.KEY_ESCAPE ? this.close() : e.keyCode === P.KEY_ENTER && this.onRunClick()
            }
            render() {
                var e = this.state["loading"];
                return u.createElement("div", {
                    className: "popup dark-panel",
                    ref: this.onMount
                }, u.createElement("div", {
                    className: "panel-header"
                }, u.createElement("div", {
                    className: "panel-title"
                }, "Remove Duplicate Geometries"), u.createElement("div", {
                    className: "panel-close",
                    onClick: this.onCloseClick
                })), u.createElement("div", {
                    className: "panel-content vbox",
                    style: {
                        minHeight: 140
                    }
                }, u.createElement("div", {
                    className: "flex_1"
                }, "Find duplicate geometries by comparing vertices, keeping only one in case of duplicates. This can help reduce the size and improve the rendering performance of models which have the same mesh copied multiple times for some reason.", u.createElement("br", null), u.createElement("br", null), u.createElement("br", null), "Note! This operation may take a long time and will freeze your browser."), u.createElement("div", {
                    className: "hbox hcenter"
                }, u.createElement(Rt, {
                    label: e ? "Loading..." : "Run",
                    onClick: this.onRunClick,
                    disabled: e
                }))))
            }
        }
        Hi.id = "removeDuplicateGeometryWindow";
        class Yi {
            static centerPivot(e, t) {
                this.iterateRenderNodes(e, t, e => {
                    var t = e.getBoundingBox().getCenter(),
                        s = M.R.negate(M.R.create(), t),
                        s = this.translateVertices(e, s);
                    return Pe(e.node, t), s
                })
            }
            static applyTranslation(r, e) {
                this.iterateRenderNodes(r, e, e => {
                    var t = r.transform.translation,
                        s = this.translateVertices(e, t.vec);
                    return Pe(e.node, M.R.negate(M.R.create(), t.vec)), s
                })
            }
            static applyTransform(e, t) {
                this.iterateRenderNodes(e, t, e => this.applyTransformToVertices(e, e.node.transform))
            }
            static iterateRenderNodes(e, t, s) {
                const r = new Set;
                H.traverseRenderNodes(e, e => {
                    var t = s(e);
                    for (const e of t) r.add(e)
                }), r.forEach(e => {
                    t.adapter.uploadBufferData(e)
                })
            }
            static applyTransformToVertices(e, i) {
                var s;
                const t = new Set,
                    r = e.geometry,
                    a = r.getAttribute(A.p.POSITION);
                if (a) {
                    const n = new N.s(a),
                        o = g.v.create(),
                        l = r.getAttribute(A.p.NORMAL);
                    if (l && 3 <= l.size) {
                        const i = new N.s(l),
                            s = E.x.getNormalMatrix(e.node.transform);
                        C.O.iterateIndexedVerticesOnce(r, e => {
                            var t = i.readToVec3(e, o);
                            g.v.transformDirection(t, t, s), i.writeVec3(e, t)
                        }), r.dataVersion++, l.buffer ? t.add(l.buffer) : console.warn("normalAttribute.buffer is undefined")
                    }
                    C.O.iterateIndexedVerticesOnce(r, t => {
                        const s = n.readToVec3(t, o),
                            r = M.R.transformMat4(s, s, i.mat);
                        for (let e = 0; e < a.size; ++e) {
                            const s = r[e];
                            n.writeAt(t, e, s)
                        }
                    }), null != (s = e.node) && s.transform.reset(), r.dataVersion++, t.add(a.buffer)
                }
                return Array.from(t)
            }
            static translateVertices(s, r) {
                const e = s.geometry,
                    i = e.getAttribute(A.p.POSITION);
                if (i) {
                    const s = new N.s(i);
                    return C.O.iterateIndexedVerticesOnce(e, t => {
                        for (let e = 0; e < i.size; ++e) {
                            const i = s.readAt(t, e) + r[e];
                            s.writeAt(t, e, i)
                        }
                    }), e.dataVersion++, [i.buffer]
                }
                return []
            }
        }

        function Pe(e, t) {
            var s = e.transform,
                s = S._.mul(S._.create(), s.mat, S._.fromTranslation(S._.create(), t));
            e.transform.setFromMatrix(s)
        }
        class ji {
            static convertToIndexed(e) {
                H.traverseRenderNodesOnce(e, this.convertRenderNodeToIndexed)
            }
            static convertRenderNodeToIndexed(e) {
                e.setGeometry(ji.convertGeometryToIndexed(e.geometry))
            }
            static convertToNonIndexed(e) {
                H.traverseRenderNodesOnce(e, this.convertRenderNodeToNonIndexed)
            }
            static convertRenderNodeToNonIndexed(e) {
                e.setGeometry(ji.convertGeometryToNonIndexed(e.geometry))
            }
            static convertGeometryToNonIndexed(e) {
                if (e.indexBuffer) {
                    var t = e.getAttributes().map(e => ({ ...e
                        })),
                        s = new Map;
                    let i = 0;
                    for (const e of t) i += e.size * ue._Z[e.componentType], s.set(e, new N.s(e));
                    const r = new ArrayBuffer(i * e.count),
                        n = new DataView(r);
                    let a = 0;
                    for (const o of t) {
                        const l = s.get(o),
                            h = ue.rg[o.componentType],
                            c = ue.oY.getBytesForType(o.componentType);
                        l && C.O.iterateIndexedVertices(e, (t, s) => {
                            for (let e = 0; e < o.size; ++e) {
                                const o = l.readAt(t, e),
                                    r = s * i;
                                h.call(n, a + r + e * c, o, !0)
                            }
                        }), o.byteOffset = a, o.byteStride = -1, a += c * o.size, o.count = e.count
                    }
                    t = new b.t({
                        buffer: new w.f({
                            data: n
                        }),
                        attributes: t
                    });
                    return new Z.Z({
                        buffers: [t],
                        mode: e.mode
                    })
                }
                return e
            }
            static convertGeometryToIndexed(t) {
                if (t.indexBuffer) return t;
                var s = t.count,
                    r = ue.oY.createIndexArray(s, s);
                for (let e = 0; e < s; ++e) r[e] = e + t.start;
                return new Z.Z({
                    indexBuffer: x.Y.fromData(r),
                    buffers: t.buffers,
                    mode: t.mode
                })
            }
        }
        class Ki {
            static separate(e, t, s) {
                t = new Ki(t, s);
                return H.traverseRenderNodes(e, t.separateRenderNode), t.result
            }
            constructor(e, t) {
                this._result = [], this.separateRenderNode = s => {
                    s.geometry.indexBuffer || s.setGeometry(ji.convertGeometryToIndexed(s.geometry));
                    const e = Gi.getMeshClusters(s.geometry);
                    if (1 < e.length) {
                        const a = s.geometry.indexBuffer;
                        if (a) {
                            var t = e.map(e => {
                                    var t = s.clone(!1, !1),
                                        e = xe.W.newTypedArray(a.data, e);
                                    return t.setGeometry(new Z.Z({
                                        indexBuffer: x.Y.fromData(e),
                                        buffers: t.geometry.buffers,
                                        mode: t.geometry.mode
                                    })), t
                                }),
                                r = s.node,
                                i = r.getParent() || r.scene;
                            if (!i) throw new Error("Parent not found");
                            for (const s of t) {
                                const e = new q.B({
                                    name: r.name,
                                    type: r.type,
                                    transform: r.transform.clone(),
                                    renderNodes: [s]
                                });
                                i.add(e), this._recenterMeshes && Yi.centerPivot(e, this._engine), this._result.push(e)
                            }
                            s.geometry.dispose(), s.detach()
                        }
                    }
                }, this._engine = e, this._recenterMeshes = t
            }
            get result() {
                return this._result
            }
        }
        class qi extends u.Component {
            constructor(e) {
                super(e), this.onRunClick = () => {
                    this.setState({
                        loading: !0
                    }), setTimeout(() => {
                        var e = Ki.separate(this.props.app.selection.getTarget(), this.props.app.engine, this.state.recenterMeshes);
                        this.props.app.setState({
                            selected: e[0] || null
                        }), this.close()
                    }, 400)
                }, this.onCloseClick = () => {
                    this.close()
                }, this.onMount = e => {
                    y.listenPopup(e, this.onCloseClick)
                }, this.onChangeRecenterMeshes = e => {
                    this.setState({
                        recenterMeshes: e
                    })
                }, this.state = {
                    loading: !1,
                    recenterMeshes: !1
                }, this.props.keyboardListener.signals.down.add(this.onKeyDown, this)
            }
            close() {
                this.props.keyboardListener.signals.down.remove(this.onKeyDown, this), this.props.onClose()
            }
            onKeyDown(e) {
                e.keyCode === P.KEY_ESCAPE ? this.close() : e.keyCode === P.KEY_ENTER && this.onRunClick()
            }
            render() {
                var e = this.state["loading"];
                return u.createElement("div", {
                    className: "popup dark-panel",
                    ref: this.onMount
                }, u.createElement("div", {
                    className: "panel-header"
                }, u.createElement("div", {
                    className: "panel-title"
                }, "Separate Geometries"), u.createElement("div", {
                    className: "panel-close",
                    onClick: this.onCloseClick
                })), u.createElement("div", {
                    className: "panel-content vbox",
                    style: {
                        minHeight: 140
                    }
                }, u.createElement("div", {
                    className: "flex_1"
                }, u.createElement("p", null, "Separate geometries by loose parts.", u.createElement("br", null), u.createElement("br", null), u.createElement(k, {
                    label: "Re-center pivot after"
                }, u.createElement(U, {
                    value: this.state.recenterMeshes,
                    onChange: this.onChangeRecenterMeshes
                })), u.createElement("br", null), "Note! This operation may take a long time and will freeze your browser. It might result in a huge buffer which may not be possible to upload depending on the model and your GPU.")), u.createElement("div", {
                    className: "hbox hcenter"
                }, u.createElement(Rt, {
                    label: e ? "Loading..." : "Run",
                    onClick: this.onRunClick,
                    disabled: e
                }))))
            }
        }
        class $i extends u.Component {
            constructor(e) {
                super(e), this.onMergeMaterialsClick = () => {
                    var e;
                    null != (e = this.props.app.popups) && e.open(Ii, {
                        app: this.props.app
                    })
                }, this.onMergeGeometryClick = () => {
                    var e;
                    null != (e = this.props.app.popups) && e.open(Fi, {
                        app: this.props.app
                    })
                }, this.onSeparateByLoosePartsClick = () => {
                    var e;
                    null != (e = this.props.app.popups) && e.open(qi, {
                        app: this.props.app
                    })
                }, this.state = {
                    menu: [{
                        id: "file",
                        label: "File",
                        children: [{
                            id: "fileNew",
                            label: "New"
                        }, {
                            id: "fileOpen",
                            label: "Open"
                        }, {
                            id: "fileImport",
                            label: "Import"
                        }, {
                            id: "fileSave",
                            label: "Save"
                        }]
                    }, {
                        id: "add",
                        label: "Add",
                        children: [{
                            label: "Mesh",
                            children: [{
                                id: "add_mesh",
                                options: "plane",
                                label: "Plane"
                            }, {
                                id: "add_mesh",
                                options: "cube",
                                label: "Cube"
                            }, {
                                separator: !0
                            }, {
                                id: "add_mesh",
                                options: "sphere",
                                label: "Sphere"
                            }, {
                                id: "add_mesh",
                                options: "disc",
                                label: "Disc"
                            }, {
                                id: "add_mesh",
                                options: "circle",
                                label: "Circle"
                            }]
                        }, {
                            label: "Light",
                            children: [{
                                id: "add_light",
                                label: "Point",
                                options: "point"
                            }, {
                                id: "add_light",
                                label: "Spot",
                                options: "spot"
                            }, {
                                id: "add_light",
                                label: "Directional",
                                options: "directional"
                            }]
                        }, {
                            id: "add_node",
                            label: "Node"
                        }]
                    }, {
                        id: "view_menu",
                        label: "View",
                        children: [{
                            id: "focus",
                            label: "Focus"
                        }, {
                            id: "lookAtCamera",
                            label: "Look at camera"
                        }, {
                            id: Li.ID,
                            label: "Wireframe",
                            checked: () => this.props.app.state.wireframe
                        }, {
                            id: Di.ID,
                            label: "View normals",
                            checked: () => this.props.app.state.viewNormals
                        }, {
                            id: "toggle_sampleProjects",
                            label: "Sample models",
                            checked: () => this.props.app.state.showWelcome
                        }, {
                            id: "toggle_animation",
                            label: "Animation",
                            checked: () => this.props.app.state.showAnimation
                        }, {
                            id: "toggle_fullscreen",
                            label: "Fullscreen",
                            checked: () => Si.isFullscreen(),
                            onSelect: () => Si.toggle()
                        }]
                    }, {
                        id: "tools",
                        label: "Tools",
                        children: [{
                            label: "Optimize",
                            children: [{
                                label: "Textures",
                                children: [{
                                    id: "resizeTexturesWindow",
                                    label: "Resize"
                                }, {
                                    id: zi.id,
                                    label: "Pack"
                                }]
                            }, {
                                separator: !0
                            }, {
                                label: "Merge materials",
                                onSelect: this.onMergeMaterialsClick
                            }, {
                                label: "Merge geometry",
                                onSelect: this.onMergeGeometryClick
                            }, {
                                label: "Separate by loose parts",
                                onSelect: this.onSeparateByLoosePartsClick
                            }, {
                                id: Hi.id,
                                label: "Remove duplicate geometry"
                            }, {
                                separator: !0
                            }, {
                                id: Oi.ID,
                                label: "Remove empty nodes"
                            }, {
                                id: Bi.ID,
                                label: "Remove invisible nodes"
                            }, {
                                separator: !0
                            }, {
                                id: Ui.ID,
                                label: "Collapse hierarchy"
                            }, {
                                id: Ui.ID,
                                label: "Collapse identity hierarchy",
                                options: !0
                            }]
                        }, {
                            label: "Normals",
                            children: [{
                                id: "flip_normals",
                                label: "Flip"
                            }, {
                                id: "recalculate_normals",
                                label: "Recalculate outside",
                                options: !0
                            }, {
                                id: "recalculate_normals",
                                label: "Recalculate inside",
                                options: !1
                            }, {
                                id: "normalize_normals",
                                label: "Normalize"
                            }, {
                                id: "remove_attribute",
                                label: "Remove normals",
                                options: A.p.NORMAL
                            }, {
                                id: "remove_attribute",
                                label: "Remove tangents",
                                options: A.p.TANGENT
                            }]
                        }, {
                            label: "Geometry",
                            children: [{
                                id: "flip_faces",
                                label: "Flip faces"
                            }, {
                                separator: !0
                            }, {
                                id: "convert_geometry",
                                label: "Convert to non-interleaved",
                                options: {
                                    interleaved: !1
                                }
                            }, {
                                id: "convert_geometry",
                                label: "Convert to interleaved",
                                options: {
                                    interleaved: !0
                                }
                            }, {
                                separator: !0
                            }, {
                                id: "convert_geometry",
                                label: "Convert to non-indexed",
                                options: {
                                    indexed: !1
                                }
                            }, {
                                id: "convert_geometry",
                                label: "Convert to indexed",
                                options: {
                                    indexed: !0
                                }
                            }, {
                                separator: !0
                            }, {
                                id: "convert_geometry",
                                label: "Convert to lines",
                                options: {
                                    mode: "lines"
                                }
                            }, {
                                id: "convert_geometry",
                                label: "Convert to points",
                                options: {
                                    mode: "points"
                                }
                            }]
                        }, {
                            label: "Transform",
                            children: [{
                                id: "transform",
                                options: "center_pivot",
                                label: "Center pivot"
                            }, {
                                id: "transform",
                                options: "apply_transform",
                                label: "Apply transform"
                            }, {
                                id: "transform",
                                options: "apply_translation",
                                label: "Apply translation"
                            }]
                        }, {
                            id: "open_duplicate_custom_window",
                            label: "Duplicate (Custom)"
                        }, {
                            id: "duplicate",
                            label: "Duplicate"
                        }]
                    }, {
                        id: "view_help",
                        label: "Help",
                        children: [{
                            id: "about",
                            label: "About"
                        }, {
                            id: "file_formats",
                            label: "File formats"
                        }, {
                            id: "gltf_support",
                            label: "glTF support"
                        }]
                    }]
                }
            }
            render() {
                return u.createElement("div", {
                    className: "HeaderPanel"
                }, u.createElement(Wt, {
                    app: this.props.app,
                    menu: this.state.menu
                }))
            }
        }
        class Xi extends z {
            constructor(e) {
                super(e), this.openFiles = e => {
                deploymodel(this._app);
                }, this.addShortcut({
                    ctrlMeta: !0,
                    keyCode: P.KEY_O
                })
            }
            execute(e) {
                p.P.openFileDialogue(!0, null, this.openFiles)
            }
        }
        Xi.ID = "fileOpen";
        class Zi {
            constructor() {
                this.json = {
                    asset: this.generateAsset(),
                    buffers: [],
                    bufferViews: [],
                    accessors: [],
                    scene: 0,
                    scenes: [],
                    nodes: [],
                    cameras: [],
                    meshes: [],
                    skins: [],
                    materials: [],
                    textures: [],
                    samplers: [],
                    images: [],
                    extensionsRequired: [],
                    extensionsUsed: [],
                    animations: []
                }
            }
            addScene(e) {
                return this.addToArray(e, this.json.scenes)
            }
            addNode(e) {
                return this.addToArray(e, this.json.nodes)
            }
            addMesh(e) {
                return this.addToArray(e, this.json.meshes)
            }
            addAccessor(e) {
                return this.addToArray(e, this.json.accessors)
            }
            addBufferView(e) {
                return this.addToArray(e, this.json.bufferViews)
            }
            addBufferConfig(e) {
                return this.addToArray(e, this.json.buffers)
            }
            addMaterial(e) {
                return this.addToArray(e, this.json.materials)
            }
            addToArray(e, t) {
                return t.push(e), t.length - 1
            }
            generateAsset() {
                return {
                    version: "2.0",
                    generator: "gltfeditor.com"
                }
            }
            getCleanJSON() {
                var e = J.g.clone(this.json, !1);
                for (const s in e) {
                    var t = e[s];
                    Array.isArray(t) && 0 === t.length && delete e[s]
                }
                return e
            }
            addRequiredExtension(e) {
                var t;
                this.addUsedExtension(e), null != (t = this.json.extensionsRequired) && t.includes(e) || (this.json.extensionsRequired = this.json.extensionsRequired || [], this.json.extensionsRequired.push(e))
            }
            addUsedExtension(e) {
                var t;
                null != (t = this.json.extensionsUsed) && t.includes(e) || (this.json.extensionsUsed = this.json.extensionsUsed || [], this.json.extensionsUsed.push(e))
            }
        }
        var Fe = c(8987),
            Le = c(4108),
            De = c(503),
            Oe = c(7375),
            Be = c(6040),
            Ue = c(433),
            ke = c(4815),
            ze = c(3707);
        class Ji {
            constructor(e) {
                this._exporter = e
            }
            exportMaterial(e) {
                var t = {
                        baseColorFactor: m.I.decomposeAndNormalizeRGBA(e.baseColorFactor, e.baseColorAlpha),
                        metallicFactor: e.metallicFactor,
                        roughnessFactor: e.roughnessFactor
                    },
                    s = this._exporter.getTextureInfo(e.baseColorTextureInfo, "base"),
                    r = this._exporter.getTextureInfo(e.metallicRoughnessTextureInfo, "metallicRoughness"),
                    s = (s && (t.baseColorTexture = s), r && (t.metallicRoughnessTexture = r), {
                        name: e.name || "",
                        pbrMetallicRoughness: t,
                        emissiveFactor: m.I.decomposeAndNormalizeRGB(e.emissiveFactor),
                        alphaMode: e.alphaMode,
                        doubleSided: e.side === fe.N.DOUBLE
                    }),
                    r = (1 !== e.emissiveStrength && (s.extensions = s.extensions || {}, s.extensions[Fe.O.ID] = {
                        emissiveStrength: e.emissiveStrength
                    }, this._exporter.jsonWriter.addUsedExtension(Fe.O.ID)), e.alphaMode === _e.mM.MASK && (s.alphaCutoff = e.alphaCutoff), this.getNormalTexture(e)),
                    t = this.getOcclusionTexture(e),
                    i = this._exporter.getTextureInfo(e.emissiveTextureInfo, "emissive"),
                    a = this._exporter.getTextureInfo(e.transmissionTextureInfo, "transmission"),
                    a = ((a || 0 < e.transmissionFactor) && (s.extensions = s.extensions || {}, s.extensions[Le.I.ID] = {
                        transmissionFactor: e.transmissionFactor,
                        ...a ? {
                            transmissionTexture: a
                        } : {}
                    }, this._exporter.jsonWriter.addUsedExtension(Le.I.ID)), this._exporter.getTextureInfo(e.sheenColorTextureInfo, "sheenColor")),
                    n = this._exporter.getTextureInfo(e.sheenRoughnessTextureInfo, "sheenRoughness"),
                    a = ((a || n || 0 < e.sheenColorFactor || 0 < e.sheenRoughnessFactor) && (s.extensions = s.extensions || {}, s.extensions[Oe.q.ID] = {
                        sheenColorFactor: m.I.decomposeAndNormalizeRGB(e.sheenColorFactor),
                        ...a ? {
                            sheenColorTexture: a
                        } : {},
                        sheenRoughnessFactor: e.sheenRoughnessFactor,
                        ...n ? {
                            sheenRoughnessTexture: n
                        } : {}
                    }, this._exporter.jsonWriter.addUsedExtension(Oe.q.ID)), this._exporter.getTextureInfo(e.clearcoatTextureInfo, "clearcoat")),
                    n = this._exporter.getTextureInfo(e.clearcoatRoughnessTextureInfo, "clearcoatRoughness"),
                    o = this._exporter.getTextureInfo(e.clearcoatNormalTextureInfo, "clearcoatNormal"),
                    a = ((0 < e.clearcoatFactor || 0 < e.clearcoatRoughnessFactor || a || n || o) && (s.extensions = s.extensions || {}, s.extensions[Be.o.ID] = {
                        clearcoatFactor: e.clearcoatFactor,
                        ...a ? {
                            clearcoatTexture: a
                        } : {},
                        clearcoatRoughnessFactor: e.clearcoatRoughnessFactor,
                        ...n ? {
                            clearcoatRoughnessTexture: n
                        } : {},
                        ...o ? {
                            clearcoatNormalTexture: o
                        } : {}
                    }, this._exporter.jsonWriter.addUsedExtension(Be.o.ID)), this._exporter.getTextureInfo(e.thicknessTextureInfo, "thickness")),
                    n = e.thicknessFactor,
                    o = ((a || 0 < e.thicknessFactor || 16777215 !== e.attenuationColor || e.attenuationDistance < 1 / 0) && (s.extensions = s.extensions || {}, s.extensions[Ue.n.ID] = { ...a ? {
                            thicknessTexture: a
                        } : {},
                        thicknessFactor: n,
                        attenuationColor: m.I.decomposeAndNormalizeRGB(e.attenuationColor),
                        attenuationDistance: e.attenuationDistance
                    }, this._exporter.jsonWriter.addUsedExtension(Ue.n.ID)), this._exporter.getTextureInfo(e.anisotropyTextureInfo, "anisotropy")),
                    a = e.anisotropyStrength,
                    n = e.anisotropyRotation,
                    a = (!o && 0 === e.anisotropyStrength && 0 === e.anisotropyRotation || (s.extensions = s.extensions || {}, s.extensions[ze.j.ID] = {
                        anisotropyStrength: a,
                        anisotropyRotation: n,
                        ...o ? {
                            anisotropyTexture: o
                        } : {}
                    }, this._exporter.jsonWriter.addUsedExtension(ze.j.ID)), this._exporter.getTextureInfo(e.specularTextureInfo, "specular")),
                    n = this._exporter.getTextureInfo(e.specularColorTextureInfo, "specularColor");
                return (a || n || 1 !== e.specularFactor || 16777215 !== e.specularColorFactor) && (s.extensions = s.extensions || {}, s.extensions[ke.w.ID] = {
                    specularFactor: e.specularFactor,
                    ...a ? {
                        specularTexture: a
                    } : {},
                    specularColorFactor: m.I.decomposeAndNormalizeRGB(e.specularColorFactor),
                    ...n ? {
                        specularColorTexture: n
                    } : {}
                }, this._exporter.jsonWriter.addUsedExtension(ke.w.ID)), e.ior !== De.H.defaultIOR && (s.extensions = s.extensions || {}, s.extensions[De.H.ID] = {
                    ior: e.ior
                }, this._exporter.jsonWriter.addUsedExtension(De.H.ID)), r && (s.normalTexture = r), t && (s.occlusionTexture = t), i && (s.emissiveTexture = i), e.side === fe.N.BACK && console.warn("GLTF doesn't support back sided materials"), s
            }
            getOcclusionTexture(e) {
                var t = this._exporter.getTextureInfo(e.occlusionTextureInfo, "occlusion");
                return t ? { ...t,
                    strength: e.occlusionStrength
                } : null
            }
            getNormalTexture(e) {
                var t = this._exporter.getTextureInfo(e.normalTextureInfo, "normal");
                return t ? { ...t,
                    scale: e.normalScale
                } : null
            }
        }
        var Ve = c(8402);
        class Qi {
            constructor(e) {
                this._exporter = e
            }
            addAnimation(e) {}
            serializeChannel(e) {}
        }
        var Ge = c(9421);
        class ea {
            constructor(e) {
                this._exporter = e
            }
            exportMaterial(e) {
                var t = {};
                if (e instanceof Fs) t.baseColorFactor = m.I.decomposeAndNormalizeRGBA(e.color, e.opacity);
                else {
                    t.baseColorFactor = m.I.decomposeAndNormalizeRGBA(e.baseColorFactor, e.baseColorAlpha);
                    const s = this._exporter.getTextureInfo(e.baseColorTextureInfo, "base");
                    s && (t.baseColorTexture = s)
                }
                const s = {
                    pbrMetallicRoughness: t,
                    emissiveFactor: m.I.decomposeAndNormalizeRGB(e.emissiveFactor),
                    alphaMode: e.alphaMode,
                    doubleSided: e.side === fe.N.DOUBLE,
                    extensions: {
                        KHR_materials_unlit: {}
                    }
                };
                return e.alphaMode === _e.mM.MASK && (s.alphaCutoff = e.alphaCutoff), e.side === fe.N.BACK && console.warn("GLTF doesn't support back sided materials"), this._exporter.jsonWriter.addRequiredExtension(Ge.W.ID), s
            }
        }
        var We = c(3960),
            He = c(3205),
            Ye = c(8396),
            je = c(4155),
            Ke = c(6385);
        class ta {
            constructor() {
                this._useWasm = !1
            }
            static supports(e) {
                return e.mode === _.g.TRIANGLES && e.hasAttribute(A.p.POSITION)
            }
            static loadModule() {
                return new Promise(async t => {
                    (0, (await c.e(446).then(c.t.bind(c, 5446, 23))).default)({
                        onModuleLoaded: e => {
                            this.encoder = e, t()
                        }
                    })
                })
            }
            static exportGeometry(e, t, s) {
                t.jsonWriter.addRequiredExtension(Ke.T.ID);
                var r = {
                    mode: (e = e.indexBuffer ? e : ji.convertGeometryToIndexed(e)).mode,
                    attributes: {}
                };
                for (const s of e.getAttributes()) {
                    const e = je.g.calculateAttributeMinMax(s),
                        i = {
                            componentType: s.componentType,
                            normalized: s.normalized,
                            count: s.count,
                            max: e.max,
                            min: e.min,
                            type: Ye.s.accessorSize2type(s.size)
                        },
                        a = t.jsonWriter.addAccessor(i);
                    r.attributes = r.attributes || {}, r.attributes[s.semantic] = a
                }
                const {
                    data: i,
                    attributes: a
                } = this.encode(e), {
                    bufferId: n,
                    byteOffset: o
                } = s.addBuffer(i.buffer), l = {
                    bufferView: t.jsonWriter.addBufferView({
                        buffer: n,
                        byteOffset: o,
                        byteLength: i.byteLength
                    }),
                    attributes: a
                };
                return r.extensions = r.extensions || {}, r.extensions.KHR_draco_mesh_compression = l, r
            }
            static encode(e) {
                const t = this.encoder,
                    s = new t.MeshBuilder,
                    r = new t.Mesh,
                    i = ue.oY.calculateNumberOfPrimitives(e.count, e.mode),
                    a = e.vertexCount,
                    n = this.readIndices(e);
                n && s.AddFacesToMesh(r, i, n);
                var o = {
                        [_.g.FLOAT]: s.AddFloatAttribute,
                        [_.g.BYTE]: s.AddInt8Attribute,
                        [_.g.SHORT]: s.AddInt16Attribute,
                        [_.g.INT]: s.AddInt32Attribute,
                        [_.g.UNSIGNED_BYTE]: s.AddUInt8Attribute,
                        [_.g.UNSIGNED_SHORT]: s.AddUInt16Attribute,
                        [_.g.UNSIGNED_INT]: s.AddUInt32Attribute
                    },
                    l = {};
                let h = 0;
                for (const i of e.getAttributes()) {
                    const n = o[i.componentType];
                    var c = i.semantic === A.p.POSITION ? t.POSITION : i.semantic === A.p.NORMAL ? t.NORMAL : A.p.isTexCoord(i.semantic) ? t.TEX_COORD : i.semantic === A.p.COLOR ? t.COLOR : t.GENERIC;
                    if (Boolean(n) && f.M.isValidNumber(c)) {
                        const t = N.s.readIntoTypedArray(e, i.semantic);
                        s.AddFloatAttribute(r, c, a, i.size, t), l[i.semantic] = h, h++
                    }
                }
                var d = new t.Encoder,
                    u = new t.DracoInt8Array,
                    p = d.EncodeMeshToDracoBuffer(r, u),
                    m = new Int8Array(new ArrayBuffer(p));
                for (let e = 0; e < p; ++e) m[e] = u.GetValue(e);
                return t.destroy(r), t.destroy(d), t.destroy(s), {
                    data: m,
                    attributes: l
                }
            }
            static readIndices(e) {
                if (e.indexBuffer) {
                    e = e.indexBuffer.data;
                    if (e instanceof Uint16Array || e instanceof Uint32Array) return e;
                    if (e instanceof Uint8Array) return new Uint16Array(e.map(e => e));
                    throw new Error("indexbuffer.data type not supported: " + e)
                }
                return null
            }
        }
        var qe = c(6504);
        class sa {
            constructor(e) {
                this._geometries = new Map, this._buffersById = new Map, this._bufferFiles = new Map, this._exporter = e
            }
            prepare(e) {
                var t = new Set,
                    e = (this.collectGeometries(e, t), f.M.sum(Array.from(t), e => f.M.nextMultiple(e.getTotalByteSize(), 4))),
                    t = new Me.c(e);
                this._allGeometries = {
                    writer: t,
                    bufferResult: this.addBuffer(t.buffer)
                }
            }
            collectGeometries(e, t) {
                e.renderNodes.forEach(e => t.add(e.geometry)), e.children.forEach(e => this.collectGeometries(e, t))
            }
            exportGeometry(e) {
                let t = this._geometries.get(e);
                return t || (t = this.addGeometry(e), this._geometries.set(e, t)), t
            }
            addGeometry(e) {
                var t, s, r;
                return "draco" === this._exporter.options.geometryCompression && ta.supports(e) ? ta.exportGeometry(e, this._exporter, this) : (t = {
                    mode: e.mode
                }, this._allGeometries ? this.writeGeometryToBuffer(e, this._allGeometries.bufferResult, t, this._allGeometries.writer) : (s = new Me.c(e.getTotalByteSize()), r = this.addBuffer(s.buffer), this.writeGeometryToBuffer(e, r, t, s)), t)
            }
            writeGeometryToBuffer(t, {
                bufferId: s,
                byteOffset: i
            }, a, n) {
                {
                    n.byteOffset = f.M.nextMultiple(n.byteOffset, 4);
                    let r = n.byteOffset;
                    for (const g of t.buffers) {
                        var o = g.getByteStrideAligned(),
                            l = o * t.vertexCount,
                            h = this._exporter.addBufferView({
                                buffer: s,
                                byteOffset: r + i,
                                byteLength: l,
                                byteStride: o,
                                target: _.g.ARRAY_BUFFER
                            });
                        let e = 0;
                        for (const t of g.attributes) {
                            const s = je.g.calculateAttributeMinMax(t),
                                i = {
                                    bufferView: h,
                                    byteOffset: e,
                                    componentType: t.componentType,
                                    normalized: t.normalized,
                                    count: t.count,
                                    min: s.min,
                                    max: s.max,
                                    type: Ye.s.accessorSize2type(t.size)
                                },
                                n = (e += ue.oY.getAttributeByteSize(t), this._exporter.jsonWriter.addAccessor(i));
                            if (0 === t.semantic.indexOf(A.p.MORPH_PREFIX)) {
                                const {
                                    index: s,
                                    semantic: i
                                } = A.p.decomposeMorph(t.semantic);
                                a.targets = a.targets || [], a.targets[s] = a.targets[s] || {}, a.targets[s][i] = n
                            } else a.attributes = a.attributes || {}, a.attributes[t.semantic] = n;
                            t.componentType !== _.g.FLOAT && this._exporter.jsonWriter.addRequiredExtension(qe._.ID)
                        }
                        var c = g.attributes.map(e => new N.s(e));
                        for (let s = 0; s < g.count; ++s) {
                            let t = 0;
                            for (const i of c) {
                                const a = ue._Z[i.attribute.componentType];
                                for (let e = 0; e < i.attribute.size; ++e) {
                                    var d = i.readAt(s, e),
                                        u = r + t + s * o + e * a;
                                    n.write(d, i.attribute.componentType, u)
                                }
                                t += a * i.attribute.size
                            }
                        }
                        r += l, n.byteOffset = r
                    }
                    const m = t.indexBuffer;
                    var e, p;
                    m && (p = this._exporter.addBufferView({
                        buffer: s,
                        byteOffset: n.byteOffset + i,
                        byteLength: t.getIndexByteSize(),
                        target: _.g.ELEMENT_ARRAY_BUFFER
                    }), e = je.g.calculateMinMaxIndex(t), p = {
                        bufferView: p,
                        byteOffset: 0,
                        componentType: m.componentType,
                        normalized: !1,
                        count: t.count,
                        min: e ? e.min : void 0,
                        max: e ? e.max : void 0,
                        type: "SCALAR"
                    }, a.indices = this._exporter.jsonWriter.addAccessor(p), C.O.iterateIndices(t, e => {
                        n.write(e, m.componentType)
                    })), this._exporter.options.embedBuffers && !this._exporter.glbExporter && this.updateBufferUri(s)
                }
            }
            addBuffer(e) {
                var t;
                return this._exporter.glbExporter && this._exporter.options.embedBuffers ? (t = this._exporter.glbExporter.addArrayBuffer(e)["byteOffset"], {
                    bufferId: 0,
                    byteOffset: t
                }) : (t = {
                    uri: this.createBufferUri(e),
                    byteLength: e.byteLength
                }, t = this._exporter.jsonWriter.addBufferConfig(t), this._buffersById.set(t, e), {
                    bufferId: t,
                    byteOffset: 0
                })
            }
            updateBufferUri(e) {
                var t, s = null == (t = this._exporter.jsonWriter.json.buffers) ? void 0 : t[e];
                if (s) {
                    const t = this._buffersById.get(e);
                    t && (s.uri = this.createBufferUri(t))
                }
            }
            createBufferUri(e) {
                var t;
                return this._exporter.options.embedBuffers ? xe.W.arraybuffer2base64uri(e) : (t = this._exporter.getMainName() + ".bin", t = this._exporter.reserveUniqueFileName(t, this._bufferFiles), this._bufferFiles.set(t, e), t)
            }
            get bufferFiles() {
                return this._bufferFiles
            }
        }
        var $e = c(5396);
        class ra {
            constructor(e) {
                if (this._textureSources = new Map, this._textures = new Map, this._materialExporters = new Map, this._materials = new Map, this._meshMap = new Map, this._imageFiles = new Map, this._preparationPromises = [], this._promises = [], this._options = e, this._mainName = e.mainName || "", this._jsonWriter = new Zi, this._geometryExporter = new sa(this), this._options.binary && (this._glbExporter = new Ve.c(this)), "draco" === this._options.geometryCompression) {
                    const e = ta.loadModule();
                    this._preparationPromises.push(e), this._promises.push(e)
                }
                this._materialExporters.set(o.q, new Ji(this)), this._materialExporters.set(ve.z, new ea(this)), this._materialExporters.set(Fs, new ea(this))
            }
            addCopyright(e) {
                e = e.asset;
                this._jsonWriter.json.asset = J.g.cloneViaJson(e), this._options.overrideGenerator && (this._jsonWriter.json.asset.generator = _t.defaultGenerator)
            }
            async addScene(e) {
                this._mainName = this._mainName || e.name, await Promise.all(this._preparationPromises), this._geometryExporter.prepare(e);
                var t = {
                    nodes: this.addNodes(e)
                };
                e.name && (t.name = e.name), this._jsonWriter.addScene(t)
            }
            addAnimation(e) {
                new Qi(this).addAnimation(e)
            }
            addNodes(e) {
                return e.children.map(e => this.addNode(e))
            }
            addNode(e) {
                e = this.getNodeConfig(e);
                return this._jsonWriter.addNode(e)
            }
            getNodeConfig(e) {
                var t = {},
                    s = (e.name && (t.name = e.name), this.addNodes(e));
                return 0 < s.length && (t.children = s), e.transform.isIdentity() || (this._options.useTRS ? (t.translation = M.R.copy([], e.transform.translation.vec), t.rotation = g.v.copy([], e.transform.rotation.vec), t.scale = M.R.copy([], e.transform.scale.vec)) : t.matrix = S._.copy([], e.transform.mat)), this._options.visibility && (this.jsonWriter.addUsedExtension($e.V.ID), t.extensions = t.extensions || {}, t.extensions.KHR_node_visibility = {
                    visible: e.visible
                }), this.addMesh(e, t), this.addCamera(e, t), this.addLight(e, t), t
            }
            addMesh(e, t) {
                if (0 < e.renderNodes.length) {
                    var s = {
                        primitives: []
                    };
                    e.morphWeights && (s.weights = e.morphWeights);
                    for (const t of e.renderNodes) {
                        const e = {
                            material: this.addMaterial(t),
                            ...this._geometryExporter.exportGeometry(t.geometry)
                        };
                        s.primitives.push(e)
                    }
                    var r = JSON.stringify(s);
                    if (this._meshMap.has(r)) t.mesh = this._meshMap.get(r);
                    else {
                        const e = this._jsonWriter.addMesh(s);
                        this._meshMap.set(r, e), t.mesh = e
                    }
                }
            }
            addBufferView(e) {
                return void 0 !== e.byteStride && (e.byteStride % 4 != 0 || e.byteStride < 4) && console.warn("byteStride should be at least 4 and multiple of 4! Given: " + e.byteStride), this.jsonWriter.addBufferView(e)
            }
            addMaterial(e) {
                var t, s = e.material,
                    r = this.materials.get(s);
                if (f.M.isValidNumber(r)) return r; {
                    const e = this._materialExporters.get(be.h.getClass(s));
                    if (e) return t = e.exportMaterial(s), r = this.jsonWriter.addMaterial(t), this.materials.set(s, r), r;
                    throw new Error("Material exporter not found for material: " + s)
                }
            }
            getTextureInfo(e, t = "") {
                var s = e.texture;
                return s ? {
                    index: this.addTexture(s, t),
                    texCoord: e.channel,
                    ...this.addTextureTransform(e.transform)
                } : null
            }
            addTextureTransform(e) {
                return e.isIdentity() ? null : (e = {
                    scale: [e.sx, e.sy],
                    offset: [e.tx, e.ty],
                    rotation: e.rotation
                }, this.jsonWriter.addRequiredExtension(We.j.ID), {
                    extensions: {
                        KHR_texture_transform: e
                    }
                })
            }
            addTexture(e, t = "") {
                var s, r, i;
                let a = this._textures.get(e);
                return f.M.isValidNumber(a) || (i = {
                    magFilter: e.sampler.magFilter,
                    minFilter: e.sampler.minFilter,
                    wrapS: e.sampler.wrapS,
                    wrapT: e.sampler.wrapT
                }, t = e.image.name || t, i = this.jsonWriter.addToArray(i, this.jsonWriter.json.samplers), s = this.addTextureSource(e, t), r = na(this._options.imageSettings, e).mimeType, i = {
                    sampler: i,
                    name: (null == (i = this._jsonWriter.json.images[s]) ? void 0 : i.name) || t
                }, "image/webp" === r ? (i.extensions = i.extensions || {}, i.extensions.EXT_texture_webp = {
                    source: s
                }, this.jsonWriter.addRequiredExtension("EXT_texture_webp")) : i.source = s, a = this.jsonWriter.addToArray(i, this.jsonWriter.json.textures), this._textures.set(e, a)), a
            }
            addTextureSource(e, t = "") {
                let s = this._textureSources.get(e);
                if (!f.M.isValidNumber(s)) {
                    const i = na(this._options.imageSettings, e),
                        a = ra.ensureFileNameExtension(t, "image", i.extension),
                        n = this._glbExporter;
                    if (n && this._options.embedImages) {
                        const t = {
                            bufferView: void 0,
                            mimeType: i.mimeType,
                            name: a
                        };
                        s = this.jsonWriter.addToArray(t, this.jsonWriter.json.images), this._textureSources.set(e, s);
                        var r = v.O.readIntoArraybuffer(e, i).then(e => {
                            t.bufferView = n.addTexture(e, a)
                        });
                        this._promises.push(r)
                    } else {
                        const t = {
                            uri: this.createTextureUri(e, i, a),
                            mimeType: i.mimeType,
                            name: a
                        };
                        s = this.jsonWriter.addToArray(t, this.jsonWriter.json.images), this._textureSources.set(e, s)
                    }
                }
                return s
            }
            createTextureUri(s, r, i) {
                if (this._options.embedImages) return v.O.readIntoCanvas({
                    texture: s
                }).toDataURL(r.mimeType, r.quality);
                i = this.reserveUniqueFileName(i, this._imageFiles);
                var e = new Promise((t, e) => {
                    v.O.readIntoBlob({
                        texture: s
                    }, r).then(e => {
                        this._imageFiles.set(i, e), t()
                    })
                });
                return this._promises.push(e), i
            }
            reserveUniqueFileName(e, t) {
                let s = 0;
                for (; t.get(e) || null === t.get(e);) s++, e = ra.findNewFileName(e, s);
                return t.set(e, null), e
            }
            static ensureFileNameExtension(e, t, s) {
                let r = (e = p.P.removeExtension(e)) || t + "_1." + s;
                return -1 === r.indexOf(".") && (r += "." + s), r
            }
            static findNewFileName(e, t) {
                var e = e.split("."),
                    s = e.slice(0, -1).join("."),
                    e = e[e.length - 1],
                    r = s.split("_");
                return 1 < r.length ? r.slice(0, -1).join("_") + `_${t}.` + e : s + `_${t}.` + e
            }
            addCamera(e, t) {}
            addLight(t, s) {
                if (this._options.lights && t.light) {
                    this.jsonWriter.addRequiredExtension(He.X.ID);
                    var r = this._jsonWriter.json;
                    r.extensions = r.extensions || {}, r.extensions.KHR_lights_punctual = r.extensions.KHR_lights_punctual || {
                        lights: []
                    };
                    let e = r.extensions.KHR_lights_punctual.lights.indexOf(t.light);
                    if (-1 === e) {
                        const s = this.serializeLight(t.light);
                        e = this._jsonWriter.addToArray(s, r.extensions.KHR_lights_punctual.lights)
                    }
                    t = s;
                    t.extensions = t.extensions || {}, t.extensions.KHR_lights_punctual = {
                        light: e
                    }
                }
            }
            serializeLight(e) {
                var t, s = {
                    name: e.name,
                    type: e.type,
                    color: e.color,
                    intensity: e.intensity
                };
                return "spot" !== e.type && "point" != e.type || (s.range = e.range, "spot" === e.type && (s.spot = {
                    innerConeAngle: null == (t = e.spot) ? void 0 : t.innerConeAngle,
                    outerConeAngle: null == (t = e.spot) ? void 0 : t.outerConeAngle
                })), s
            }
            get jsonWriter() {
                return this._jsonWriter
            }
            getJSONString(e = !1) {
                return JSON.stringify(this.jsonWriter.getCleanJSON(), null, e ? void 0 : 2)
            }
            getFileName() {
                var e = this._glbExporter ? "glb" : "gltf";
                return this.getMainName() + "." + e
            }
            getMainName() {
                return this._mainName || "untitled"
            }
            async getFile() {
                return new Promise(async (e, t) => {
                    await Promise.all(this._promises), 0 === this._imageFiles.size && 0 === this._geometryExporter.bufferFiles.size ? e(this.createFile()) : e(this.createZipFile())
                })
            }
            createFile() {
                var e;
                return this._glbExporter ? this._glbExporter.createFile() : (e = this.getJSONString(), new File([e], this.getFileName(), {
                    type: "model/gltf+json",
                    lastModified: Date.now()
                }))
            }
            async createZipFile() {
                const s = new(await c.e(578).then(c.t.bind(c, 2882, 23))).default,
                    e = this.getFileName(),
                    t = p.P.changeExtension(e, "zip");
                s.file(this.getFileName(), this.createFile()), this._imageFiles.forEach((e, t) => {
                    s.file(t, e)
                }), this._geometryExporter.bufferFiles.forEach((e, t) => {
                    s.file(t, e)
                });
                var r = await s.generateAsync({
                    type: "blob"
                });
                return new File([r], t, {
                    type: "application/zip",
                    lastModified: Date.now()
                })
            }
            get materials() {
                return this._materials
            }
            get options() {
                return this._options
            }
            get glbExporter() {
                return this._glbExporter
            }
        }
        const ia = {
                "image/jpeg": "jpg",
                "image/png": "png",
                "image/webp": "webp"
            },
            aa = {
                jpg: "image/jpeg",
                png: "image/png",
                webp: "image/webp"
            },
            na = (e, t) => {
                var s = aa[e.format] || "image/png";
                return {
                    mimeType: s,
                    quality: e.quality,
                    extension: ia[s] || "png"
                }
            };
        class oa {
            constructor(e) {
                this._options = e
            }
            addScene(e) {
                this._scene = e
            }
            addNode(e) {}
            getSceneName() {
                var e;
                return (null == (e = this._scene) ? void 0 : e.name) || "model"
            }
            addCopyright(e) {}
            addAnimation(e) {}
            get options() {
                return this._options
            }
        }
        class la {
            constructor() {
                this.content = "", this.counters = {
                    vertex: 0,
                    normal: 0,
                    uv: 0,
                    face: 0
                }
            }
            addCopyright(e) {
                this.content = `# ${e}.
` + this.content
            }
            addComment(e) {
                this.content += `# ${e}
`
            }
            addV3(e, t, s) {
                this.content += `v ${e} ${t} ` + s, this.content += "\n", this.counters.vertex++
            }
            addV4(e, t, s, r) {
                this.content += `v ${e} ${t} ${s} ` + r, this.addLine(), this.counters.vertex++
            }
            addVN3(e, t, s) {
                this.content += `vn ${e} ${t} ` + s, this.content += "\n", this.counters.normal++
            }
            addVT2(e, t) {
                this.content += `vt ${e} ` + t, this.addLine(), this.counters.uv++
            }
            addVT3(e, t, s) {
                this.content += `vt ${e} ${t} ` + s, this.addLine(), this.counters.uv++
            }
            addFaceV(e, t, s) {
                this.content += `f ${e} ${t} ` + s, this.addLine(), this.counters.face++
            }
            addFaceVT(e, t, s, r, i, a) {
                this.content += `f ${e}/${r} ${t}/${i} ${s}/` + a, this.addLine(), this.counters.face++
            }
            addFaceVTN(e, t, s, r, i, a, n, o, l) {
                this.content += `f ${e}/${r}/${n} ${t}/${i}/${o} ${s}/${a}/` + l, this.addLine(), this.counters.face++
            }
            addFaceVN(e, t, s, r, i, a) {
                this.content += `f ${e}//${r} ${t}//${i} ${s}//` + a, this.addLine(), this.counters.face++
            }
            addLine() {
                this.content += "\n"
            }
        }
        class ha extends oa {
            constructor(e) {
                super(e), this._objWriter = new la, this._tmp = g.v.create(), this._currentAttributes = ha.resetAttributes(), this._currentCounters = J.g.cloneViaJson(this._objWriter.counters), this._currentWorldMatrix = S._.create(), this._currentNormalMatrix = S._.create()
            }
            static resetAttributes() {
                return {
                    normal: !1,
                    uv: !1
                }
            }
            write() {
                this._scene && this.traverse(this._scene)
            }
            traverse(e) {
                this.writeNode(e);
                for (const t of e.children) this.traverse(t)
            }
            writeNode(e) {
                for (const t of e.renderNodes) this.writeRenderNode(t)
            }
            writeRenderNode(e) {
                var t = e.geometry,
                    s = t.getAttribute(A.p.POSITION);
                s && 3 <= s.size && (this._currentWorldMatrix = e.node.calculateWorldMatrix(), this._currentNormalMatrix = this._currentWorldMatrix, this._currentAttributes = ha.resetAttributes(), this._currentCounters = J.g.cloneViaJson(this._objWriter.counters), this._objWriter.addComment(`Mesh: ${e.node.name||"unnamed"} (${e.node.id})`), this._objWriter.addComment(`Geometry: ${t.name||"unnamed"} (${t.id})`), this.exportPositions(s, t), this.exportNormals(t), this.exportUVs(e), this.exportFaces(t))
            }
            exportPositions(e, t) {
                const s = new N.s(e);
                4 === e.size ? C.O.iterateVertices(t, e => {
                    e = s.readToVec4(e, this._tmp);
                    g.v.transformMat4(e, e, this._currentWorldMatrix), this._objWriter.addV4(e[0], e[1], e[2], e[3])
                }) : C.O.iterateVertices(t, e => {
                    e = s.readPointToVec4(e, this._tmp);
                    g.v.transformMat4(e, e, this._currentWorldMatrix), this._objWriter.addV3(e[0], e[1], e[2])
                })
            }
            exportNormals(e) {
                var t = e.getAttribute(A.p.NORMAL);
                if (t && 3 <= t.size) {
                    this._currentAttributes.normal = !0;
                    const s = new N.s(t);
                    C.O.iterateVertices(e, e => {
                        e = s.readToVec3(e, this._tmp);
                        this._objWriter.addVN3(e[0], e[1], e[2])
                    })
                }
            }
            exportUVs(e) {
                if ((e.material instanceof o.q || e.material instanceof ve.z) && e.material.baseColorTextureInfo.texture) {
                    var t = e.material.baseColorTextureInfo.channel,
                        t = e.geometry.getAttribute(A.p.TEXCOORD_0 + t);
                    if (t) {
                        const s = new N.s(t);
                        2 === t.size ? (this._currentAttributes.uv = !0, C.O.iterateVertices(e.geometry, e => {
                            e = s.readToVec2(e, this._tmp);
                            this._objWriter.addVT2(e[0], e[1])
                        })) : 3 === t.size && (this._currentAttributes.uv = !0, C.O.iterateVertices(e.geometry, e => {
                            e = s.readToVec3(e, this._tmp);
                            this._objWriter.addVT3(e[0], e[1], e[2])
                        }))
                    }
                }
            }
            exportFaces(e) {
                this._currentAttributes.normal && this._currentAttributes.uv ? this.exportFacesVTN(e) : this._currentAttributes.normal ? this.exportFacesVN(e) : this._currentAttributes.uv ? this.exportFacesVT(e) : this.exportFacesV(e)
            }
            exportFacesV(e) {
                const r = this._currentCounters.vertex + 1;
                C.O.iterateTriangles(e, (e, t, s) => {
                    this._objWriter.addFaceV(e + r, t + r, s + r)
                })
            }
            exportFacesVTN(e) {
                const r = this._currentCounters.vertex + 1,
                    i = this._currentCounters.uv + 1,
                    a = this._currentCounters.normal + 1;
                C.O.iterateTriangles(e, (e, t, s) => {
                    this._objWriter.addFaceVTN(e + r, t + r, s + r, e + i, t + i, s + i, e + a, t + a, s + a)
                })
            }
            exportFacesVN(e) {
                const r = this._currentCounters.vertex + 1,
                    i = this._currentCounters.normal + 1;
                C.O.iterateTriangles(e, (e, t, s) => {
                    this._objWriter.addFaceVN(e + r, t + r, s + r, e + i, t + i, s + i)
                })
            }
            exportFacesVT(e) {
                const r = this._currentCounters.vertex + 1,
                    i = this._currentCounters.uv + 1;
                C.O.iterateTriangles(e, (e, t, s) => {
                    this._objWriter.addFaceVT(e + r, t + r, s + r, e + +i, t + +i, s + +i)
                })
            }
            addCopyright(e) {
                e = e.asset.generator || _t.defaultGenerator;
                this._objWriter.addCopyright(e)
            }
            async getFile() {
                return this.write(), new Promise(async (e, t) => {
                    e(this.createFile())
                })
            }
            createFile() {
                return new File([this._objWriter.content], this.getFileName(), {
                    type: "text/plain",
                    lastModified: Date.now()
                })
            }
            getFileName() {
                var e;
                return `${(null==(e=this._scene)?void 0:e.name)||"model"}.obj`
            }
        }
        var Xe = c(4427);
        class ca {
            constructor() {
                this._name = "", this._generator = "", this._vertexData = [], this._numberOfTriangles = 0
            }
            begin(e) {
                this._name = e
            }
            addTriangleFace(e, t, s, r) {
                this._vertexData.push(r[0], r[1], r[2], e[0], e[1], e[2], t[0], t[1], t[2], s[0], s[1], s[2])
            }
            addCopyright(e) {
                this._generator = e.asset.generator || _t.defaultGenerator
            }
            end() {
                this._numberOfTriangles = this._vertexData.length / 12, this._bufferWriter = this.createBuffer(), this.writeHeader(this._bufferWriter), this.writeTriangles(this._bufferWriter)
            }
            createBuffer() {
                var e = 50 * this._numberOfTriangles,
                    e = Xe.W + 4 + e;
                return new Me.c(e)
            }
            writeHeader(t) {
                var s = `solid ${this._name} ${this._generator}.`;
                for (let e = 0; e < Xe.W; e++) t.dataView.setUint8(e, s.charCodeAt(e) || 0);
                t.byteOffset = Xe.W, t.writeUint32(this._numberOfTriangles)
            }
            writeTriangles(t) {
                for (let e = 0; e < this._vertexData.length; e++) t.writeFloat32(this._vertexData[e]), e % 12 == 11 && t.writeUint16(0)
            }
            createFile(e) {
                if (this._bufferWriter) return new File([this._bufferWriter.dataView.buffer], e, {
                    type: Xe.J,
                    lastModified: Date.now()
                });
                throw new Error("No buffer created")
            }
        }
        class da {
            constructor() {
                this._name = "", this._content = ""
            }
            begin(e) {
                this._name = e
            }
            addTriangleFace(e, t, s, r) {
                this._content += `facet normal ${r[0]} ${r[1]} ${r[2]}
`, this._content += "\touter loop\n", this._content += `		vertex ${e[0]} ${e[1]} ${e[2]}
`, this._content += `		vertex ${t[0]} ${t[1]} ${t[2]}
`, this._content += `		vertex ${s[0]} ${s[1]} ${s[2]}
`, this._content += "\tendloop\n", this._content += "endfacet\n"
            }
            addCopyright(e) {
                e = e.asset.generator || _t.defaultGenerator;
                this._content = `solid ${this._name} ${e}.
` + this._content
            }
            end() {
                this._content += `endsolid ${this._name}
`
            }
            createFile(e) {
                return new File([this._content], e, {
                    type: Xe.J,
                    lastModified: Date.now()
                })
            }
        }
        const ua = M.R.create(),
            pa = M.R.create(),
            ma = M.R.create();
        class ga {
            static area(e, t, s) {
                t = M.R.sub(pa, t, e), s = M.R.sub(ma, s, e), e = M.R.cross(ua, t, s);
                return .5 * M.R.magnitude(e)
            }
        }
        class _a {
            static recalculate(e, t, s = !0) {
                const r = new Set;
                H.traverseRenderNodesOnce(e, e => {
                    e = this.recalculateRenderNode(e, s);
                    e && r.add(e)
                }), r.forEach(e => {
                    t.adapter.uploadBufferData(e)
                })
            }
            static recalculateRenderNode(s, t) {
                var r;
                this.addNormalAttribute(s);
                const i = s.geometry,
                    a = i.getAttribute(A.p.POSITION),
                    n = i.getAttribute(A.p.NORMAL);
                if (i.mode === _.g.TRIANGLES && a && n) {
                    const l = new N.s(a),
                        h = new N.s(n),
                        c = t ? 1 : -1,
                        d = null == (r = i.indexBuffer) ? void 0 : r.data,
                        u = new Map,
                        p = new Map,
                        m = new Map; {
                        {
                            const s = M.R.create(),
                                t = M.R.create(),
                                r = M.R.create(),
                                a = M.R.create(),
                                n = M.R.create();
                            for (let e = 0; e < i.count; ++e) {
                                const c = i.start + e,
                                    A = d ? d[c] : c;
                                u.has(A) || u.set(A, new Set);
                                var o = Math.floor(e / 3);
                                if (u.get(A).add(o), e % 3 == 0) {
                                    const i = d ? d[c + 1] : c + 1,
                                        h = d ? d[c + 2] : c + 2,
                                        u = (l.readToVec3(A, s), l.readToVec3(i, t), l.readToVec3(h, r), M.R.sub(a, t, s), M.R.sub(n, r, s), M.R.cross(M.R.create(), a, n)),
                                        g = M.R.sqrLen(u);
                                    if (0 < g) {
                                        M.R.scale(u, u, 1 / Math.sqrt(g)), p.set(o, u);
                                        const i = ga.area(s, t, r);
                                        m.set(o, i)
                                    }
                                }
                            }
                        }
                        const s = M.R.create();
                        C.O.iterateIndexedVerticesOnce(i, e => {
                            var t = u.get(e);
                            t && (t = this.calculateWeightedNormal(t, p, m, s)) && (M.R.scale(t, t, c), h.writeVec3(e, t))
                        })
                    }
                    return i.dataVersion++, n.buffer
                }
                console.warn("NormalCalculator: unsupported geometry")
            }
            static calculateNormal(e, t, s, r = M.R.create()) {
                var i = M.R.create(),
                    a = M.R.create(),
                    t = (M.R.sub(i, t, e), M.R.sub(a, s, e), M.R.cross(r, i, a)),
                    s = M.R.sqrLen(t);
                return 0 < s && M.R.scale(t, t, 1 / Math.sqrt(s)), t
            }
            static calculateWeightedNormal(e, s, r, i) {
                let a = !1;
                return M.R.set(i, 0, 0, 0), e.forEach(e => {
                    var t = s.get(e);
                    if (t) {
                        a = !0;
                        const s = r.get(e);
                        M.R.scaleAndAdd(i, i, t, s)
                    }
                }), a ? (M.R.normalize(i, i), i) : null
            }
            static addNormalAttribute(e) {
                var t, s = e.geometry;
                s.hasAttribute(A.p.NORMAL) || (t = new b.t({
                    buffer: new w.f({
                        data: new Float32Array(3 * s.vertexCount)
                    }),
                    attributes: [{
                        size: 3,
                        semantic: A.p.NORMAL
                    }]
                }), t = new Z.Z({
                    indexBuffer: s.indexBuffer,
                    buffers: [...s.buffers, t],
                    mode: s.mode,
                    start: s.start,
                    count: s.count
                }), e.setGeometry(t))
            }
        }
        class fa {
            constructor(e) {
                this._vertices = [], this._faces = [], this._generator = "", this._exporter = e
            }
            begin() {}
            addVertex(e) {
                this._vertices.push(e[0], e[1], e[2])
            }
            addTriangle(e, t, s) {
                this._faces.push(e, t, s)
            }
            addCopyright(e) {
                this._generator = !this._exporter.options.overrideGenerator && e.asset.generator || _t.defaultGenerator
            }
            end() {
                let e = `ply
format binary_little_endian 1.0
comment Created by ${this._generator}
element vertex ${this._exporter.counters.vertex}
property float x
property float y
property float z
element face ${this._exporter.counters.face}
property list uchar int vertex_indices
end_header
`;
                var t = new Me.c(4 * this._vertices.length + 13 * this._faces.length);
                for (const e of this._vertices) t.writeFloat32(e);
                for (let e = 0; e < this._faces.length; ++e) e % 3 == 0 && t.writeUint8(3), t.writeInt32(this._faces[e]);
                this._content = new Blob([e, t.buffer])
            }
            createFile(e) {
                if (this._content) return new File([this._content], e, {
                    type: "application/octet-stream",
                    lastModified: Date.now()
                });
                throw new Error("No content")
            }
        }
        class va {
            constructor(e) {
                this._content = "", this._generator = "", this._properites = "", this._elements = "", this._exporter = e
            }
            begin() {}
            addVertex(e) {
                this._properites += `${e[0]} ${e[1]} ${e[2]}\n`
            }
            addTriangle(e, t, s) {
                this._elements += `3 ${e} ${t} ${s}
`
            }
            addCopyright(e) {
                this._generator = !this._exporter.options.overrideGenerator && e.asset.generator || _t.defaultGenerator
            }
            end() {
                this._content = `ply
format ascii 1.0
comment Created by ${this._generator}
element vertex ${this._exporter.counters.vertex}
property float x
property float y
property float z
element face ${this._exporter.counters.face}
property list uchar int vertex_indices
end_header
${this._properites}
` + this._elements
            }
            createFile(e) {
                return new File([this._content], e, {
                    type: "text/plain",
                    lastModified: Date.now()
                })
            }
        }
        class ba {
            constructor(e) {
                this._materialId = "", this._inputs = [], this._shaders = [], this._writer = e
            }
            writeMaterial(e) {
                this._materialId = "Material_" + e.id;
                let t = 1;
                e instanceof o.q && (t = e.baseColorAlpha);
                var s = e.alphaMode === _e.mM.OPAQUE ? 1 - e.transmissionFactor : t,
                    r = (e.alphaMode === _e.mM.MASK && 0 < e.alphaCutoff && this._inputs.push("float inputs:opacityThreshold = " + e.alphaCutoff), this.addDiffuse(e, s)),
                    e = (this.addEmissive(e), this.addNormal(e), this.addOcclusion(e), this.addRoughness(e), this.addMetallic(e), this.addIOR(e), "PreviewSurface");
                return this._writer.materials += `
	def Material "${this._materialId}"
	{
		def Shader "${e}"
		{
			uniform token info:id = "UsdPreviewSurface"
			${this._inputs.join("\n\t\t\t")}
			${r?"":"float inputs:opacity = "+s.toPrecision(wa)}
			int inputs:useSpecularWorkflow = 0
			token outputs:surface
		}
	
		token outputs:surface.connect = </Materials/${this._materialId}/${e}.outputs:surface>
		
		${this._shaders.join("\n\t\t\t")}
	}
`, this._materialId
            }
            addDiffuse(e, t) {
                if (e instanceof o.q)
                    if (e.baseColorTextureInfo.hasTexture()) {
                        t = this.addTexture(e.baseColorTextureInfo, "diffuse", e, e.baseColorFactor, t);
                        if (e.alphaMode === _e.mM.BLEND || e.alphaMode === _e.mM.MASK) return this._inputs.push(`float inputs:opacity.connect = </Materials/${this._materialId}/${t}.outputs:a>`), !0
                    } else this._inputs.push("color3f inputs:diffuseColor = " + Ze(e.baseColorFactor));
                return !1
            }
            addEmissive(e) {
                e instanceof o.q && (e.emissiveTextureInfo.hasTexture() ? this.addTexture(e.emissiveTextureInfo, "emissive", e, e.emissiveFactor) : 0 < e.emissiveFactor && this._inputs.push("color3f inputs:emissiveColor = " + Ze(e.emissiveFactor)))
            }
            addNormal(e) {
                e instanceof o.q && e.normalTextureInfo.hasTexture() && this.addTexture(e.normalTextureInfo, "normal", e)
            }
            addOcclusion(e) {
                e instanceof o.q && (e.occlusionTextureInfo.hasTexture() ? this.addTexture(e.occlusionTextureInfo, "occlusion", e, this.getOcclusionFactor(e), 1, "r") : this._inputs.push("float inputs:occlusion = " + e.occlusionStrength.toPrecision(wa)))
            }
            addRoughness(e) {
                e instanceof o.q && (e.metallicRoughnessTextureInfo.hasTexture() ? this.addTexture(e.metallicRoughnessTextureInfo, "roughness", e, this.getRoughnessFactor(e), 1, "g") : this._inputs.push("float inputs:roughness = " + e.roughnessFactor.toPrecision(wa)))
            }
            addMetallic(e) {
                e instanceof o.q && (e.metallicRoughnessTextureInfo.hasTexture() ? this.addTexture(e.metallicRoughnessTextureInfo, "metallic", e, this.getMetallicFactor(e), 1, "b") : this._inputs.push("float inputs:metallic = " + e.metallicFactor.toPrecision(wa)))
            }
            addIOR(e) {
                e instanceof o.q && 1.5 !== e.ior && this._inputs.push("float inputs:ior = " + e.ior.toPrecision(wa))
            }
            getMetallicFactor(e) {
                return m.I.vec3_to_hex([1, 1, e.metallicFactor, 1])
            }
            getRoughnessFactor(e) {
                return m.I.vec3_to_hex([1, e.roughnessFactor, 1, 1])
            }
            getOcclusionFactor(e) {
                return m.I.vec3_to_hex([e.occlusionStrength, 1, 1, 1])
            }
            addTexture(t, e, s, r, i = 1, a = "rgb") {
                var {
                    texture: n,
                    channel: t,
                    transform: o
                } = t, l = `Texture_${n.id}_` + e;
                let h = this._writer.savedTextures.get(n);
                if (!h) {
                    const t = na(this._writer.options.imageSettings, n);
                    var c = p.P.changeExtension(n.image.name, t.extension);
                    h = "textures/" + c;
                    let e = 0;
                    for (; void 0 !== this._writer.usdaWriter.files[h];) c = p.P.changeExtension(n.image.name + "_" + ++e, t.extension), h = "textures/" + c;
                    this._writer.savedTextures.set(n, h), this._writer.usdaWriter.files[h] = "[loading]", this._writer.usdaWriter.filePromises.push(v.O.readIntoArraybuffer(n, t).then(e => {
                        this._writer.usdaWriter.files[h] = new Uint8Array(e)
                    }))
                }
                var d = "diffuse" === e || "emissive" === e ? "sRGB" : "raw",
                    t = 0 < t ? "st" + t : "st",
                    s = s.transparent || s.alphaMode === _e.mM.MASK && 0 < s.alphaCutoff;
                let u = "color3f";
                return "normal" === e ? u = "normal3f" : 1 === a.length && (u = "float"), this._inputs.push(`${u} inputs:${xa[e]}.connect = </Materials/${this._materialId}/${l}.outputs:${a}>`), this._shaders.push(`
		def Shader "PrimvarReader_${e}"
		{
			uniform token info:id = "UsdPrimvarReader_float2"
			float2 inputs:fallback = (0.0, 0.0)
			token inputs:varname = "${t}"
			float2 outputs:result
		}

		def Shader "Transform2d_${e}"
		{
			uniform token info:id = "UsdTransform2d"
			token inputs:in.connect = </Materials/${this._materialId}/PrimvarReader_${e}.outputs:result>
			float inputs:rotation = ${(o.rotation*f.M.RAD2DEG).toPrecision(wa)}
			float2 inputs:scale = ${Je(o.scale)}
			float2 inputs:translation = ${Je(o.translation)}
			float2 outputs:result
		}

		def Shader "${l}"
		{
			uniform token info:id = "UsdUVTexture"
			asset inputs:file = @${h}@
			float2 inputs:st.connect = </Materials/${this._materialId}/Transform2d_${e}.outputs:result>
			${void 0!==r&&16777215!==r&&void 0!==i&&1!==i?"float4 inputs:scale = "+([a=1]=[i],t=m.I.decomposeAndNormalizeRGB(r),`(${t[0].toPrecision(6)}, ${t[1].toPrecision(6)}, ${t[2].toPrecision(6)}, ${a.toPrecision(6)})`):""}
			token inputs:sourceColorSpace = "${d}"
			token inputs:wrapS = "${Qe(n.sampler.wrapS)}"
			token inputs:wrapT = "${Qe(n.sampler.wrapT)}"
			float outputs:r
			float outputs:g
			float outputs:b
			float3 outputs:rgb${s?"\n\t\t\tfloat outputs:a":""}
		}
`), l
            }
        }

        function Ze(e) {
            e = m.I.decomposeAndNormalizeRGB(e);
            return `(${e[0].toPrecision(6)}, ${e[1].toPrecision(6)}, ${e[2].toPrecision(6)})`
        }

        function Je(e) {
            return `(${e[0].toPrecision(wa)}, ${e[1].toPrecision(wa)})`
        }

        function Qe(e) {
            return e === _.g.REPEAT ? "repeat" : e === _.g.MIRRORED_REPEAT ? "mirror" : "clamp"
        }
        const xa = {
            diffuse: "diffuseColor",
            emissive: "emissiveColor",
            occlusion: "occlusion",
            metallic: "metallic",
            roughness: "roughness",
            normal: "normal"
        };
        class Ta {
            constructor(e, t) {
                this.materials = "", this.savedTextures = new Map, this._savedMaterials = new Map, this.usdaWriter = e, this.options = t
            }
            writeMaterial(e) {
                let t = this._savedMaterials.get(e);
                return t || (t = new ba(this).writeMaterial(e), this._savedMaterials.set(e, t)), t
            }
            getContent() {
                return this.materials ? `
def "Materials"
{
${this.materials}
}
` : ""
            }
        }
        const wa = 6;
        class Ea {
            constructor(e) {
                this._name = "", this._generator = "gltfeditor.com", this._content = "", this._objects = "", this.files = {}, this.filePromises = [], this._materialWriter = new Ta(this, e)
            }
            begin(e) {
                this._name = e
            }
            addCopyright(e) {
                this._generator = e.asset.generator || _t.defaultGenerator
            }
            end() {
                this._content = "" + this.createHeader() + `

def Xform "Root"
{
	def Scope "Scenes" (
		kind = "sceneLibrary"
	)
	{
		def Xform "Scene" (
			customData = {
				bool preliminary_collidesWithEnvironment = 0
				string sceneName = "${this._name}"
			}
			sceneName = "${this._name}"
		)
		{
		token preliminary:anchoring:type = "plane"
		token preliminary:planeAnchoring:alignment = "horizontal"
		
${this._objects}
		}
	}
}
`
            }
            writeNode(e) {
                1 < e.renderNodes.length && console.warn("TODO implement multiple render nodes");
                var t, s = e.renderNodes[0];
                s && (t = this.writeGeometry(s.geometry), s = this._materialWriter.writeMaterial(s.material), this._objects += `		def Xform "Object_${e.id}" (
			prepend references = @./${t}@</Geometry>
			prepend apiSchemas = ["MaterialBindingAPI"]
		)
		{
			matrix4d xformOp:transform = ${t=e.calculateWorldMatrix(),`((${t[0]}, ${t[1]}, ${t[2]}, ${t[3]}), (${t[4]}, ${t[5]}, ${t[6]}, ${t[7]}), (${t[8]}, ${t[9]}, ${t[10]}, ${t[11]}), (${t[12]}, ${t[13]}, ${t[14]}, ${t[15]}))`}
			uniform token[] xformOpOrder = ["xformOp:transform"]

			rel material:binding = </Materials/${s}>
		}

`)
            }
            createHeader() {
                return `#usda 1.0
(
	customLayerData = {
		string creator = "${this._generator}"
	}
	defaultPrim = "Root"
	metersPerUnit = 1
	upAxis = "Y"
)`
            }
            writeGeometry(e) {
                var t = `geometries/Geometry_${e.id}.usda`;
                return this.files[t] || (this.files[t] = this.createGeometryFile(e, t)), t
            }
            createGeometryFile(e, t) {
                var s = this.createFaceVertexCounts(e);
                return "" + this.createHeader() + `

def "Geometry"
{
	def Mesh "Geometry"
	{
		int[] faceVertexCounts = [${s}]
		${this.createFaceVertexIndices(e)}
		${this.createNormals(e)}
		${this.createPoints(e)}
		${this.createUVs(e)}
		uniform token subdivisionScheme = "none"
	}
}
`
            }
            createFaceVertexCounts(e) {
                e = ue.oY.calculateNumberOfPrimitives(e.count, e.mode);
                return new Array(e).fill(3).join(",")
            }
            createFaceVertexIndices(e) {
                let s = "";
                return C.O.iterateIndices(e, (e, t) => {
                    0 < t && (s += ","), s += "" + e
                }), `int[] faceVertexIndices = [${s}]`
            }
            createNormals(e) {
                var t = e.getAttribute(A.p.NORMAL);
                if (t && 3 <= t.size) {
                    const r = new N.s(t),
                        i = g.v.create();
                    let s = "";
                    return C.O.iterateVertices(e, (e, t) => {
                        e = r.readToVec3(e, i);
                        0 < t && (s += ","), s += `(${e[0].toPrecision(wa)},${e[1].toPrecision(wa)},${e[2].toPrecision(wa)})`
                    }), `normal3f[] normals = [${s}] (
			interpolation = "vertex"
		)`
                }
                return ""
            }
            createPoints(e) {
                var t = e.getAttribute(A.p.POSITION);
                if (t && 3 <= t.size) {
                    const r = new N.s(t),
                        i = g.v.create();
                    let s = "";
                    return C.O.iterateVertices(e, (e, t) => {
                        e = r.readToVec3(e, i);
                        0 < t && (s += ","), s += `(${e[0].toPrecision(wa)},${e[1].toPrecision(wa)},${e[2].toPrecision(wa)})`
                    }), `
		point3f[] points = [${s}]`
                }
                return ""
            }
            createUVs(t) {
                let r = "";
                for (let e = 0; e < 8; ++e) {
                    var i = t.getAttribute(A.p.getTexCoord(e));
                    if (i && 2 <= i.size) {
                        const a = new N.s(i),
                            n = g.v.create();
                        let s = "";
                        C.O.iterateVertices(t, (e, t) => {
                            e = a.readToVec2(e, n);
                            0 < t && (s += ","), s += `(${e[0].toPrecision(wa)},${(1-e[1]).toPrecision(wa)})`
                        }), r && (r += "\n\t\t"), r += `texCoord2f[] primvars:${0<e?"st"+e:"st"} = [${s}] (
				interpolation = "vertex"
			)`
                    }
                }
                return r
            }
            async createFile(e) {
                this._content += this._materialWriter.getContent();
                const s = await c.e(542).then(c.bind(c, 5815)),
                    t = (await Promise.all(this.filePromises), "model.usda"),
                    r = {
                        "model.usda": new Uint8Array(0)
                    };
                Object.entries(this.files).forEach(([e, t]) => {
                    r[e] = "string" == typeof t ? s.strToU8(t) : t
                }), r[t] = s.strToU8(this._content);
                let i = 0;
                const a = {};
                Object.entries(r).forEach(([e, t]) => {
                    const s = 34 + e.length;
                    var r = 63 & (i += s);
                    if (4 != r) {
                        const s = new Uint8Array(64 - r);
                        a[e] = [t, {
                            extra: {
                                12345: s
                            }
                        }]
                    } else a[e] = t;
                    i = t.length
                });
                var n = s.zipSync(a, {
                    level: 0
                });
                return new File([n], e, {
                    type: "model/vnd.usdz+zip",
                    lastModified: Date.now()
                })
            }
        }
        class Ca extends z {
            async execute(e) {
                var t = Ca.exporters[e.fileFormat] || ra,
                    {
                        scene: s,
                        animation: r
                    } = this._app.state,
                    t = new t(e);
                t.addCopyright(this._app.project), await t.addScene(s), r && t.addAnimation(r), t.getFile().then(e => {
                    p.P.downloadFile(e, e.name)
                })
            }
        }
        Ca.ID = "export", Ca.exporters = {
            glb: ra,
            gltf: ra,
            obj: ha,
            stl: class extends oa {
                constructor(e) {
                    super(e), this._tmp1 = g.v.create(), this._tmp2 = g.v.create(), this._tmp3 = g.v.create(), this._n0 = g.v.create(), this._n1 = g.v.create(), this._n2 = g.v.create(), this._n = M.R.create(), this._writer = new(e.binary ? ca : da)
                }
                write() {
                    this._scene && (this._writer.begin(this.getSceneName()), this.traverse(this._scene), this._writer.end())
                }
                traverse(e) {
                    this.writeNode(e);
                    for (const t of e.children) this.traverse(t)
                }
                writeNode(e) {
                    for (const t of e.renderNodes) this.writeRenderNode(t)
                }
                writeRenderNode(n) {
                    const o = n.geometry,
                        l = n.node.calculateWorldMatrix(),
                        h = E.x.getNormalMat(l),
                        e = o.getAttribute(A.p.POSITION);
                    if (e && 3 <= e.size) {
                        const n = new N.s(e);
                        C.O.iterateTriangles(o, (e, t, s) => {
                            var r = n.readPointToVec4(e, this._tmp1),
                                i = (g.v.transformMat4(r, r, l), n.readPointToVec4(t, this._tmp2)),
                                a = (g.v.transformMat4(i, i, l), n.readPointToVec4(s, this._tmp3)),
                                e = (g.v.transformMat4(a, a, l), this.getNormal(o, h, e, t, s, r, i, a));
                            this._writer.addTriangleFace(r, i, a, e)
                        })
                    }
                }
                getNormal(e, t, s, r, i, a, n, o) {
                    var l = e.getAttribute(A.p.NORMAL);
                    if (l) {
                        const e = new N.s(l),
                            a = e.readToVec3(s, this._n0),
                            n = e.readToVec3(r, this._n1),
                            o = e.readToVec3(i, this._n2),
                            h = [(a[0] + n[0] + o[0]) / 3, (a[1] + n[1] + o[1]) / 3, (a[2] + n[2] + o[2]) / 3];
                        return M.R.normalize(h, h), M.R.transformMat4(h, h, t), M.R.normalize(h, h), h
                    }
                    return _a.calculateNormal(a, n, o, this._n)
                }
                getFileName() {
                    return this.getSceneName() + ".stl"
                }
                addCopyright(e) {
                    this._writer.addCopyright(e)
                }
                async getFile() {
                    return this.write(), this._writer.createFile(this.getFileName())
                }
            },
            ply: class extends oa {
                constructor(e) {
                    super(e), this._tmp1 = g.v.create(), this._tmp2 = g.v.create(), this._tmp3 = g.v.create(), this._n0 = g.v.create(), this._n1 = g.v.create(), this._n2 = g.v.create(), this._n = M.R.create(), this.counters = {
                        vertex: 0,
                        face: 0,
                        position: 3,
                        normal: 0,
                        uv: 0
                    }, this._writer = new(e.binary ? fa : va)(this)
                }
                async getFile() {
                    return this.write(), this._writer.createFile(this.getFileName())
                }
                write() {
                    this._scene && (this._writer.begin(), this.traverse(this._scene), this._writer.end())
                }
                traverse(e) {
                    this.writeNode(e);
                    for (const t of e.children) this.traverse(t)
                }
                writeNode(e) {
                    for (const t of e.renderNodes) this.writeRenderNode(t)
                }
                writeRenderNode(s) {
                    const e = ji.convertGeometryToIndexed(s.geometry),
                        r = s.node.calculateWorldMatrix(),
                        t = e.getAttribute(A.p.POSITION);
                    if (t && 3 <= t.size) {
                        const s = new N.s(t),
                            i = this.counters.vertex;
                        C.O.iterateTriangles(e, (e, t, s, r) => {
                            this.counters.face++, this._writer.addTriangle(e + i, t + i, s + i)
                        }), C.O.iterateVertices(e, (e, t) => {
                            this.counters.vertex++;
                            e = s.readPointToVec4(e, this._tmp1), e = g.v.transformMat4(this._tmp2, e, r);
                            this._writer.addVertex(e)
                        })
                    }
                }
                getFileName() {
                    var e = this.getSceneName();
                    return e.endsWith(".ply") ? e : e + ".ply"
                }
                addCopyright(e) {
                    this._writer.addCopyright(e)
                }
            },
            assjson: class {
                constructor() {
                    this.getModule()
                }
                async getModule() {
                    return this._assimp || (this._assimpPromise || (this._assimpPromise = new Promise(async e => {
                        var t = await Promise.all([c.e(300), c.e(172)]).then(c.t.bind(c, 9300, 23));
                        this._assimp = await t.default(), e(this._assimp)
                    })), await this._assimpPromise)
                }
                async addScene(e) {
                    var t = await this.getModule(),
                        s = new t.FileList,
                        t = t.ConvertFileList(s, "assjson");
                    t.IsSuccess() && 0 != t.FileCount() ? (s = t.GetFile(0), s = (new TextDecoder).decode(s.GetContent()), s = JSON.parse(s), console.log(s)) : console.log(t.GetErrorCode())
                }
                addAnimation(e) {}
                addCopyright(e) {}
                async getFile() {
                    return new File([], "name")
                }
            },
            usdz: class extends oa {
                constructor(e) {
                    super(e), this.visitNode = e => {
                        this._model.writeNode(e)
                    }, this._model = new Ea(e)
                }
                async getFile() {
                    return this.write(), this._model.createFile(this.getFileName())
                }
                write() {
                    this._scene && (this._model.begin(this.getSceneName()), H.traverseNodes(this._scene, this.visitNode), this._model.end())
                }
                getFileName() {
                    return this.getSceneName() + ".usdz"
                }
            }
        };
        const ya = [{
            value: "png",
            label: "PNG"
        }, {
            value: "jpg",
            label: "JPEG"
        }, {
            value: "webp",
            label: "WebP"
        }];
        class Aa extends u.Component {
            constructor(e) {
                super(e), this.onChangeFormat = e => {
                    this.props.onChange({ ...this.props.settings,
                        format: e.value
                    })
                }, this.onChangeQuality = e => {
                    this.props.onChange({ ...this.props.settings,
                        quality: e / 100
                    })
                }
            }
            render() {
                return u.createElement(u.Fragment, null, u.createElement(k, {
                    label: "Textures"
                }, u.createElement(F, {
                    selected: ya.find(e => e.value === this.props.settings.format),
                    render: e => e.label,
                    onChange: this.onChangeFormat,
                    options: ya
                }), "png" !== this.props.settings.format && u.createElement(G, {
                    label: "Quality",
                    value: Math.round(100 * this.props.settings.quality),
                    onChange: this.onChangeQuality,
                    min: 0,
                    max: 100,
                    step: 1,
                    decimals: 0,
                    postfix: "%"
                })))
            }
        }
        const Ma = [{
            value: "",
            label: "None"
        }, {
            value: "draco",
            label: "Draco"
        }];
        class Ra extends u.Component {
            constructor(e) {
                super(e), this.onChange = e => {
                    this.props.onChange({ ...this.props.options,
                        ...e
                    })
                }, this.onChangeEmbedImages = e => {
                    this.onChange({
                        embedImages: e
                    })
                }, this.onChangeEmbedBuffers = e => {
                    this.onChange({
                        embedBuffers: e
                    })
                }, this.onChangeGeometryCompression = e => {
                    this.onChange({
                        geometryCompression: e.value
                    })
                }, this.onChangeImageSettings = e => {
                    this.onChange({
                        imageSettings: e
                    })
                }
            }
            render() {
                const t = this.props.options;
                return u.createElement(u.Fragment, null, u.createElement(Aa, {
                    settings: t.imageSettings,
                    onChange: this.onChangeImageSettings
                }), u.createElement(k, {
                    label: "Geometry Compression"
                }, u.createElement(F, {
                    selected: Ma.find(e => e.value === t.geometryCompression),
                    render: e => e.label,
                    onChange: this.onChangeGeometryCompression,
                    options: Ma
                })), u.createElement("br", null), u.createElement(k, {
                    label: "Embed Textures"
                }, u.createElement(U, {
                    value: t.embedImages,
                    onChange: this.onChangeEmbedImages
                })), u.createElement(k, {
                    label: "Embed Geometry"
                }, u.createElement(U, {
                    value: t.embedBuffers,
                    onChange: this.onChangeEmbedBuffers
                })), u.createElement(k, {
                    label: "Use TRS transforms"
                }, u.createElement(U, {
                    value: t.useTRS,
                    onChange: e => this.onChange({
                        useTRS: e
                    })
                })), u.createElement(k, {
                    label: "Animations"
                }, u.createElement(U, {
                    value: t.animations,
                    onChange: e => this.onChange({
                        animations: e
                    })
                })), u.createElement(k, {
                    label: "Lights"
                }, u.createElement(U, {
                    value: t.lights,
                    onChange: e => this.onChange({
                        lights: e
                    })
                })), u.createElement(k, {
                    label: "Visibility"
                }, u.createElement(U, {
                    value: t.visibility,
                    onChange: e => this.onChange({
                        visibility: e
                    })
                })), u.createElement(k, {
                    label: 'Override generator to "gltfeditor.com"'
                }, u.createElement(U, {
                    value: t.overrideGenerator,
                    onChange: e => this.onChange({
                        overrideGenerator: e
                    })
                })))
            }
        }
        class Sa extends u.Component {
            constructor(e) {
                super(e), this.onChange = e => {
                    this.props.onChange({ ...this.props.options,
                        ...e
                    })
                }, this.onChangeBinary = e => {
                    this.onChange({
                        binary: e
                    })
                }
            }
            render() {
                var e = this.props.options;
                return u.createElement(u.Fragment, null, u.createElement(k, {
                    label: "Binary"
                }, u.createElement(U, {
                    value: e.binary,
                    onChange: this.onChangeBinary
                })))
            }
        }
        class Na extends u.Component {
            constructor(e) {
                super(e), this.onChange = e => {
                    this.props.onChange({ ...this.props.options,
                        ...e
                    })
                }, this.onChangeImageSettings = e => {
                    this.onChange({
                        imageSettings: e
                    })
                }
            }
            render() {
                var e = this.props.options;
                return u.createElement(u.Fragment, null, u.createElement(Aa, {
                    settings: e.imageSettings,
                    onChange: this.onChangeImageSettings
                }))
            }
        }
        class Ia extends u.Component {
            constructor(e) {
                super(e), this._fileFormats = [{
                    value: "gltf",
                    label: "GLTF",
                    ui: Ra
                }, {
                    value: "glb",
                    label: "GLB",
                    ui: Ra
                }, {
                    value: "usdz",
                    label: "USDZ",
                    ui: Na
                }, {
                    value: "obj",
                    label: "OBJ"
                }, {
                    value: "stl",
                    label: "STL",
                    ui: Sa
                }, {
                    value: "ply",
                    label: "PLY",
                    ui: Sa
                }, {
                    value: "assjson",
                    label: "Assimp"
                }], this.onChangeFileFormat = e => {
                    let t = this.state;
                    var s;
                    ["glb", "gltf"].includes(e.value) && (s = "glb" === e.value, t = { ...t,
                        binary: s
                    }, s = "glb" === e.value, t = { ...t,
                        embedImages: s,
                        embedBuffers: s
                    }), this.setState({ ...t,
                        fileFormat: e.value
                    })
                }, this.onSaveClick = e => {
                    this.save()
                }, this.onCloseClick = () => {
                    this.close()
                }, this.onChangeOptions = e => {
                    this.setState({ ...e
                    })
                }, this.onMount = e => {
                    y.listenPopup(e, this.onCloseClick)
                }, this.state = {
                    fileFormat: "glb",
                    binary: !0,
                    geometryCompression: "",
                    embedImages: !0,
                    imageSettings: {
                        format: "jpg",
                        quality: .9
                    },
                    embedBuffers: !0,
                    useTRS: !1,
                    animations: !0,
                    lights: !0,
                    visibility: !1,
                    overrideGenerator: !0,
                    filter: {
                        selected: !!e.app.state.selected,
                        visible: !1
                    }
                }, this.props.keyboardListener.signals.down.add(this.onKeyDown, this)
            }
            save() {
                var e = J.g.clone(this.state);
                this.close(), this.props.app.commands.execute(Ca.ID, e)
            }
            close() {
                this.props.keyboardListener.signals.down.remove(this.onKeyDown, this), this.props.onClose()
            }
            onKeyDown(e) {
                e.keyCode === P.KEY_ENTER && this.save()
            }
            render() {
                var e = this._fileFormats.find(e => e.value === this.state.fileFormat),
                    t = null == e ? void 0 : e.ui;
                return u.createElement("div", {
                    className: "SaveWindow popup dark-panel",
                    ref: this.onMount
                }, u.createElement("div", {
                    className: "panel-header"
                }, u.createElement("div", {
                    className: "panel-title"
                }, "Save"), u.createElement("div", {
                    className: "panel-close",
                    onClick: this.onCloseClick
                })), u.createElement("div", {
                    className: "panel-content vbox"
                }, u.createElement(k, {
                    label: "Format"
                }, u.createElement(F, {
                    options: this._fileFormats,
                    render: F.renderLabel,
                    selected: e,
                    onChange: this.onChangeFileFormat
                })), u.createElement("div", {
                    className: "format-ui"
                }, t && u.createElement(t, {
                    options: this.state,
                    onChange: this.onChangeOptions
                })), u.createElement("div", {
                    className: "alignSelfFlexEnd"
                }, u.createElement(Rt, {
                    label: "Save",
                    onClick: this.onSaveClick
                }))))
            }
        }
        class Pa extends z {
            constructor(e) {
                super(e), this.addShortcut({
                    ctrlMeta: !0,
                    keyCode: P.KEY_S
                })
            }
            execute(e) {
                var t;
                null != (t = this._app.popups) && t.open(Ia, {
                    app: this._app
                })
            }
        }
        Pa.ID = "fileSave";
        class Fa extends z {
            constructor(e) {
                super(e), this.openFiles = e => {
                    this._app.project.loadFiles(Array.from(e), !0)
                }, this.addShortcut({
                    ctrlMeta: !0,
                    alt: !1,
                    shift: !1,
                    keyCode: P.KEY_I
                })
            }
            execute(e) {
                p.P.openFileDialogue(!0, null, this.openFiles)
            }
        }
        Fa.ID = "fileImport";
        class La extends z {
            execute(t) {
                this._app.setState(e => ({
                    showWelcome: null != t ? t : !e.showWelcome
                }))
            }
        }
        La.ID = "toggle_sampleProjects";
        class Da extends z {
            execute(e) {
                this._app.setState(e => ({
                    showAnimation: !e.showAnimation
                }))
            }
        }
        Da.ID = "toggle_animation";
        class Oa extends z {
            constructor(e) {
                super(e), this.addShortcut({
                    ctrlMeta: !0,
                    keyCode: P.KEY_N
                })
            }
            execute(e) {
                this._app.project.clear(), this._app.project.signals.change.dispatch(this._app.project)
            }
        }
        Oa.ID = "fileNew";
        class Ba extends z {
            execute(e) {
                var t = this.createGeometry(e),
                    e = Ba.names[e],
                    e = new q.B({
                        name: e,
                        renderNodes: [new T.j({
                            name: e,
                            geometry: t,
                            material: new o.q({
                                baseColorFactor: 15338251,
                                metallicFactor: 0,
                                roughnessFactor: .5
                            })
                        })]
                    });
                this._app.commands.execute(La.ID, !1), this._app.project.scene.add(e), this._app.setState({
                    selected: e
                })
            }
            createGeometry(e) {
                var t = new ut;
                switch (e) {
                    case "plane":
                        return t.createPlane();
                    case "cube":
                        return t.createCube();
                    case "sphere":
                    case "torus":
                        return t.createSphere();
                    case "disc":
                        return t.createDisc();
                    case "circle":
                        return t.createCircle();
                    case "cylinder":
                        return t.createCylinder();
                    case "cone":
                        return t.createCone()
                }
                throw new Error("Unknown option: " + e)
            }
        }
        Ba.ID = "add_mesh", Ba.names = {
            plane: "Plane",
            cube: "Cube",
            sphere: "Sphere",
            disc: "Disc",
            circle: "Circle",
            cylinder: "Cylinder",
            cone: "Cone",
            torus: "Torus"
        };
        class Ua extends z {
            constructor(e) {
                super(e), this.addShortcut({
                    keyCode: P.KEY_DELETE
                }), this.addShortcut({
                    keyCode: P.KEY_BACKSPACE
                })
            }
            execute(r) {
                const t = this._app,
                    i = t.state.selected;
                if (i) {
                    if (i instanceof K.x)
                        for (let e = i.children.length - 1; 0 <= e; e--) i.children[e].detach();
                    else if (!0 !== (null == r ? void 0 : r.invert)) this.deleteNode(i), this._app.setState({
                        selected: null
                    });
                    else {
                        const r = [];
                        let e = t.selection.getSelectedNode();
                        for (; e;) r.push(e), e = e.getParent();
                        H.traverseNodesBackwards(t.state.scene, t => {
                            r.includes(t) || this.deleteNode(t);
                            for (let e = t.renderNodes.length - 1; 0 <= e; e--) {
                                var s = t.renderNodes[e];
                                s !== i && this.deleteNode(s)
                            }
                        })
                    }
                    t.invalidate(), t.invalidateUI()
                }
            }
            deleteNode(e) {
                e instanceof q.B || e instanceof Ce.h || e instanceof T.j ? e.detach() : e instanceof Ae.a && (e.node.light = void 0), (e instanceof q.B || e instanceof T.j) && H.traverseRenderNodesOnce(e, e => {
                    this._app.engine.debugTools.toggleVertexNormals(e, !1)
                })
            }
        }
        Ua.ID = "delete";
        class ka {
            static flip(e, t) {
                ka.updateNode(e, t, ka.flipNormals)
            }
            static normalize(e, t) {
                ka.updateNode(e, t, ka.normalizeNormals)
            }
            static updateNode(e, t, s) {
                const r = new Set;
                H.traverseGeometryOnce(e, e => {
                    e = s(e);
                    e && r.add(e)
                }), r.forEach(e => {
                    t.adapter.uploadBufferData(e)
                })
            }
            static flipNormals(e) {
                return ka.updateNormals(e, e => {
                    M.R.scale(e, e, -1)
                })
            }
            static normalizeNormals(e) {
                return ka.updateNormals(e, e => {
                    M.R.normalize(e, e)
                })
            }
            static updateNormals(e, t) {
                var s = e.getAttribute(A.p.NORMAL);
                if (s && 3 <= s.size) {
                    const r = new N.s(s),
                        i = M.R.create();
                    return C.O.iterateIndexedVerticesOnce(e, e => {
                        r.readToVec3(e, i), t(i), r.writeVec3(e, i)
                    }), e.dataVersion++, s.buffer
                }
            }
            static removeAttribute(e, t, s) {
                ka.updateNode(e, s, e => ka.removeRenderNodeAttribute(e, t))
            }
            static removeRenderNodeAttribute(e, t) {
                e.removeAttribute(t)
            }
        }
        class za extends z {
            constructor(e) {
                super(e)
            }
            execute(e) {
                var t = this._app,
                    s = t.selection.getTarget();
                ka.flip(s, t.engine), t.invalidate()
            }
        }
        za.ID = "flip_normals";
        class Va extends z {
            constructor(e) {
                super(e)
            }
            execute(e = !0) {
                var t = this._app,
                    s = t.selection.getTarget();
                _a.recalculate(s, t.engine, e), t.invalidate(), t.invalidateUI()
            }
        }
        Va.ID = "recalculate_normals";
        class Ga {
            static convertToNonInterleaved(e) {
                H.traverseRenderNodesOnce(e, this.convertRenderNodeToNonInterleaved)
            }
            static convertToInterleaved(e) {
                H.traverseRenderNodesOnce(e, this.convertRenderNodeToInterleaved)
            }
            static convertRenderNodeToNonInterleaved(e) {
                var t = e.geometry;
                if (t.isInterleaved()) {
                    var s = [];
                    for (const e of t.getAttributes()) {
                        var r = Ga.createBufferForAttribute(e, t);
                        s.push(r)
                    }
                    var i = new Z.Z({
                        indexBuffer: t.indexBuffer,
                        buffers: s,
                        mode: t.mode,
                        start: t.start,
                        count: t.count
                    });
                    e.setGeometry(i)
                }
            }
            static convertRenderNodeToInterleaved(i) {
                var e = i.geometry;
                if (1 < e.buffers.length) {
                    const s = e.getAttributes().map(e => ({ ...e
                        })),
                        a = new Map,
                        n = e.getBytesPerVertex();
                    for (const i of s) a.set(i, new N.s(i));
                    const o = new ArrayBuffer(e.getTotalVertexByteSize()),
                        l = new DataView(o);
                    let r = 0;
                    for (const i of s) {
                        const h = a.get(i),
                            c = ue.rg[i.componentType],
                            d = ue.oY.getBytesForType(i.componentType);
                        h && C.O.iterateIndexedVerticesOnce(e, t => {
                            for (let e = 0; e < i.size; ++e) {
                                const i = h.readAt(t, e),
                                    s = t * n;
                                c.call(l, r + s + e * d, i, !0)
                            }
                        }), i.byteOffset = r, i.byteStride = -1, r += d * i.size
                    }
                    var t = new b.t({
                            buffer: new w.f({
                                data: l
                            }),
                            attributes: s
                        }),
                        t = new Z.Z({
                            indexBuffer: e.indexBuffer,
                            buffers: [t],
                            mode: e.mode,
                            start: e.start,
                            count: e.count
                        });
                    i.setGeometry(t)
                }
            }
            static createBufferForAttribute(r, e) {
                const i = new N.s(r),
                    a = new ue.eE[r.componentType](e.count * r.size);
                return C.O.iterateIndexedVertices(e, t => {
                    for (let e = 0; e < r.size; ++e) {
                        var s = i.readAt(t, e);
                        a[t * r.size + e] = s
                    }
                }), new b.t({
                    buffer: new w.f({
                        data: a
                    }),
                    attributes: [{ ...r,
                        byteOffset: 0,
                        byteStride: ue.oY.getAttributeByteSize(r)
                    }]
                })
            }
        }
        class Wa extends z {
            constructor(e) {
                super(e)
            }
            execute(e) {
                var t = this._app,
                    s = t.selection.getTarget();
                void 0 !== e.interleaved && (e.interleaved ? Ga.convertToInterleaved(s) : Ga.convertToNonInterleaved(s)), void 0 !== e.indexed && (e.indexed ? ji.convertToIndexed(s) : ji.convertToNonIndexed(s)), e.mode && ("lines" === e.mode ? Ys.convertToLines(s) : "points" === e.mode && Ys.convertToPoints(s)), t.invalidate(), t.invalidateUI()
            }
        }
        Wa.ID = "convert_geometry";
        class Ha extends z {
            constructor(e) {
                super(e)
            }
            execute(e) {
                var t = this._app,
                    s = t.selection.getTarget();
                ka.normalize(s, t.engine), t.invalidate()
            }
        }
        Ha.ID = "normalize_normals";
        class Ya extends z {
            constructor(e) {
                super(e)
            }
            execute(e) {
                var t = this._app,
                    s = t.selection.getSelectedNodeTarget();
                switch (e) {
                    case "center_pivot":
                        Yi.centerPivot(s, t.engine);
                        break;
                    case "apply_transform":
                        Yi.applyTransform(s, t.engine);
                        break;
                    case "apply_translation":
                        Yi.applyTranslation(s, t.engine);
                        break;
                    default:
                        throw new Error("Wrong option given: " + e)
                }
                t.invalidate(), t.invalidateUI()
            }
        }
        Ya.ID = "transform";
        class ja extends z {
            constructor(e) {
                super(e)
            }
            execute(e) {
                var t = this._app,
                    s = t.selection.getTarget();
                ka.removeAttribute(s, e, t.engine), t.invalidate(), t.invalidateUI()
            }
        }
        ja.ID = "remove_attribute";
        class Ka extends z {
            constructor(e) {
                super(e), this.addShortcut({
                    keyCode: P.KEY_F
                }), this.addShortcut({
                    keyCode: P.KEY_HOME
                })
            }
            execute(e) {
                var t, s = this._app,
                    r = s.selection.getTarget();
                if (r) {
                    const e = null == (t = null == (t = s.canvasView) ? void 0 : t.renderView) ? void 0 : t.controller;
                    e ? class {
                        static focus(e, t) {
                            var s = e instanceof T.j ? e.getBoundingBoxWorld() : null == e ? void 0 : e.getAABBWorld(!0);
                            if (s) {
                                const e = f.M.max(s.getSize()),
                                    r = M.R.lerp(M.R.create(), s.min, s.max, .5);
                                if (t.setTarget(r), t.setDistance(2 * e, !1), s) {
                                    const e = f.M.max(s.getSize());
                                    t.camera.near = f.M.clamp(e / 80, 1e-5, 10), t.camera.far = 1e3 * e
                                }
                            }
                            return s
                        }
                        static slideTo(e, t) {
                            var s = e.getAABBWorld(!0);
                            if (s) {
                                const e = M.R.lerp(M.R.create(), s.min, s.max, .5),
                                    r = M.R.sub(M.R.create(), e, t.getTarget()),
                                    i = M.R.add(M.R.create(), t.camera.getEye(), r);
                                t.camera.lookAt(e, i), t.setTarget(e)
                            }
                            return s
                        }
                    }.focus(r, e) : console.warn("No controller found"), s.invalidate()
                }
            }
        }
        Ka.ID = "focus";
        class qa extends z {
            execute(e) {
                var t = new q.B({
                    name: qa.names[e]
                });
                t.light = new Ae.a(t, {
                    type: e
                }), this._app.commands.execute(La.ID, !1), this._app.project.scene.add(t), this._app.setState({
                    selected: t.light
                })
            }
        }
        qa.ID = "add_light", qa.names = {
            point: "Point light",
            spot: "Spot light",
            directional: "Directional light"
        };
        class $a extends z {
            constructor(e) {
                super(e), this.addShortcut({
                    keyCode: P.KEY_F,
                    ctrlMeta: !0
                })
            }
            execute(e) {
                var t = this._app,
                    s = t.selection.getSelectedNode(),
                    r = t.state.camera;
                if (s && r) {
                    const e = E.x.getTranslation(r.calculateWorldMatrix());
                    s instanceof K.x || s.lookAt(e), t.invalidate(), t.invalidateUI()
                }
            }
        }
        $a.ID = "lookAtCamera";
        var et = c(387);
        class Xa extends z {
            constructor(e) {
                super(e), this.addShortcut({
                    keyCode: P.KEY_D,
                    ctrlMeta: !0
                })
            }
            execute(e, t) {
                const s = this._app.state.selected,
                    r = s instanceof T.j ? s.node : s;
                if (r) {
                    const e = r.transform.translation,
                        s = r.getAABBParent() || new et.x,
                        i = s.max[0] - s.min[0],
                        a = e.x + (0 == i ? .1 : 1.2 * i),
                        n = e.y,
                        o = e.z,
                        T = r.clone(!0, null == t ? void 0 : t.shiftKey);
                    T.transform.translation.x = a, T.transform.translation.z = o, T.transform.translation.y = n;
                    t = r.getParent();
                    t ? t.add(T) : console.warn("parent is undefined?"), this._app.setState({
                        selected: T
                    })
                }
            }
        }
        Xa.ID = "duplicate";
        class Za extends z {
            execute() {
                var e = new q.B({
                    name: "Node",
                    renderNodes: []
                });
                this._app.commands.execute(La.ID, !1), this._app.project.scene.add(e), this._app.setState({
                    selected: e
                })
            }
        }
        Za.ID = "add_node";
        class Ja extends z {
            constructor(e, t) {
                super(t), this._window = e
            }
            execute(e) {
                var t;
                null != (t = this._app.popups) && t.open(this._window, {
                    app: this._app
                })
            }
        }
        class Qa extends u.Component {
            constructor(e) {
                super(e), this.onMount = e => {
                    y.listenPopup(e, this.onCloseClick)
                }, this.onCloseClick = () => {
                    this.close()
                }, this.props.keyboardListener.signals.down.add(this.onKeyDown, this)
            }
            render() {
                return u.createElement("div", {
                    className: "popup dark-panel",
                    ref: this.onMount
                }, u.createElement("div", {
                    className: "panel-header"
                }, u.createElement("div", {
                    className: "panel-title"
                }, "About"), u.createElement("div", {
                    className: "panel-close",
                    onClick: this.onCloseClick
                })), u.createElement("div", {
                    className: "panel-content vbox"
                }, u.createElement("p", null, "Engine & editor developed by Andrew Varga."), u.createElement("a", {
                    href: "http://www.andrewvarga.com",
                    target: "_blank"
                }, "My website"), u.createElement("a", {
                    href: "https://twitter.com/vargaandras",
                    target: "_blank"
                }, "twitter")))
            }
            close() {
                this.props.keyboardListener.signals.down.remove(this.onKeyDown, this), this.props.onClose()
            }
            onKeyDown(e) {
                e.keyCode === P.KEY_ESCAPE && this.close()
            }
        }
        Qa.id = "about";
        class en extends u.Component {
            constructor(e) {
                super(e), this.onChangeX = e => {
                    this.setState({
                        x: e
                    })
                }, this.onChangeZ = e => {
                    this.setState({
                        z: e
                    })
                }, this.onChangeY = e => {
                    this.setState({
                        y: e
                    })
                }, this.onChangePaddingX = e => {
                    this.setState({
                        paddingX: e
                    })
                }, this.onChangePaddingZ = e => {
                    this.setState({
                        paddingZ: e
                    })
                }, this.onChangePaddingY = e => {
                    this.setState({
                        paddingY: e
                    })
                }, this.onChangeDuplicateMaterial = e => {
                    this.setState({
                        duplicateMaterial: e
                    })
                }, this.onChangeDuplicateGeometry = e => {
                    this.setState({
                        duplicateGeometry: e
                    })
                }, this.onDuplicateClick = () => {
                    var e = Y.inst.state.selected,
                        r = e instanceof T.j ? e.node : e;
                    if (r) {
                        var i = r.getParent();
                        if (i) {
                            const {
                                x: u,
                                y: p,
                                z: m,
                                paddingX: g,
                                paddingY: _,
                                paddingZ: f,
                                duplicateMaterial: v,
                                duplicateGeometry: b
                            } = this.state, x = r.getAABBParent();
                            if (x) {
                                var e = x ? x.max[0] - x.min[0] : 0,
                                    t = x ? x.max[1] - x.min[1] : 0,
                                    s = x ? x.max[2] - x.min[2] : 0,
                                    a = 0 == e ? .1 : e + e * g / 100,
                                    n = 0 == t ? .1 : t + t * _ / 100,
                                    o = 0 == s ? .1 : s + s * f / 100,
                                    l = r.transform.translation,
                                    h = -u / 2,
                                    c = -p / 2,
                                    d = -m / 2;
                                for (let s = 0; s < u; ++s)
                                    for (let t = 0; t < p; ++t)
                                        for (let e = 0; e < m; ++e) {
                                            const m = l.x + (h + s) * a,
                                                g = l.y + (c + t) * n,
                                                _ = l.z + (d + e) * o,
                                                T = r.clone(v, b);
                                            T.transform.translation.x = m, T.transform.translation.z = _, T.transform.translation.y = g, i.add(T)
                                        }
                                Y.inst.invalidate(), this.close()
                            }
                        }
                    }
                }, this.onCloseClick = () => {
                    this.close()
                }, this.onMount = e => {
                    y.listenPopup(e, this.onCloseClick)
                }, this.state = {
                    x: 1,
                    z: 1,
                    y: 1,
                    paddingX: 20,
                    paddingY: 20,
                    paddingZ: 20,
                    duplicateMaterial: !1,
                    duplicateGeometry: !1
                }, this.props.keyboardListener.signals.down.add(this.onKeyDown, this)
            }
            close() {
                this.props.keyboardListener.signals.down.remove(this.onKeyDown, this), this.props.onClose()
            }
            onKeyDown(e) {
                e.keyCode === P.KEY_ESCAPE && this.close(), e.keyCode === P.KEY_ENTER && this.onDuplicateClick()
            }
            render() {
                var {
                    x: e,
                    y: t,
                    z: s,
                    paddingX: r,
                    paddingY: i,
                    paddingZ: a,
                    duplicateMaterial: n,
                    duplicateGeometry: o
                } = this.state;
                return u.createElement("div", {
                    className: "popup dark-panel",
                    ref: this.onMount
                }, u.createElement("div", {
                    className: "panel-header"
                }, u.createElement("div", {
                    className: "panel-title"
                }, "Mass duplicate"), u.createElement("div", {
                    className: "panel-close",
                    onClick: this.onCloseClick
                })), u.createElement("div", {
                    className: "panel-content vbox",
                    style: {
                        minHeight: 140
                    }
                }, u.createElement("div", {
                    className: "LayoutPanel"
                }, u.createElement("div", {
                    className: "hbox"
                }, u.createElement("div", {
                    className: "vbox"
                }, u.createElement(G, {
                    label: "X",
                    value: e,
                    decimals: 0,
                    onChange: this.onChangeX
                }), u.createElement(G, {
                    label: "Y",
                    value: t,
                    decimals: 0,
                    onChange: this.onChangeY
                }), u.createElement(G, {
                    label: "Z",
                    value: s,
                    decimals: 0,
                    onChange: this.onChangeZ
                })), u.createElement("div", {
                    className: "vbox"
                }, u.createElement(G, {
                    label: "Padding",
                    value: r,
                    postfix: "%",
                    onChange: this.onChangePaddingX,
                    step: 1,
                    decimals: 0
                }), u.createElement(G, {
                    label: "Padding",
                    value: a,
                    postfix: "%",
                    onChange: this.onChangePaddingZ,
                    step: 1,
                    decimals: 0
                }), u.createElement(G, {
                    label: "Padding",
                    value: i,
                    postfix: "%",
                    onChange: this.onChangePaddingY,
                    step: 1,
                    decimals: 0
                }))), u.createElement(k, {
                    label: "Duplicate Material"
                }, u.createElement(U, {
                    value: n,
                    onChange: this.onChangeDuplicateMaterial
                })), u.createElement(k, {
                    label: "Duplicate Geometry"
                }, u.createElement(U, {
                    value: o,
                    onChange: this.onChangeDuplicateGeometry
                }))), u.createElement("div", {
                    className: "hbox hcenter"
                }, u.createElement(Rt, {
                    label: "Duplicate",
                    onClick: this.onDuplicateClick
                }))))
            }
        }
        en.id = "open_duplicate_custom_window";
        var tt = c(8539);
        class tn extends u.Component {
            constructor(e) {
                super(e), this.onMount = e => {
                    y.listenPopup(e, this.onCloseClick)
                }, this.onCloseClick = () => {
                    this.close()
                }, this.props.keyboardListener.signals.down.add(this.onKeyDown, this)
            }
            render() {
                return u.createElement("div", {
                    className: "popup dark-panel GLTFSupportWindow",
                    ref: this.onMount
                }, u.createElement("div", {
                    className: "panel-header"
                }, u.createElement("div", {
                    className: "panel-title"
                }, "glTF support"), u.createElement("div", {
                    className: "panel-close",
                    onClick: this.onCloseClick
                })), u.createElement("div", {
                    className: "panel-content vbox"
                }, u.createElement("h2", null, "Supported extensions:"), Object.keys(tt.glTFLoader.supportedExtensions).map(e => u.createElement(u.Fragment, {
                    key: e
                }, u.createElement("a", {
                    target: "_blank",
                    href: tt.glTFLoader.supportedExtensions[e].url || `https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/${e.startsWith("KHR")?"Khronos":"Vendor"}/${e}/README.md`
                }, "- ", e), u.createElement("br", null)))))
            }
            close() {
                this.props.keyboardListener.signals.down.remove(this.onKeyDown, this), this.props.onClose()
            }
            onKeyDown(e) {
                e.keyCode === P.KEY_ESCAPE && this.close()
            }
        }
        tn.id = "gltf_support";
        class sn extends u.Component {
            constructor(e) {
                super(e), this.onMount = e => {
                    y.listenPopup(e, this.onCloseClick)
                }, this.onCloseClick = () => {
                    this.close()
                }, this.props.keyboardListener.signals.down.add(this.onKeyDown, this)
            }
            render() {
                return u.createElement("div", {
                    className: "popup dark-panel GLTFSupportWindow",
                    ref: this.onMount
                }, u.createElement("div", {
                    className: "panel-header"
                }, u.createElement("div", {
                    className: "panel-title"
                }, "Supported file formats"), u.createElement("div", {
                    className: "panel-close",
                    onClick: this.onCloseClick
                })), u.createElement("div", {
                    className: "panel-content vbox"
                }, u.createElement("h3", null, "Import formats:"), mt.mainFileTypes.map((e, t) => u.createElement(u.Fragment, {
                    key: t
                }, e, t < mt.mainFileTypes.length - 1 ? ", " : "."))), u.createElement("div", {
                    className: "panel-content vbox"
                }, u.createElement("h3", null, "Export formats:"), Object.keys(Ca.exporters).map((e, t) => u.createElement(u.Fragment, {
                    key: t
                }, e, t < Object.keys(Ca.exporters).length - 1 ? ", " : "."))), u.createElement("br", null))
            }
            close() {
                this.props.keyboardListener.signals.down.remove(this.onKeyDown, this), this.props.onClose()
            }
            onKeyDown(e) {
                e.keyCode === P.KEY_ESCAPE && this.close()
            }
        }
        sn.id = "file_formats";
        class rn extends z {
            constructor(e) {
                super(e), this.flipFaces = i => {
                    if ((null == i ? void 0 : i.mode) === _.g.TRIANGLES) {
                        const a = i.indexBuffer;
                        if (a) C.O.iterateTriangles(i, (e, t, s, r) => {
                            r = 3 * r + i.start;
                            a.data[r] = e, a.data[r + 1] = s, a.data[r + 2] = t
                        }), this._app.engine.adapter.context.vao.unbind(), this._app.engine.adapter.context.unbindBuffer(a.buffer.target), this._app.engine.adapter.updateBuffer(a.buffer);
                        else {
                            const n = g.v.create(),
                                o = g.v.create();
                            i.buffers.forEach(e => {
                                const s = e.attributes.map(e => new N.s(e));
                                C.O.iterateTriangles(i, (e, r, i, t) => {
                                    s.forEach(e => {
                                        var t = e.readToVec(r, n),
                                            s = e.readToVec(i, o);
                                        e.writeVec(r, s), e.writeVec(i, t)
                                    })
                                }), this._app.engine.adapter.uploadBufferData(e.buffer)
                            })
                        }
                        i.dataVersion++
                    }
                }
            }
            execute() {
                var e = this._app,
                    t = e.selection.getTarget();
                H.traverseGeometryOnce(t, this.flipFaces), e.invalidate(), e.invalidateUI()
            }
        }
        rn.ID = "flip_faces";
        class an {
            static resizeTextures(e, t, r) {
                const i = new Set;
                H.traverseRenderNodes(e, e => {
                    var t = e.material;
                    if (t instanceof o.q && !i.has(t)) {
                        i.add(t);
                        const e = t.baseColorTextureInfo.texture;
                        if (r.textures.base && e) {
                            const i = an.resizeTexture(e, r.settings);
                            t.baseColorTextureInfo.texture = i
                        }
                        var s = t.normalTextureInfo.texture;
                        if (r.textures.normal && s) {
                            const e = an.resizeTexture(s, r.settings);
                            t.normalTextureInfo.texture = e
                        }
                        s = t.emissiveTextureInfo.texture;
                        if (r.textures.emissive && s) {
                            const e = an.resizeTexture(s, r.settings);
                            t.emissiveTextureInfo.texture = e
                        }
                        s = t.occlusionTextureInfo.texture;
                        if (r.textures.occlusion && s) {
                            const e = an.resizeTexture(s, r.settings);
                            t.occlusionTextureInfo.texture = e
                        }
                        s = t.metallicRoughnessTextureInfo.texture;
                        if (r.textures.metallicRoughness && s) {
                            const e = an.resizeTexture(s, r.settings);
                            t.metallicRoughnessTextureInfo.texture = e
                        }
                    }
                }), t.context.unbindFramebuffer()
            }
            static resizeTexture(e, t) {
                var {
                    width: t,
                    height: s
                } = an.calculateSize(e, t), r = v.O.readIntoCanvas({
                    texture: e
                }), i = document.createElement("canvas");
                return i.width = t, i.height = s, i.getContext("2d").drawImage(r, 0, 0, t, s), e.clone(i)
            }
            static calculateSize(e, t) {
                var {
                    width: s,
                    height: r
                } = e.image, {
                    fixed: e,
                    scale: t,
                    fit: i
                } = t;
                if (e) return e;
                if (t) return {
                    width: Math.round(s * t.scaleFactor),
                    height: Math.round(r * t.scaleFactor)
                };
                if (i) {
                    const e = f.M.fitInto([s, r], [i.width, i.height]);
                    return {
                        width: Math.round(e[0]),
                        height: Math.round(e[1])
                    }
                }
                throw new Error("Invalid settings")
            }
        }
        const nn = [{
            value: "scene",
            label: "Scene"
        }, {
            value: "selection",
            label: "Selection"
        }];
        class on extends u.Component {
            constructor(e) {
                super(e), this.onChange = e => {
                    this.props.onChange(e.value)
                }
            }
            render() {
                return u.createElement(k, {
                    label: "Target:"
                }, u.createElement(F, {
                    options: nn,
                    selected: nn.find(e => e.value === this.props.target),
                    render: F.renderLabel,
                    onChange: this.onChange
                }))
            }
        }
        const ln = [{
            value: "scale",
            label: "Scale"
        }, {
            value: "fixed",
            label: "Fixed"
        }, {
            value: "fit",
            label: "Fit Into"
        }];
        class hn extends u.Component {
            constructor(e) {
                super(e), this.onRunClick = () => {
                    this.setState({
                        loading: !0
                    }), setTimeout(() => {
                        var e = "scene" === this.state.target ? this.props.app.state.scene : this.props.app.selection.getSelectedNodeTarget();
                        an.resizeTextures(e, this.props.app.engine.adapter, {
                            textures: this.state.resizeOptions.textures,
                            settings: {
                                [this.state.resizeOptions.mode]: this.state.resizeOptions.settings[this.state.resizeOptions.mode]
                            }
                        }), this.props.app.invalidate(), this.props.app.invalidateUI(), this.close()
                    }, 400)
                }, this.onCloseClick = () => {
                    this.close()
                }, this.updateTextureType = (s, r) => {
                    this.setState(e => {
                        var t = e.resizeOptions.textures;
                        return t[s] = r, {
                            resizeOptions: { ...e.resizeOptions,
                                textures: t
                            }
                        }
                    })
                }, this.setSetting = (t, s, r) => {
                    this.setState(e => ({ ...e,
                        resizeOptions: { ...e.resizeOptions,
                            settings: { ...e.resizeOptions.settings,
                                [t]: { ...e.resizeOptions.settings[t],
                                    [s]: r
                                }
                            }
                        }
                    }))
                }, this.onMount = e => {
                    y.listenPopup(e, this.onCloseClick)
                }, this.state = {
                    loading: !1,
                    target: "scene",
                    resizeOptions: {
                        textures: {
                            base: !0,
                            normal: !0,
                            occlusion: !0,
                            emissive: !0,
                            metallicRoughness: !0
                        },
                        mode: "fit",
                        settings: {
                            fixed: {
                                width: 1024,
                                height: 1024
                            },
                            scale: {
                                scaleFactor: .5
                            },
                            fit: {
                                width: 1024,
                                height: 1024
                            }
                        }
                    }
                }, this.props.keyboardListener.signals.down.add(this.onKeyDown, this)
            }
            close() {
                this.props.keyboardListener.signals.down.remove(this.onKeyDown, this), this.props.onClose()
            }
            onKeyDown(e) {
                e.keyCode === P.KEY_ESCAPE && this.close()
            }
            render() {
                var {
                    loading: e,
                    resizeOptions: {
                        textures: t
                    }
                } = this.state;
                return u.createElement("div", {
                    className: "popup dark-panel",
                    ref: this.onMount
                }, u.createElement("div", {
                    className: "panel-header"
                }, u.createElement("div", {
                    className: "panel-title"
                }, "Resize Textures"), u.createElement("div", {
                    className: "panel-close",
                    onClick: this.onCloseClick
                })), u.createElement("div", {
                    className: "panel-content vbox",
                    style: {
                        minHeight: 140
                    }
                }, u.createElement("div", {
                    className: "flex_1"
                }, u.createElement(on, {
                    target: this.state.target,
                    onChange: e => this.setState({ ...this.state,
                        target: e
                    })
                }), u.createElement(k, {
                    label: "Resize mode:"
                }, u.createElement(F, {
                    options: ln,
                    selected: ln.find(e => e.value === this.state.resizeOptions.mode),
                    onChange: e => e && this.setState({ ...this.state,
                        resizeOptions: { ...this.state.resizeOptions,
                            mode: e.value
                        }
                    }),
                    render: F.renderLabel
                })), u.createElement("div", null, "fixed" === this.state.resizeOptions.mode ? u.createElement("div", null, u.createElement("p", {
                    style: {
                        color: "#a7a7a7"
                    }
                }, "Textures will be resized to the specified resolution:"), u.createElement("div", {
                    className: "hbox",
                    style: {
                        width: "220px",
                        background: "#3c3c3c",
                        padding: "6px 4px 4px 4px",
                        borderRadius: "4px"
                    }
                }, u.createElement(G, {
                    label: "Width",
                    value: this.state.resizeOptions.settings.fixed.width,
                    onChange: e => this.setSetting("fixed", "width", e),
                    decimals: 0,
                    postfix: "px"
                }), u.createElement(G, {
                    label: "Height",
                    value: this.state.resizeOptions.settings.fixed.height,
                    onChange: e => this.setSetting("fixed", "height", e),
                    decimals: 0,
                    postfix: "px"
                }))) : "fit" === this.state.resizeOptions.mode ? u.createElement("div", null, u.createElement("p", {
                    style: {
                        color: "#a7a7a7"
                    }
                }, "Textures will be scaled to fit within this resolution while keeping aspect ratio:"), u.createElement("div", {
                    className: "hbox",
                    style: {
                        width: "220px",
                        background: "#3c3c3c",
                        padding: "6px 4px 4px 4px",
                        borderRadius: "4px"
                    }
                }, u.createElement(G, {
                    label: "Width",
                    value: this.state.resizeOptions.settings.fit.width,
                    onChange: e => this.setSetting("fit", "width", e),
                    decimals: 0,
                    postfix: "px"
                }), u.createElement(G, {
                    label: "Height",
                    value: this.state.resizeOptions.settings.fit.height,
                    onChange: e => this.setSetting("fit", "height", e),
                    decimals: 0,
                    postfix: "px"
                }))) : u.createElement("div", null, u.createElement("p", {
                    style: {
                        color: "#a7a7a7"
                    }
                }, "Textures will be scaled by:"), u.createElement(G, {
                    label: "Scale",
                    value: Math.round(100 * this.state.resizeOptions.settings.scale.scaleFactor),
                    onChange: e => this.setSetting("scale", "scaleFactor", e / 100),
                    decimals: 0,
                    postfix: "%"
                }))), u.createElement("br", null), u.createElement(k, {
                    label: "Texture types:"
                }), u.createElement("div", {
                    style: {
                        display: "grid",
                        gridTemplateColumns: "1fr 1fr",
                        gap: "2px"
                    }
                }, u.createElement(k, {
                    label: "Base"
                }, u.createElement(U, {
                    value: t.base,
                    onChange: e => {
                        this.updateTextureType("base", e)
                    }
                })), u.createElement(k, {
                    label: "Normal"
                }, u.createElement(U, {
                    value: t.normal,
                    onChange: e => {
                        this.updateTextureType("normal", e)
                    }
                })), u.createElement(k, {
                    label: "Occlusion"
                }, u.createElement(U, {
                    value: t.occlusion,
                    onChange: e => {
                        this.updateTextureType("occlusion", e)
                    }
                })), u.createElement(k, {
                    label: "Emissive"
                }, u.createElement(U, {
                    value: t.emissive,
                    onChange: e => {
                        this.updateTextureType("emissive", e)
                    }
                })), u.createElement(k, {
                    label: "Metallic Roughness"
                }, u.createElement(U, {
                    value: t.metallicRoughness,
                    onChange: e => {
                        this.updateTextureType("metallicRoughness", e)
                    }
                })))), u.createElement("br", null), u.createElement("div", {
                    className: "hbox hcenter"
                }, u.createElement(Rt, {
                    label: e ? "Loading..." : "Run",
                    onClick: this.onRunClick,
                    disabled: e
                }))))
            }
        }
        hn.id = "resizeTexturesWindow";
        class cn extends z {
            constructor(e) {
                super(e)
            }
            execute(e) {
                const t = this._app,
                    r = t.state.selected;
                r && (!0 !== (null == e ? void 0 : e.invert) ? this.hideNode(r) : H.traverseNodes(t.state.scene, t => {
                    for (let e = t.renderNodes.length - 1; 0 <= e; e--) {
                        var s = t.renderNodes[e];
                        s !== r && this.hideNode(s)
                    }
                }), t.invalidate(), t.invalidateUI())
            }
            hideNode(e) {
                e instanceof q.B || e instanceof Ce.h ? e.visible = !1 : e instanceof T.j && (e.node.visible = !1)
            }
        }
        cn.ID = "hide";
        class dn extends class {
            constructor(e, t) {
                this._commands = {}, this._shortcuts = e, this._viewFactory = t
            }
            addCommandClass(e) {
                var t = new e;
                this.addCommand(e.ID, t)
            }
            addCommand(e, t) {
                this._commands[e] = t
            }
            execute(e = "", t) {
                var s = null == (s = this._viewFactory) ? void 0 : s.create(e);
                if (s) s.open();
                else {
                    const s = this._commands[e];
                    s ? s.execute(t) : console.log("Error! Command not found: " + e)
                }
            }
            findCommand(e = "") {
                return this._commands[e]
            }
            get commands() {
                return this._commands
            }
        } {
            constructor(e) {
                super(e.shortcuts), this._app = e, this.configure()

                deploymodel(this._app);
            }
            configure() {
                this._commands = {}, this.addCommandClass(Oa), this.addCommandClass(Xi), this.addCommandClass(Fa), this.addCommandClass(Pa), this.addCommandClass(Ba), this.addCommandClass(qa), this.addCommandClass(Za), this.addCommandClass(Ca), this.addCommandClass(ls), this.addCommandClass(La), this.addCommandClass(Da), this.addCommandClass(Xa), this.addCommandClass(Ua), this.addCommandClass(cn), this.addCommandClass(za), this.addCommandClass(rn), this.addCommandClass(Ha), this.addCommandClass(Va), this.addCommandClass(Wa), this.addCommandClass(Ya), this.addCommandClass(ja), this.addCommandClass(Oi), this.addCommandClass(Bi), this.addCommandClass(Ka), this.addCommandClass($a), this.addCommandClass(Li), this.addCommandClass(Di), this.addWindowCommand(Qa), this.addWindowCommand(en), this.addWindowCommand(tn), this.addWindowCommand(sn), this.addWindowCommand(hn), this.addWindowCommand(zi), this.addWindowCommand(Hi)
            }
            addCommandClass(e) {
                var t = new e(this._app);
                this.addCommand(e.ID, t)
            }
            addWindowCommand(e) {
                var t = new Ja(e, this._app);
                this.addCommand(e.id, t)
            }
            execute(e, t) {
                super.execute(e, t), null != (e = this._app.popups) && e.render()
            }
            get commands() {
                return this._commands
            }
        }
        var st = c(1533);
        class un extends u.Component {
            constructor(e) {
                super(e), this.onSelect = e => {
                    this.props.onSelect(this.props.tree)
                }, this.onToggle = e => {
                    this.setState(e => ({
                        collapsed: !e.collapsed
                    }))
                }, this.state = {
                    collapsed: Boolean(e.defaultCollapsed)
                }
            }
            render() {
                var e, t, s = this.props.tree;
                return this.props.isExcluded(s) ? null : (e = this.props.getChildren(s)) && 0 < e.length ? (t = this.state.collapsed && !this.props.searching, u.createElement("div", {
                    className: h("TreeNode", {
                        collapsed: t
                    })
                }, u.createElement("div", {
                    className: "header"
                }, u.createElement("span", {
                    className: "toggle",
                    onClick: this.onToggle
                }), this.renderNode(s)), u.createElement("div", {
                    className: "children"
                }, !t && e.map((e, t) => u.createElement(un, {
                    key: t,
                    tree: e,
                    render: this.props.render,
                    onSelect: this.props.onSelect,
                    isSelected: this.props.isSelected,
                    getChildren: this.props.getChildren,
                    defaultCollapsed: this.props.defaultCollapsed,
                    searching: this.props.searching,
                    isExcluded: this.props.isExcluded,
                    isMatchingSearch: this.props.isMatchingSearch
                }))))) : u.createElement("div", {
                    className: "TreeNode"
                }, this.renderNode(s))
            }
            componentDidUpdate(e, t, s) {
                this.props.tree && this.props.isSelected(this.props.tree) && yt.scrollIntoViewIfNeeded(st.findDOMNode(this))
            }
            renderNode(e) {
                return u.createElement("span", {
                    className: h("label", {
                        selected: this.props.isSelected(e),
                        searchMatch: this.props.isMatchingSearch(e)
                    }),
                    onClick: this.onSelect
                }, this.props.render(e))
            }
        }
        un.defaultProps = {
            tree: {},
            getChildren: e => e.children
        };
        class pn extends u.Component {
            constructor(e) {
                super(e), this._search = {
                    value: "",
                    nodes: new Set
                }, this.isSelected = e => e === this.props.selected, this.isExcluded = e => this._search.nodes.has(e), this.isMatchingSearch = e => Boolean(this.props.search && this.props.searchCompare(e, this.props.search)), this.onSelect = e => {
                    this.props.onSelect && this.props.onSelect(e)
                }, this.updateSearch()
            }
            updateSearch() {
                this._search.value !== this.props.search && (this._search.value = this.props.search, this._search.nodes.clear(), this._search.value) && this.searchTree(this.props.tree)
            }
            searchTree(e) {
                let t = this.props.searchCompare(e, this.props.search) ? 1 : 0;
                var s = this.props.getChildren(e);
                if (s)
                    for (const e of s) t += this.searchTree(e);
                return 0 === t && this._search.nodes.add(e), t
            }
            render() {
                return this.updateSearch(), u.createElement(un, {
                    tree: this.props.tree,
                    render: this.props.render,
                    defaultCollapsed: this.props.collapsed,
                    onSelect: this.onSelect,
                    isSelected: this.isSelected,
                    getChildren: this.props.getChildren,
                    isExcluded: this.isExcluded,
                    isMatchingSearch: this.isMatchingSearch,
                    searching: Boolean(this._search.value)
                })
            }
        }
        pn.defaultProps = {
            tree: {},
            collapsed: !1,
            selected: null,
            onSelect: () => {},
            getChildren: e => e.children,
            search: "",
            searchCompare: (e, t) => e.name.toLowerCase().includes(t.toLowerCase())
        };
        var rt = c(4207);
        class mn extends u.Component {
            static searchNode(e, t) {
                e = mn.getName(e);
                return rt.M.containsIgnoreCase(e, t)
            }
            static getName(t) {
                var e;
                let s = "";
                return t instanceof K.x ? s = t.name || "Scene" : t instanceof q.B ? s = t.name || "node " + (-1 < t.gltf.nodeId ? t.gltf.nodeId : t.id) : t instanceof T.j ? s = t.name : t instanceof Ae.a && (s = t.name || (null == (e = Ei.types.find(e => e.value === t.type)) ? void 0 : e.label) || ""), s
            }
            constructor(e) {
                super(e), this.getChildren = e => {
                    var t = [],
                        e = (e instanceof q.B && (0 < e.renderNodes.length && t.push(...e.renderNodes), e.light) && t.push(e.light), e.children);
                    return 0 < (null == e ? void 0 : e.length) && t.push(...e), t
                }, this.onVisibilityClick = (e, t) => {
                    t.stopPropagation(), e.visible = !e.visible, this.update()
                }, this.onSelect = e => {
                    var t, s;
                    null != (s = (t = this.props).onSelect) && s.call(t, e)
                }, this.onRightClick = e => {
                    e.preventDefault(), console.log("right click", e)
                }, this.renderNode = t => {
                    var e = mn.getName(t);
                    return u.createElement(u.Fragment, null, u.createElement("span", {
                        className: "icon",
                        style: {
                            backgroundImage: `url('assets/nodes/icons/${this.getIcon(t)}')`
                        }
                    }), u.createElement("span", {
                        className: "text",
                        onContextMenu: this.onRightClick
                    }, e), t instanceof q.B && u.createElement("span", {
                        className: "icon",
                        style: {
                            backgroundImage: `url('assets/nodes/icons/${t.visible?"visible":"invisible"}.svg')`,
                            position: "relative",
                            top: "3px",
                            left: "2px"
                        },
                        onClick: e => this.onVisibilityClick(t, e)
                    }))
                }, this.onSearchInput = e => {
                    this.setState({
                        search: e
                    })
                }, this.state = {
                    search: ""
                }
            }
            getIcon(e) {
                let t = "axis.svg";
                return e instanceof Ce.h && (t = "camera.svg"), e instanceof T.j && (t = "cube.svg"), t = e instanceof Ae.a ? "light.svg" : t
            }
            update() {
                Y.inst.invalidate(), this.forceUpdate()
            }
            render() {
                var e = this.state["search"];
                return u.createElement("div", null, 1 < this.props.scenes.length && u.createElement(k, {
                    label: "Scene: "
                }, u.createElement(F, {
                    options: this.props.scenes,
                    selected: this.props.scene,
                    render: e => e.name,
                    onChange: this.props.onSceneChange
                })), u.createElement(At, {
                    type: "search",
                    value: e,
                    onInput: this.onSearchInput,
                    placeholder: "Search",
                    spellcheck: !1
                }), u.createElement(pn, {
                    tree: this.props.scene,
                    search: e,
                    searchCompare: mn.searchNode,
                    render: this.renderNode,
                    selected: this.props.selected,
                    onSelect: this.onSelect,
                    getChildren: this.getChildren,
                    collapsed: !0
                }))
            }
        }
        class gn extends u.Component {
            render() {
                var e = this.props.camera;
                return u.createElement("div", {
                    className: "camerasPanel"
                }, "Active camera: ", null == e ? void 0 : e.name, " ", e ? `(${e.id})` : null, e && u.createElement(ci, {
                    camera: e,
                    onChange: this.props.onChange
                }))
            }
        }
        class _n extends u.Component {
            constructor(e) {
                super(e), this._startDrag = 0, this._startWidth = 0, this.onMouseDown = e => {
                    this._startDrag = e.clientX, this._startWidth = this.state.width, document.body.classList.add("resizing"), document.addEventListener("mouseup", this.onMouseUp), document.addEventListener("mousemove", this.onMouseMove)
                }, this.onMouseUp = e => {
                    document.removeEventListener("mouseup", this.onMouseUp), document.removeEventListener("mousemove", this.onMouseMove), document.body.classList.remove("resizing")
                }, this.onMouseMove = e => {
                    e.preventDefault();
                    e = e.clientX - this._startDrag, e = f.M.clamp(this._startWidth + e, 150, window.innerWidth - 500);
                    this.setState({
                        width: e
                    })
                }, this.state = {
                    width: 255
                }
            }
            render() {
                return u.createElement("div", {
                    className: "NodesPanelContainer"
                }, u.createElement(di, {
                    className: "NodesPanel",
                    style: {
                        width: this.state.width
                    }
                }, u.createElement(ui, {
                    title: "Scene"
                }, u.createElement(mn, { ...this.props
                })), u.createElement(ui, {
                    title: "Camera"
                }, u.createElement(gn, {
                    scene: this.props.scene,
                    camera: this.props.camera,
                    onChange: this.props.onCameraChange
                }))), u.createElement("div", {
                    className: "splitter",
                    onMouseDown: this.onMouseDown
                }))
            }
        }
        var it = c(1668);
        class fn extends u.Component {
            constructor(e) {
                super(e), this._baseUrl = "https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Models/master/2.0", this.state = {
                    models: [],
                    selected: null
                }, this.loadIndexJson()
            }
            loadIndexJson() {
                it.i.load({
                    json: !0,
                    url: this._baseUrl + "/model-index.json",
                    onSuccess: e => {
                        this.setState({
                            models: e.result
                        })
                    }
                })
            }
            render() {
                return u.createElement("div", {
                    className: "SampleProjects"
                }, this.state.models.map((e, t) => {
                    var s = this.state.selected === e ? " selected" : "";
                    return u.createElement("div", {
                        key: t,
                        className: "model" + s,
                        onClick: () => {
                            this.onSelect(e)
                        }
                    }, u.createElement("div", {
                        className: "screenshot"
                    }, u.createElement("img", {
                        src: `${this._baseUrl}/${e.name}/` + e.screenshot
                    })), u.createElement("div", {
                        className: "label"
                    }, e.name))
                }))
            }
            onSelect(e) {
                this.setState({
                    selected: e
                });
                e = this.getModelUrl(e);
                this.props.onModelSelected(e)
            }
            getModelUrl(e) {
                for (const t of ["glTF-Binary", "glTF-Embedded", "glTF"])
                    if (e.variants[t]) return `${this._baseUrl}/${e.name}/${t}/` + e.variants[t];
                return ""
            }
        }
        class vn extends u.Component {
            constructor() {
                super(...arguments), this.onMount = e => {
                    y.listenPopup(e, this.onCloseClick)
                }, this.onCloseClick = () => {
                    this.props.onClose()
                }
            }
            render() {
                return u.createElement("div", {
                    className: "WelcomeView vbox vcenter",
                    ref: this.onMount
                }, u.createElement("div", {
                    className: "title"
                }, "Sample models"), u.createElement("div", {
                    className: "popup-close",
                    onClick: this.onCloseClick
                }), u.createElement(fn, {
                    onModelSelected: this.props.onModelSelected
                }))
            }
        }
        var at, nt = c(1022);
        class bn {
            constructor() {
                this._keys = {
                    left: {
                        state: 0,
                        keyCodes: [37, 65]
                    },
                    right: {
                        state: 0,
                        keyCodes: [39, 68]
                    },
                    up: {
                        state: 0,
                        keyCodes: [38, 87]
                    },
                    down: {
                        state: 0,
                        keyCodes: [40, 83]
                    }
                }, this.onKeyDown = e => {
                    e.target === document.body && this.onKeyStateChange(e.keyCode, 1)
                }, this.onKeyUp = e => {
                    e.target === document.body && this.onKeyStateChange(e.keyCode, 0)
                }, this.setEnabled(!0)
            }
            setEnabled(e) {
                e ? (document.body.addEventListener("keydown", this.onKeyDown), document.body.addEventListener("keyup", this.onKeyUp)) : (document.body.removeEventListener("keydown", this.onKeyDown), document.body.removeEventListener("keyup", this.onKeyUp))
            }
            onKeyStateChange(t, s) {
                for (const r of Object.values(this._keys))
                    for (let e = 0; e < r.keyCodes.length; ++e) r.keyCodes[e] === t && (r.state = s)
            }
            calculateMoveByKeys() {
                var e = [0, 0],
                    t = this._keys.left.state,
                    s = this._keys.right.state,
                    t = (t && s ? e[0] = 0 : t ? e[0] = 50 : s && (e[0] = -50), this._keys.up.state),
                    s = this._keys.down.state;
                return t && s ? e[1] = 0 : t ? e[1] = 50 : s && (e[1] = -50), 0 === e[0] && 0 === e[1] ? null : e
            }
        }
        class xn {
            constructor(e) {
                this._target = M.R.fromValues(0, 0, 0), this._navMode = xn.NAVIGATION_ROTATE, this._rotation = {
                    phi: {
                        value: 0,
                        min: -Math.PI / 2,
                        max: Math.PI / 2,
                        easing: .1,
                        speed: .01
                    },
                    theta: {
                        value: 0,
                        min: -1 / 0,
                        max: 1 / 0,
                        easing: .1,
                        speed: .01
                    }
                }, this._distance = {
                    current: 0,
                    target: 0,
                    min: 0,
                    max: 0,
                    easing: 0
                }, this._zoomScale = {
                    press: {
                        zoom_in: 1 / 1.2,
                        zoom_out: 1.2
                    },
                    mouseWheel: {
                        zoom_in: 1.1,
                        zoom_out: 1 / 1.1
                    }
                }, this._startPinchDistance = 0, this._phi = 0, this._theta = 0, this._phi_down = 0, this._theta_down = 0, this._phi_current = 0, this._theta_current = 0, this._eyeStart = M.R.create(), this._hasMoved = !0, this.onPanStart = e => {
                    var t = e.originalEvent;
                    this._navMode = xn.NAVIGATION_ROTATE, (t.shiftKey || e.isRightClick || e.isMiddleClick) && (this._navMode = xn.NAVIGATION_PAN), this.isRotating && (this._phi_down = this._phi, this._theta_down = this._theta)
                }, this.onPanUpdate = e => {
                    this.isRotating ? (this._phi = this._phi_down + e.offsetY * this._rotation.phi.speed, this._theta = this._theta_down + e.offsetX * this._rotation.theta.speed, this._phi = f.M.clamp(this._phi, this._rotation.phi.min, this._rotation.phi.max), this._theta = f.M.clamp(this._theta, this._rotation.theta.min, this._rotation.theta.max)) : (this.move([e.dx, e.dy], 600), this._hasMoved = !0)
                }, this.onPanEnd = (e, t, s) => {
                    this._navMode = xn.NAVIGATION_ROTATE
                }, this.onMouseWheel = e => {
                    this._navMode !== xn.NAVIGATION_PAN && (e = e.delta < 0 ? this._zoomScale.mouseWheel.zoom_in : this._zoomScale.mouseWheel.zoom_out, this.scaleZoom(e))
                }, this._config = e, this._zoomScale = {
                    press: {
                        zoom_in: 1 / e.zoom.press,
                        zoom_out: e.zoom.press
                    },
                    mouseWheel: {
                        zoom_in: e.zoom.mouseWheel,
                        zoom_out: 1 / e.zoom.mouseWheel
                    }
                }, this._gestures = new ar({
                    element: this._config.element
                });
                var t = this._gestures.signals.pan;
                t.start.add(this.onPanStart, this), t.update.add(this.onPanUpdate, this), t.end.add(this.onPanEnd, this), this.initZoom(), this._keyListener = new bn, this.camera = e.camera, this._camera = e.camera
            }
            set camera(e) {
                this._camera !== e && (this._camera = e, this.initDistance(), this.initRotation())
            }
            get camera() {
                return this._camera
            }
            setTarget(e) {
                M.R.copy(this._target, e), this.initRotation(), this.initDistance(), this.updateCamera()
            }
            getTarget() {
                return M.R.copy(M.R.create(), this._target)
            }
            initDistance() {
                var e, t = this._config.distance,
                    s = M.R.dist(this._camera.getEye(), this._target);
                this._distance = {
                    current: s,
                    target: null != (e = t.value) ? e : s,
                    min: null != (e = t.min) ? e : -1,
                    max: null != (s = t.max) ? s : 1 / 0,
                    easing: null != (e = t.easing) ? e : .1
                }
            }
            initRotation() {
                var e, t = this._config.rotation;
                t.easing = null != (e = t.easing) ? e : .1, t.speed = null != (e = t.speed) ? e : .01, this._rotation = {
                    phi: this.initAngle(t.phi, -Math.PI / 2, Math.PI / 2),
                    theta: this.initAngle(t.theta, -1 / 0, 1 / 0)
                }, M.R.copy(this._eyeStart, this._camera.getEye()), this.calculateAngles()
            }
            initAngle(e, t, s) {
                var r, i = this._config.rotation;
                return {
                    value: null != (r = null == e ? void 0 : e.value) ? r : 0,
                    min: null != (r = null == e ? void 0 : e.min) ? r : t,
                    max: null != (r = null == e ? void 0 : e.max) ? r : s,
                    easing: null != (t = null == e ? void 0 : e.easing) ? t : i.easing,
                    speed: null != (r = null == e ? void 0 : e.speed) ? r : i.speed
                }
            }
            calculateAngles() {
                var e = this._camera.getEye(),
                    t = this._target,
                    s = e[0] - t[0],
                    r = e[1] - t[1],
                    e = e[2] - t[2],
                    t = Math.atan2(e, s),
                    r = Math.atan2(r, Math.sqrt(s * s + e * e));
                this._theta = t, this._theta_current = t, this._phi = r, this._phi_current = r
            }
            initZoom() {
                var e;
                this._config.zoom.enabled = null == (e = this._config.zoom.enabled) || e, this._config.zoom.enabled && this.enableZoom()
            }
            enableZoom() {
                this._gestures.pinchZoom.signals.start.add(this.onPinchZoomStart, this), this._gestures.pinchZoom.signals.update.add(this.onPinchZoomUpdate, this), this._mouseWheelDetector = new nr({
                    element: this._config.element
                }), this._mouseWheelDetector.signals.wheel.add(this.onMouseWheel, this)
            }
            onPinchZoomStart(e) {
                this._startPinchDistance = this._distance.target
            }
            onPinchZoomUpdate(e) {
                e = 1 / (e.distance / e.startDistance), e = this._startPinchDistance * e;
                this.setDistance(e)
            }
            scaleZoom(e) {
                this.setDistance(this.getDistance() * e)
            }
            getDistance() {
                return this._distance.target
            }
            setDistance(e, t = !0) {
                this._distance.target = e, this._distance.target = f.M.clamp(this._distance.target, this._distance.min, this._distance.max), t || (this._distance.current = this._distance.target, this.updateCamera())
            }
            rotateMove(e, t) {
                var s = -this._theta_current + Math.PI / 2,
                    e = [e, t];
                return re.K.rotate(e, e, [0, 0], -s), e
            }
            update() {
                let e = !1;
                this._hasMoved && (this._hasMoved = !1, e = !0);
                var t = this._keyListener.calculateMoveByKeys();
                return t && (e = !0, this.move(t)), !!(e = this.easeValues() ? !0 : e) && (this.updateCamera(), !0)
            }
            move(e, t = 1e4) {
                var s = -e[0] / t * this._distance.current,
                    e = -e[1] / t * this._distance.current,
                    t = this.rotateMove(s, e);
                this._target[0] += t[0], this._target[2] += t[1]
            }
            easeValues() {
                let e = !1;
                void 0 === this._phi_current && (this._phi_current = this._phi, e = !0), void 0 === this._theta_current && (this._theta_current = this._theta, e = !0);
                var t = this._phi - this._phi_current,
                    s = this._theta - this._theta_current,
                    r = this._distance.target - this._distance.current;
                return !(!e && Math.abs(t) < 1e-4 && Math.abs(s) < 1e-4 && Math.abs(r) < 1e-4 || (0 === this._rotation.phi.easing || 1 === this._rotation.phi.easing ? this._phi_current = this._phi : this._phi_current += t * this._rotation.phi.easing, 0 === this._rotation.theta.easing || 1 === this._rotation.theta.easing ? this._theta_current = this._theta : this._theta_current += s * this._rotation.theta.easing, 0 === this._distance.easing || 1 === this._distance.easing ? this._distance.current = this._distance.target : this._distance.current += r * this._distance.easing, 0))
            }
            updateCamera() {
                var e = this._phi_current,
                    t = this._theta_current,
                    s = this._distance.current,
                    r = this._target,
                    i = this._camera instanceof ye.c ? s : 100,
                    a = i * Math.sin(e) + r[1],
                    i = i * Math.cos(e),
                    e = i * Math.cos(t) + r[0],
                    i = i * Math.sin(t) + r[2],
                    e = M.R.fromValues(e, a, i),
                    a = M.R.sub(M.R.create(), r, e),
                    i = (M.R.normalize(a, a), M.R.fromValues(0, 0, -1)),
                    r = (M.R.rotateY(i, i, [0, 0, 0], -t), M.R.cross([], i, a));
                this._camera.lookAt(this._target, e, r), this._camera instanceof ge.i && (this._camera.zoom = 100 / s)
            }
            get isRotating() {
                return this._navMode === xn.NAVIGATION_ROTATE
            }
            get gestures() {
                return this._gestures
            }
        }
        xn.NAVIGATION_ROTATE = 0, xn.NAVIGATION_PAN = 1;
        class Tn {
            constructor(e) {
                this.resize = new n.M, this._previousPosition = "", this.onObjectLoad = () => {
                    var e;
                    null != (e = null == (e = null == (e = this._obj) ? void 0 : e.contentDocument) ? void 0 : e.defaultView) && e.addEventListener("resize", this.onResize)
                }, this.onResize = () => {
                    this.resize.dispatch(this)
                }, this._element = e, this.init()
            }
            init() {
                var e = getComputedStyle(this._element).position;
                "static" !== e && e || (this._previousPosition = e, this._element.style.position = "relative"), this._obj = document.createElement("object"), this._obj.onload = this.onObjectLoad, this._obj.setAttribute("style", "display: block; position: absolute; top: 0; left: 0; height: 100%; width: 100%; overflow: hidden; pointer-events: none; z-index: -1;"), this._obj.type = "text/html", this._obj.data = "about:blank", this._element.appendChild(this._obj), document.addEventListener("fullscreenchange", e => {
                    null !== document.fullscreenElement && setTimeout(this.onResize, 40)
                })
            }
            dispose() {
                var e;
                this._obj && (yt.detach(this._obj), null != (e = null == (e = this._obj.contentDocument) ? void 0 : e.defaultView)) && e.removeEventListener("resize", this.onResize), void 0 !== this._previousPosition && (this._element.style.position = this._previousPosition)
            }
        }
        Tn.addedToDom = n.M.create();
        class wn {
            static getPoint(e, t, s = g.v.create()) {
                return M.R.scaleAndAdd(s, e.origin, e.dir, t), s[3] = 1, s
            }
            constructor(e, t) {
                this.origin = e || g.v.fromValues(0, 0, 0, 1), this.dir = t || g.v.fromValues(0, 0, -1, 0)
            }
            clone() {
                return new wn(this.origin, this.dir)
            }
        }
        class En {
            static findClosestIntersection(e, t) {
                var s = {
                        sceneNode: null
                    },
                    r = Number.MAX_VALUE;
                for (const i of t) {
                    const t = i.getAABBWorld();
                    t && En.intersectBox(e, t) < r && (s.sceneNode = i)
                }
                return s
            }
            static transformRay(e, t, s = new wn) {
                return s.origin = g.v.transformMat4(g.v.create(), e.origin, t), s.dir = g.v.transformDirection(g.v.create(), e.dir, t), s
            }
            static intersectBox(e, t, s) {
                if (s) {
                    const t = S._.invert(S._.create(), s);
                    t && (e = this.transformRay(e, t))
                }
                var r = e.origin,
                    i = e.dir,
                    a = t.min,
                    n = t.max;
                let o = !0;
                var l = [0, 0, 0];
                let h;
                var c = M.R.create(),
                    d = M.R.create(),
                    u = M.R.create(),
                    p = Number.MAX_VALUE;
                for (let e = 0; e < 3; e++) r[e] < a[e] ? (l[e] = 1, d[e] = a[e], o = !1) : r[e] > n[e] ? (l[e] = 0, d[e] = n[e], o = !1) : l[e] = 2;
                if (o) return M.R.copy(u, r), 0;
                for (let e = 0; e < 3; e++) 2 != l[e] && 0 != i[e] ? c[e] = (d[e] - r[e]) / i[e] : c[e] = -1;
                h = 0;
                for (let e = 1; e < 3; e++) c[h] < c[e] && (h = e);
                if (c[h] < 0) return p;
                for (let e = 0; e < 3; e++)
                    if (h != e) {
                        if (u[e] = r[e] + c[h] * i[e], u[e] < a[e] || u[e] > n[e]) return p
                    } else u[e] = d[e];
                return c[h]
            }
        }
        class Cn {
            static getRayFromScreenCoords(e, t, s, r) {
                e = e || new wn;
                return M.R.copy(e.origin, r.getEye()), Cn.screenCoordsToRayDir(e.dir, t, s, r), e
            }
            static screenCoordsToRayDir(e, t, s, r) {
                t = this.screenCoordsToWorldPos(e, t, s, r), s = M.R.subtract(e, t, r.getEye());
                return M.R.normalize(s, s), s[3] = 0, s
            }
            static screenCoordsToWorldPos(e, t, s, r, i = -1) {
                t = this.normalizeScreenCoords(e, t, s, r), t[2] = i, t[3] = 1, s = g.v.transformMat4(e, t, r.getInverseViewProjectionMatrix());
                return 0 === s[3] ? [0, 0, 0, 1] : (i = s[3], s[0] /= i, s[1] /= i, s[2] /= i, s[3] = 1, s)
            }
            static normalizeScreenCoords(e, t, s, r) {
                return r.viewportWidth && r.viewportHeight && (t = t / r.viewportWidth * 2 - 1, s = -(s / r.viewportHeight * 2 - 1)), e[0] = t, e[1] = s, e
            }
        }
        const yn = {
                x: [1, 0, 0, 0],
                y: [0, 1, 0, 0],
                z: [0, 0, 1, 0]
            },
            An = {
                normal: {
                    x: m.I.vec3_to_hex([.6, .01, .01]),
                    y: m.I.vec3_to_hex([0, .6, .046]),
                    z: m.I.vec3_to_hex([0, .045, .6])
                },
                hover: {
                    x: m.I.vec3_to_hex([1, .01, .01]),
                    y: m.I.vec3_to_hex([0, 1, .046]),
                    z: m.I.vec3_to_hex([0, .045, 1])
                }
            },
            Mn = {
                x: "x",
                y: "y",
                z: "z",
                xy: "z",
                xz: "y",
                yz: "x",
                "": ""
            };
        class Rn {
            constructor(t, e) {
                this.signals = {
                    pointerDown: n.M.create(),
                    pointerMove: n.M.create(),
                    pointerUp: n.M.create()
                }, this._meshes = {
                    x: null,
                    y: null,
                    z: null,
                    xy: null,
                    xz: null,
                    yz: null
                }, this._hoveringAxis = "", this._dragging = !1, this._down = {
                    axis: "",
                    helperAxis: null,
                    axisOffset: 0,
                    worldMatrix: S._.create(),
                    p: null
                }, this.onHoverMove = e => {
                    e = this.findAxisUnderPointer(e);
                    e !== this._hoveringAxis && (this._hoveringAxis = e, Y.inst.invalidate())
                }, this.onPointerDown = (e, t) => {
                    this._down.axis = this.findAxisUnderPointer(e), this._down.axis && this._selectedNode && this._gizmos.camera && (t.halt(), this._gizmos.pointerDetector.signals.move.add(this.onPointerMove, void 0, 2), this._gizmos.pointerDetector.signals.up.add(this.onPointerUp, void 0, 2), t = Cn.getRayFromScreenCoords(new wn, e.localX, e.localY, this._gizmos.camera), S._.copy(this._down.worldMatrix, this._selectedNode.calculateWorldMatrix()), this.signals.pointerDown.dispatch(t, e), Y.inst.invalidate())
                }, this.onPointerMove = (e, t) => {
                    this._down.axis && this._gizmos.camera && (t.halt(), this._dragging = !0, t = Cn.getRayFromScreenCoords(new wn, e.localX, e.localY, this._gizmos.camera), this.signals.pointerMove.dispatch(t, e), Y.inst.invalidate(), Y.inst.invalidateUI())
                }, this.onPointerUp = (e, t) => {
                    t.halt(), this._gizmos.pointerDetector.signals.up.remove(this.onPointerUp), this._down.axis = "", this._dragging = !1, Y.inst.invalidate()
                }, this._gizmos = t, this._asset = e;
                for (const t of this._asset.children) t.name = t.name.split("scale_").join("");
                for (const t of Object.keys(this._meshes)) {
                    const e = this._asset.children.find(e => e.name === t);
                    this._meshes[t] = e
                }
            }
            activate() {
                this._asset.visible = !0, this._gizmos.pointerDetector.signals.hoverMove.add(this.onHoverMove), this._gizmos.pointerDetector.signals.down.add(this.onPointerDown, void 0, 2)
            }
            deactivate() {
                this._gizmos.pointerDetector.signals.hoverMove.remove(this.onHoverMove), this._gizmos.pointerDetector.signals.down.remove(this.onPointerDown), this._gizmos.pointerDetector.signals.move.remove(this.onPointerMove), this._gizmos.pointerDetector.signals.up.remove(this.onPointerUp)
            }
            getRayAxisPlaneIntersection(e) {
                var t = this._down.axis.split("").map(e => this.getWorldAxis(e)),
                    t = (!t[1] && this._down.helperAxis && (t[1] = this._down.helperAxis), M.R.cross(M.R.create(), t[0], t[1])),
                    s = E.x.getTranslation(this._down.worldMatrix),
                    s = class {
                        static intersectPlaneRay(e, t, s) {
                            var r = M.R.dot(t, s.dir);
                            if (1e-4 < Math.abs(r)) {
                                e = M.R.sub(M.R.create(), e, s.origin), s = M.R.dot(e, t) / r;
                                if (1e-5 < s) return s
                            }
                            return -1
                        }
                    }.intersectPlaneRay(s, t, e);
                return 0 < s ? wn.getPoint(e, s) : null
            }
            findAxisUnderPointer(e) {
                var t;
                return this._gizmos.camera ? (e = Cn.getRayFromScreenCoords(new wn, e.localX, e.localY, this._gizmos.camera), t = Object.values(this._meshes).filter(e => !!e), (null == (e = En.findClosestIntersection(e, t).sceneNode) ? void 0 : e.name) || "") : (console.warn("AxisGizmo.findAxisUnderPointer: no camera set"), "")
            }
            calculateAxisOffset(e) {
                var {
                    downPosition: t,
                    worldAxis: s
                } = this.getAxisInfo(this._down.axis), r = [];
                return wr.distanceLineLine(t, s, e.origin, e.dir, r), r[0]
            }
            getAxisInfo(e) {
                var t = this._down.worldMatrix;
                return {
                    downPosition: E.x.getTranslation(t),
                    worldAxis: this.getWorldAxis(e)
                }
            }
            getWorldAxis(e) {
                e = yn[e];
                return "local" === Y.inst.state.transformOrientation ? g.v.transformDirection(g.v.create(), e, this._down.worldMatrix) : e
            }
            render(e, t) {
                this._selectedNode = t;
                var s = this._gizmos.adapter.context;
                s.gl.clear(s.gl.DEPTH_BUFFER_BIT), this._dragging && this._down.axis ? (s.gl.disable(s.gl.CULL_FACE), s.depthTest = !1, s.depthMask = !1, this.drawAxisLines(e)) : this.renderGizmos(t, e)
            }
            drawAxisLines(e) {
                for (const t of this._down.axis.split("")) this.drawAxisLine(t, e)
            }
            drawAxisLine(e, t) {
                var s = this._gizmos.axisColors[e],
                    {
                        worldAxis: e,
                        downPosition: r
                    } = this.getAxisInfo(e),
                    i = M.R.scaleAndAdd(M.R.create(), r, e, -1e3),
                    r = M.R.scaleAndAdd(M.R.create(), r, e, 1e3);
                this._gizmos.engine.drawing.line.draw(i, r, s, t)
            }
            renderGizmos(e, t) {
                this._gizmos.updateTransformation(this._asset, e, t);
                for (const e of Object.keys(this._meshes)) {
                    const t = this._meshes[e],
                        s = this._hoveringAxis === e,
                        r = Mn[e];
                    t.renderNodes[0].material.baseColorFactor = (s ? An.hover : An.normal)[r]
                }
                this._gizmos.adapter.renderNode(this._asset, t)
            }
            get down() {
                return this._down
            }
            set selectedNode(e) {
                this._selectedNode = e
            }
            get selectedNode() {
                return this._selectedNode
            }
        }
        class Sn {
            constructor(e) {
                this._firstMove = !0, this.onPointerDown = e => {
                    var t, s = this._axisGizmo.down;
                    this._firstMove = !0, 1 <= s.axis.length ? (1 === s.axis.length && (t = this._axisGizmo.getWorldAxis(s.axis), s.helperAxis = M.R.cross(M.R.create(), t, e.dir), M.R.normalize(s.helperAxis, s.helperAxis)), s.p = this._axisGizmo.getRayAxisPlaneIntersection(e)) : s.axisOffset = this._axisGizmo.calculateAxisOffset(e)
                }, this.onPointerMove = (e, t) => {
                    this.altDrag(t);
                    var s, r = this._axisGizmo.down;
                    if (1 <= (null == (s = r.axis) ? void 0 : s.length) && r.p) this.movePlane(e);
                    else {
                        const t = this._axisGizmo.calculateAxisOffset(e) - r.axisOffset,
                            {
                                downPosition: s,
                                worldAxis: i
                            } = this._axisGizmo.getAxisInfo(r.axis),
                            a = M.R.scaleAndAdd(M.R.create(), s, i, t);
                        this.updatePosition(a)
                    }
                }, this._gizmos = e;
                var t = null == (t = this._gizmos.assets.scene) ? void 0 : t.children.find(e => "move" === e.name);
                if (!t) throw new Error("Could not find move asset");
                this._axisGizmo = new Rn(e, t), this._axisGizmo.signals.pointerDown.add(this.onPointerDown), this._axisGizmo.signals.pointerMove.add(this.onPointerMove)
            }
            activate() {
                this._axisGizmo.activate()
            }
            deactivate() {
                this._axisGizmo.deactivate()
            }
            render(e, t) {
                this._axisGizmo.render(e, t)
            }
            altDrag(e) {
                var t = e.originalEvent,
                    s = this._axisGizmo.selectedNode;
                if (t.altKey && this._firstMove && s) {
                    const e = s.clone(t.ctrlKey || t.metaKey || t.shiftKey);
                    this._axisGizmo.selectedNode = e;
                    t = s.scene;
                    if (!t) throw new Error("Could not find scene");
                    (s.getParent() || t).add(e), t.signals.select.dispatch(e)
                }
                this._firstMove = !1
            }
            movePlane(e) {
                const t = this._axisGizmo.down,
                    s = this._axisGizmo.getRayAxisPlaneIntersection(e);
                if (s && t.p) {
                    const e = M.R.sub(M.R.create(), s, t.p);
                    if (1 === t.axis.length) {
                        const s = this._axisGizmo.getWorldAxis(t.axis);
                        M.R.scale(e, s, M.R.dot(s, e))
                    }
                    var r = E.x.getTranslation(t.worldMatrix),
                        r = M.R.add(M.R.create(), r, e);
                    this.updatePosition(r)
                }
            }
            updatePosition(e) {
                var t = this._axisGizmo.down,
                    s = this._axisGizmo.selectedNode;
                s && (t = S._.clone(t.worldMatrix), S._.setTranslation(t, e), e = E.x.matrix_world2local(t, s), t = S._.getTranslation(M.R.create(), e), s.transform.translation.copyFrom(t))
            }
        }
        class Nn {
            constructor(e) {
                this.onPointerDown = e => {
                    var t, s = this._axisGizmo.down;
                    1 === s.axis.length && (t = this._axisGizmo.getWorldAxis(s.axis), s.helperAxis = M.R.cross(M.R.create(), t, e.dir), M.R.normalize(s.helperAxis, s.helperAxis)), s.p = this._axisGizmo.getRayAxisPlaneIntersection(e)
                }, this.onPointerMove = (e, t) => {
                    this._axisGizmo.down.p && this.scaleOnPlane(e, t)
                }, this._gizmos = e;
                var t = null == (t = this._gizmos.assets.scene) ? void 0 : t.children.find(e => "scale" === e.name);
                this._axisGizmo = new Rn(e, t), this._axisGizmo.signals.pointerDown.add(this.onPointerDown), this._axisGizmo.signals.pointerMove.add(this.onPointerMove)
            }
            activate() {
                this._axisGizmo.activate()
            }
            deactivate() {
                this._axisGizmo.deactivate()
            }
            render(e, t) {
                this._axisGizmo.render(e, t)
            }
            scaleOnPlane(e, t) {
                var s = this._axisGizmo.down,
                    r = this._axisGizmo.getRayAxisPlaneIntersection(e);
                if (r && s.p && this._axisGizmo.selectedNode) {
                    const e = S._.getScaling(M.R.create(), s.worldMatrix),
                        i = S._.getTranslation(M.R.create(), s.worldMatrix),
                        a = M.R.sub(M.R.create(), r, i),
                        n = M.R.sub(M.R.create(), s.p, i);
                    "global" === Y.inst.state.transformOrientation && (s.axis.includes("x") || (n[0] = a[0]), s.axis.includes("y") || (n[1] = a[1]), s.axis.includes("z") || (n[2] = a[2])); {
                        const e = Te.g.create();
                        S._.decomposeOld(e, [], [], s.worldMatrix), Te.g.invert(e, e), Te.g.normalize(e, e), M.R.transformQuat(a, a, e), M.R.transformQuat(n, n, e)
                    }
                    r = M.R.div(M.R.create(), a, n);
                    if (!t.originalEvent.ctrlKey && !t.originalEvent.metaKey && 1 < s.axis.length) {
                        const e = M.R.magnitude(a) / M.R.magnitude(n);
                        r[0] = e, r[1] = e, r[2] = e
                    }
                    "local" === Y.inst.state.transformOrientation && (s.axis.includes("x") || (r[0] = 1), s.axis.includes("y") || (r[1] = 1), s.axis.includes("z") || (r[2] = 1));
                    t = E.x.matrix_world2local(s.worldMatrix, this._axisGizmo.selectedNode), s = (S._.getScaling(e, t), M.R.mul(M.R.create(), e, r));
                    this._axisGizmo.selectedNode.transform.scale.copyFrom(s)
                }
            }
        }
        class In {
            constructor(e) {
                this.onPointerDown = e => {}, this.onPointerMove = (e, t) => {}, this._gizmos = e;
                e = null == (e = this._gizmos.assets.scene) ? void 0 : e.children.find(e => "rotate" === e.name);
                if (!e) throw new Error("Could not find rotate asset");
                this._asset = e
            }
            activate() {
                this._asset.visible = !0
            }
            deactivate() {}
            render(e, t) {
                var s = this._gizmos.adapter.context;
                s.gl.clear(s.gl.DEPTH_BUFFER_BIT), s.depthTest = !0, s.depthMask = !0, this._gizmos.updateTransformation(this._asset, t, e), this._gizmos.adapter.renderNode(this._asset, e)
            }
            scaleOnPlane(e, t) {}
        }
        class Pn {
            constructor(e, t, s) {
                this.axisColors = {
                    x: 16711680,
                    y: 65280,
                    z: 255
                }, this._tools = new Map, this._navigationMode = "", this._engine = e, this._pointerDetector = t, this.assets = s
            }
            render(e, t) {
                this._camera = e;
                var s, r = t && this._navigationMode ? this.getGizmo(this._navigationMode) : void 0;
                this._activeTool !== r && (this.assets.hideChildren(), null != r && r.activate(), null != (s = this._activeTool) && s.deactivate(), this._activeTool = r), t && null != r && r.render(e, t)
            }
            updateTransformation(e, t, s) {
                const r = t.calculateWorldMatrix(),
                    i = S._.getTranslation([], r);
                if (e.transform.translation.copyFrom(i), "local" === Y.inst.state.transformOrientation) {
                    const t = Te.g.create();
                    S._.decomposeOld(t, [], [], r), e.transform.rotation.copyFrom(t)
                } else e.transform.rotation.set(0, 0, 0, 1);
                if (s instanceof ye.c) {
                    const t = M.R.sub([], i, s.getEye()),
                        r = s.calculateWorldMatrix(),
                        a = [r[8], r[9], r[10]],
                        n = Math.abs(M.R.dot(a, t)),
                        o = 100 / s.viewportWidth * 2 * n * Math.tan(s.fovY / 2);
                    e.transform.scale.set(o, o, o)
                }
            }
            set navigationMode(e) {
                this._navigationMode !== e && (this._navigationMode = e)
            }
            get navigationMode() {
                return this._navigationMode
            }
            getGizmo(e) {
                let t = this._tools.get(e);
                if (!t) {
                    switch (e) {
                        case "move":
                            t = new Sn(this);
                            break;
                        case "scale":
                            t = new Nn(this);
                            break;
                        case "rotate":
                            t = new In(this);
                            break;
                        case "":
                            t = void 0
                    }
                    t && this._tools.set(e, t)
                }
                return t
            }
            get engine() {
                return this._engine
            }
            get adapter() {
                return this._engine.adapter
            }
            get pointerDetector() {
                return this._pointerDetector
            }
            get camera() {
                return this._camera
            }
        }
        class Fn {
            constructor(e, t, s) {
                this._engine = e, this._pointerDetector = t, this._renderCamera = new ye.c({
                    near: .01,
                    far: 1e5,
                    fovY: 30 / 180 * Math.PI
                }), this._renderCamera.lookAt([0, 0, 0], [0, 0, 2], [0, 1, 0]), s.loadPromise.then(e => {
                    this._arrows = e.children.find(e => "orientation" === e.name), this._engine.signals.change.dispatch()
                })
            }
            render(e) {
                if (this._arrows && (this._sceneCamera = e, this._engine.adapter instanceof Js)) {
                    const e = this._engine.adapter,
                        a = e.context;
                    a.gl.clear(a.gl.DEPTH_BUFFER_BIT), a.gl.disable(a.gl.CULL_FACE), a.depthTest = !1, a.depthMask = !1;
                    var [t, s] = e.drawingBufferSize, r = [10 * window.devicePixelRatio, 50 * window.devicePixelRatio], i = [80 * window.devicePixelRatio, 80 * window.devicePixelRatio], t = (e.setViewport([t - i[1] - r[0], s - i[1] - r[1], i[0], i[1]]), Te.g.create());
                    S._.decomposeOld(t, [], [], this._sceneCamera.getViewMatrix()), Te.g.normalize(t, t), this._arrows.transform.rotation.copyFrom(t), e.renderNode(this._arrows, this._renderCamera)
                }
            }
        }
        class Ln {
            constructor() {
                this.scene = null, this.loadPromise = new Promise(async e => {
                    this.loadGeometries(e)
                })
            }
            async loadGeometries(e) {
                var t = new tt.glTFLoader;
                await t.load("assets/3d/gizmo/gizmos.glb"), this.scene = t.scene, this.hideChildren(), this.setWorldMatrixAutoUpdate(this.scene), e(t.scene)
            }
            hideChildren() {
                var e;
                if (null != (e = this.scene) && e.children)
                    for (const e of this.scene.children) e.visible = !1
            }
            setWorldMatrixAutoUpdate(e) {
                e.worldMatrixAutoUpdate = !1;
                for (const t of e.children) this.setWorldMatrixAutoUpdate(t)
            }
        }
        class Dn {
            constructor(e, t) {
                this._engine = e, this._pointerDetector = t, this.assets = new Ln, this._transformGizmos = new Pn(e, t, this.assets), this._orientation = new Fn(e, t, this.assets)
            }
            render(e, t) {
                this._transformGizmos.render(e, t), this._orientation.render(e)
            }
            set navigationMode(e) {
                this._transformGizmos.navigationMode = e
            }
        }
        class On {
            constructor(e, t) {
                this.initArrow = e => {
                    e = e.children.find(e => "orientation" === e.name).children.find(e => "orientation_x" === e.name), this._arrow = e.clone(!0), this._arrow.transform.scale.set(.5, .2, .5), e = this._arrow.renderNodes[0].material;
                    e.baseColorFactor = 12829635, e.emissiveFactor = 0
                }, this._engine = e, (this._assets = t).loadPromise.then(this.initArrow)
            }
            renderDirectionArrow(e, t, s) {
                var r, i;
                this._arrow && (r = this._engine.adapter.getMeshRenderer(this._arrow.renderNodes[0]), e = e.node, i = E.x.getTranslation(e.calculateWorldMatrix()), this._arrow.transform.translation.copyFrom(i), this._arrow.transform.translation.y -= t.transform.scale.y / 2, i = Te.g.create(), Te.g.rotateX(i, i, -Math.PI / 2), Te.g.multiply(i, e.transform.rotation.vec, i), this._arrow.transform.rotation.copyFrom(i), e = 3 * t.transform.scale.x, this._arrow.transform.scale.set(e, .5 * e, e), r.render(s))
            }
        }
        class Bn extends On {
            constructor(e, t) {
                super(e, t)
            }
            render(e, t, s) {}
        }
        class Un extends On {
            constructor(e, t) {
                super(e, t)
            }
            render(e, t, s) {
                this.renderDirectionArrow(e, t, s)
            }
        }
        class kn extends On {
            constructor(e, t) {
                super(e, t)
            }
            render(e, t, s) {
                this.renderDirectionArrow(e, t, s), this.renderCones(e, t, s)
            }
            renderCones(e, t, s) {
                var r;
                null != (r = this._assets.scene) && r.children.find(e => "cone" === e.name)
            }
        }
        const zn = {
            point: "assets/textures/widgets/light_point.png",
            directional: "assets/textures/widgets/light_point.png",
            spot: "assets/textures/widgets/light_spot.svg"
        };
        class Vn {
            constructor(e, t) {
                this._textures = new Map, this.onTextureLoaded = () => {
                    this._engine.signals.change.dispatch()
                }, this._engine = e, this._gizmoRenderers = {
                    point: new Bn(e, t),
                    directional: new Un(e, t),
                    spot: new kn(e, t)
                }
            }
            render(e, s, t, r) {
                var i = Vn.parseLights(e, s).sort((e, t) => {
                    e = E.x.calculateViewZ(e, s);
                    return E.x.calculateViewZ(t, s) - e
                });
                for (const e of i) this.renderLight(e, e.light === t, s, r)
            }
            static parseLights(e, t, s = []) {
                e.light && s.push(e);
                for (const r of e.children) this.parseLights(r, t, s);
                return s
            }
            renderLight(e, t, s, r) {
                var i, a, n, o, l, h, c;
                e.light && (h = E.x.getTranslation(e.calculateWorldMatrix()), i = E.x.getTranslation(s.calculateWorldMatrix()), a = this.getTexture(e.light), (l = (o = (n = this.getSprite()).renderNodes[0]).material).baseColorTextureInfo.texture = a, l.baseColorAlpha = t ? 1 : .5, n.transform.translation.copyFrom(h), l = n, l = (h = s) instanceof ye.c ? (l = S._.getTranslation([], l.calculateWorldMatrix()), l = M.R.sub([], l, h.getEye()), c = [(c = h.calculateWorldMatrix())[8], c[9], c[10]], c = Math.abs(M.R.dot(c, l)), 50 / h.viewportWidth * 2 * c * Math.tan(h.fovY / 2)) : 1, c = a.image.width / a.image.height, n.transform.scale.set(l, l / c, 1), n.lookAt(i), r ? r.renderNode(o, s, e.light) : (t && this.renderGizmo(e.light, n, s), this._engine.adapter.getMeshRenderer(o).render(s)))
            }
            renderGizmo(e, t, s) {
                this._gizmoRenderers[e.type].render(e, t, s)
            }
            getTexture(e) {
                var t = zn[e.type],
                    e = this._textures.get(t);
                if (e) return e; {
                    const e = X.x.from({
                        source: t,
                        onLoad: this.onTextureLoaded,
                        flipY: !0,
                        generateMipmap: !0,
                        magFilter: _.g.LINEAR,
                        minFilter: _.g.LINEAR_MIPMAP_LINEAR
                    });
                    return this._textures.set(t, e), e
                }
            }
            getSprite() {
                return this._sprite || (this._sprite = new q.B({
                    renderNodes: [new T.j({
                        geometry: this._engine.geometryPool.unitQuad,
                        material: new ve.z({
                            alphaMode: _e.mM.BLEND,
                            side: fe.N.DOUBLE
                        })
                    })]
                })), this._sprite
            }
        }
        class Gn {
            constructor(e) {
                this.signals = {
                    select: n.M.create()
                }, this._selected = null, this._needsResize = !1, this._invalidated = !0, this.onRendererReady = () => {
                    this.invalidate()
                }, this.onClick = e => {
                    if (this._picker = this._picker || this._engine.adapter.createPixelPicker(), this._picker) {
                        var t = this._engine.drawingBufferSize,
                            s = Tt.getLocalCoordsInBuffer(e.pointerData, this.canvas, t);
                        if (this._scene) {
                            const e = this._picker.pick(s, t, this._scene, this._camera, this.renderPickableWidgets);
                            this.signals.select.dispatch(e)
                        }
                    }
                }, this.renderPickableWidgets = e => {
                    this._scene && this._lightGizmos.render(this._scene, this._camera, this._selected, e)
                }, this.onSceneChange = () => {
                    this.invalidate()
                }, this.onResize = () => {
                    this._needsResize = !0
                }, this._engine = e, this._engine.signals.change.add(this.onSceneChange), this._engine.signals.resize.add(this.onResize);
                e = this.canvas;
                if (this._camera = new ye.c({
                        near: .01,
                        far: 1e4
                    }), this._camera.lookAt([0, 0, 0], [0, 0, 10]), !e.parentElement) throw new Error("canvas must have a parent element");
                this._resizeDetector = new Tn(e.parentElement), this._resizeDetector.resize.add(this.onResize, this), this.resizeCanvas(), this._controller = new xn({
                    camera: this._camera,
                    element: e,
                    distance: {
                        easing: 1
                    },
                    rotation: {
                        easing: 1,
                        speed: .01
                    },
                    zoom: {
                        press: 1.2,
                        mouseWheel: 1.1
                    }
                }), this._renderer = this._engine.adapter.createRenderer(), this._renderer.onReady().then(this.onRendererReady), this._editorWidget = new Dn(this._engine, this._controller.gestures.pointerDetector), this._lightGizmos = new Vn(this._engine, this._editorWidget.assets), this._updater = new nt.F, this._updater.init(this.onFrame, this)
            }
            set scene(e) {
                this._scene !== e && (this._scene && this._scene.signals.change.remove(this.onSceneChange), this._scene = e, this._scene && this._scene.signals.change.add(this.onSceneChange), this.invalidate())
            }
            set camera(e) {
                this._camera !== e && (this._camera = e, this._controller.camera = this._camera, this.onResize())
            }
            set selected(e) {
                this._selected !== e && (this._selected = e, this.invalidate())
            }
            set navigationMode(e) {
                this._editorWidget.navigationMode = e
            }
            enablePicking() {
                this._controller.gestures.signals.click.add(this.onClick)
            }
            invalidate() {
                this._invalidated = !0
            }
            resizeCanvas() {
                var e = this.canvas,
                    t = this._engine.resolutionScale,
                    s = e.clientWidth,
                    r = e.clientHeight,
                    i = Math.floor(s * window.devicePixelRatio * t),
                    t = Math.floor(r * window.devicePixelRatio * t);
                e.width === i && e.height === t || (e.width = i, e.height = t), this._camera.setViewport(s, r)
            }
            onFrame() {
                let e = this._invalidated;
                this._controller.update() && (e = !0, this._scene) && this._scene.signals.change.dispatch(), this._needsResize && (this.resizeCanvas(), this._needsResize = !1, e = !0), e && (this._invalidated = !1, this.renderScene(), this._engine.debugTools.render(this._camera), this.renderGrid(), this.renderLightGizmos(), this.renderSelection(), this.renderEditorWidgets())
            }
            renderScene() {
                this._renderer.render(this._scene, this._camera)
            }
            renderSelection() {
                var e, t;
                this._selected && (this._outlineRenderer || (this._outlineRenderer = this._engine.adapter.createOutlineRenderer()), t = {
                    color: this._engine.debugTools.selectionColor,
                    thickness: this._engine.debugTools.selectionThickness
                }, null != (e = this._outlineRenderer)) && e.render([this._selected], t, this._camera)
            }
            renderGrid() {
                var e;
                this._engine.debugTools.grid && (this._gridRenderer || (this._gridRenderer = this._engine.adapter.createGridRenderer()), null != (e = this._gridRenderer)) && e.render(this._camera)
            }
            renderEditorWidgets() {
                var e = this._selected instanceof T.j || this._selected instanceof Ae.a ? this._selected.node : this._selected || null;
                e instanceof K.x || this._editorWidget.render(this._camera, e)
            }
            renderLightGizmos() {
                this._scene && this._lightGizmos.render(this._scene, this._camera, this._selected)
            }
            get canvas() {
                return this._engine.adapter.canvas
            }
            get resizeDetector() {
                return this._resizeDetector
            }
            get controller() {
                return this._controller
            }
        }
        class Wn extends u.PureComponent {
            constructor(e) {
                super(e), this.onDivMounted = e => {
                    var t = e,
                        s = this.props.engine.canvas;
                    null != t && t.firstChild ? t.insertBefore(s, t.firstChild) : null != t && t.appendChild(s), this.createRenderView(), "function" == typeof this.props.domRef && this.props.domRef(e)
                }
            }
            createRenderView() {
                this._renderView || (this._renderView = new Gn(this.props.engine), this.updateRenderView(), this.props.onNodeSelect && (this._renderView.enablePicking(), this._renderView.signals.select.add(this.onNodeSelected, this)), this.props.onResize && this._renderView.resizeDetector.resize.add(this.props.onResize))
            }
            get renderView() {
                return this._renderView
            }
            onNodeSelected(e) {
                var t, s;
                null != (s = (t = this.props).onNodeSelect) && s.call(t, e)
            }
            updateRenderView() {
                this._renderView && (this._renderView.camera = this.props.camera || this.props.scene.camera || this._renderView.camera, this._renderView.scene = this.props.scene, this._renderView.selected = this.props.selected, this._renderView.navigationMode = this.props.navigationMode)
            }
            render() {
                return this.updateRenderView(), u.createElement("div", {
                    className: this.props.className,
                    ref: this.onDivMounted
                }, this.props.children)
            }
        }
        class Hn extends u.Component {
            constructor(e) {
                super(e), this.onDropFiles = async e => {
                    var t, s = null == (t = e.dataTransfer) ? void 0 : t.items;
                    if (s) {
                        const t = await (new Lt).load(s);
                        this._app.project.loadFiles(t, e.shiftKey)
                    }
                }, this._app = e.app
            }
            render() {
                return u.createElement(Ft, {
                    onDragOver: e => !0,
                    onDrop: this.onDropFiles,
                    onDroppingChange: this.props.onDroppingChange
                }, this.props.children)
            }
        }
        class Yn extends u.Component {
            constructor(e) {
                super(e)
            }
            render() {
                return u.createElement("div", {
                    className: "AnimationSpeed"
                }, u.createElement(G, {
                    label: "Speed",
                    value: 100 * this.props.value,
                    onChange: e => this.props.onChange(e / 100),
                    postfix: "%",
                    decimals: 0,
                    step: 1
                }))
            }
        }
        class jn extends u.Component {
            constructor(e) {
                super(e), this._seekBar = u.createRef(), this._wasPlayingBeforeDragStart = !1, this.onAnimationChange = () => {
                    this.forceUpdate()
                }, this.onSeekDown = e => {
                    var t = this.props["animation"];
                    t && (e.originalEvent.stopImmediatePropagation(), this._wasPlayingBeforeDragStart = t.isPlaying(), t.pause(), this.seekTo(e))
                }, this.onSeekMove = e => {
                    this.seekTo(e)
                }, this.onSeekUp = e => {
                    this.props.animation && this._wasPlayingBeforeDragStart && this.props.animation.play()
                }, this.onToggleClick = e => {
                    var t = this.props["animation"];
                    t && t.togglePlay()
                }, this.onCloseClick = e => {
                    this.props.onClose()
                }, this.listenAnimation(e.animation)
            }
            listenAnimation(e) {
                e !== this._previousAnimation && (this._previousAnimation && this._previousAnimation.signals.change.remove(this.onAnimationChange), e && e.signals.change.add(this.onAnimationChange), this._previousAnimation = e)
            }
            seekTo(e) {
                var t = this.props["animation"];
                t && (e = this.getRatio(e) * t.totalTime, t.seekTo(e))
            }
            getRatio(e) {
                return f.M.clamp(e.localX, 0, this.barWidth) / this.barWidth
            }
            get barWidth() {
                var e = this._seekBar.current;
                let t = 0;
                return t = e ? e.offsetWidth : t
            }
            render() {
                var e;
                const t = this.props["animation"],
                    s = this.barWidth;
                let r = 0,
                    i = !1;
                this.listenAnimation(t), t && (r = t.currentTime / t.totalTime, i = t.isPlaying());
                var a = s * r;
                return u.createElement("div", {
                    className: "AnimationPanel"
                }, (1 < (null == t ? void 0 : t.animations.length) || (null == (e = t.currentAnimation) ? void 0 : e.name)) && u.createElement("div", {
                    className: "title"
                }, 1 < t.animations.length ? u.createElement(F, {
                    options: t.animations,
                    selected: t.currentAnimation,
                    render: e => null == e ? void 0 : e.name,
                    onChange: e => {
                        e && (t.currentAnimation = e, this.forceUpdate())
                    }
                }) : null == (e = t.currentAnimation) ? void 0 : e.name), u.createElement("div", {
                    className: "bar"
                }, u.createElement("div", {
                    className: "popup-close",
                    onClick: this.onCloseClick
                }), u.createElement("div", {
                    className: h("toggleButton", {
                        playing: i,
                        disabled: !t
                    }),
                    onClick: this.onToggleClick
                }), u.createElement(Yn, {
                    value: t.speed,
                    onChange: e => t.speed = e
                }), u.createElement("div", {
                    className: "seekBar",
                    ref: this._seekBar
                }, u.createElement("div", {
                    className: "total_bar"
                }), u.createElement("div", {
                    className: "current_bar",
                    style: {
                        transform: `scaleX(${r})`,
                        WebkitTransform: `scaleX(${r})`
                    }
                }), u.createElement(wt, {
                    onDown: this.onSeekDown,
                    onMove: this.onSeekMove,
                    onUp: this.onSeekUp,
                    ignoreRightButton: !0
                }, u.createElement("div", {
                    className: "hit_bar"
                })), u.createElement("div", {
                    className: "seek_button",
                    style: {
                        transform: `translateX(${a}px)`,
                        WebkitTransform: `translateX(${a}px)`
                    }
                })), u.createElement("span", {
                    className: "timeDisplay"
                }, u.createElement(oi, {
                    value: t.currentTime,
                    decimals: 2
                }), " / ", u.createElement(oi, {
                    value: t.totalTime,
                    decimals: 2
                }))))
            }
        }
        class Kn {
            static sortByModCount(e, t) {
                return (t._modCount || 0) - (e._modCount || 0)
            }
            constructor(e) {
                this.signals = {
                    activated: n.M.create()
                }, this._keyboardListener = e || P.getInstance(), this._keys = {}, this.enable()
            }
            enable() {
                this._keyboardListener.signals.down.add(this.onKeyDown, this)
            }
            disable() {
                this._keyboardListener.signals.down.remove(this.onKeyDown, this)
            }
            add(e) {
                if (!e.keyCode) {
                    if (!e.key || 1 !== e.key.length) return void console.warn("Invalid config.key");
                    e.keyCode = e.key[0].toUpperCase().charCodeAt(0)
                }
                e._modCount = 0, e.ctrl && e._modCount++, e.shift && e._modCount++, e.alt && e._modCount++, e.meta && e._modCount++, e.enabled = !1 !== e.enabled, this._keys[e.keyCode] = this._keys[e.keyCode] || [], this._keys[e.keyCode].push(e)
            }
            onKeyDown(t) {
                var e, s = this._keys[t.keyCode],
                    r = [];
                if (s)
                    for (let e = 0; e < s.length; ++e) {
                        const i = s[e];
                        !i.enabled || void 0 !== i.ctrl && i.ctrl !== t.ctrlKey || void 0 !== i.shift && i.shift !== t.shiftKey || void 0 !== i.meta && i.meta !== t.metaKey || void 0 !== i.alt && i.alt !== t.altKey || r.push(i)
                    }
                r.sort(Kn.sortByModCount);
                const i = r[0];
                i && (t.preventDefault(), t.stopImmediatePropagation(), null != (e = i.handler) && e.call(i, i, t), this.signals.activated.dispatch(i))
            }
            get keys() {
                return this._keys
            }
        }
        class qn {
            constructor(e) {
                this._app = e, this._keyboardListener = P.getInstance(), this._shortcuts = new Kn(this._keyboardListener)
            }
            get shortcuts() {
                return this._shortcuts
            }
            get keyboardListener() {
                return this._keyboardListener
            }
        }
        class $n {
            constructor() {
                var e, t = ee.U.getQueryParams();
                this.ui = t.ui, this.ibl_intensity = null != (e = t.ibl_intensity) ? e : 1, this.background_color = m.I.string2number(null != (e = t.background_color) ? e : "181818"), this.url = null != (e = t.url) ? e : ""
            }
        }
        class Xn {
            constructor() {}
            static debounce(e) {
                this._handlers.add(e), this._timeoutId || (this._timeoutId = requestAnimationFrame(this.onNextFrame))
            }
        }(at = Xn)._timeoutId = 0, Xn._handlers = new Set, Xn.onNextFrame = () => {
            at._timeoutId = 0, at._handlers.forEach(e => e())
        };
        class Zn extends u.Component {
            constructor(e) {
                super(e), this._options = [{
                    id: "",
                    title: "Select",
                    iconUrl: "assets/ui/toolbar/select.svg"
                }, {
                    id: "move",
                    title: "Move",
                    iconUrl: "assets/ui/toolbar/move.svg"
                }, {
                    id: "rotate",
                    title: "Rotate",
                    iconUrl: "assets/ui/toolbar/rotate.svg"
                }, {
                    id: "scale",
                    title: "Scale",
                    iconUrl: "assets/ui/toolbar/scale.svg"
                }], this.onChangeNavigationMode = e => {
                    this.props.app.setNavigationMode(e)
                }
            }
            render() {
                var e = this.props.app.state["navigationMode"];
                return u.createElement("div", {
                    className: "ToolsPanel"
                }, u.createElement(vr, {
                    options: this._options,
                    selected: e,
                    onChange: this.onChangeNavigationMode
                }))
            }
        }
        class Jn extends u.Component {
            constructor(e) {
                super(e), this._options = [{
                    id: "local",
                    label: "Local"
                }, {
                    id: "global",
                    label: "Global"
                }], this.onChange = e => {
                    this.props.onChange(e.id)
                }
            }
            render() {
                const t = this.props["value"];
                return u.createElement(F, {
                    options: this._options,
                    render: e => e.label,
                    selected: this._options.find(e => e.id === t),
                    onChange: this.onChange
                })
            }
        }
        class Qn extends u.PureComponent {
            constructor() {
                super(...arguments), this.onWireFrameChange = e => {
                    this.props.app.commands.execute(Li.ID), this.forceUpdate()
                }, this.onGridChange = e => {
                    this.props.app.setGrid(e), this.forceUpdate()
                }, this.onTransformOrientationChange = e => {
                    this.props.app.setState({
                        transformOrientation: e
                    }), this.props.app.invalidate(), this.forceUpdate()
                }
            }
            render() {
                return u.createElement("div", {
                    className: "ViewOptions"
                }, u.createElement("div", {
                    className: "options"
                }, u.createElement(k, {
                    label: "Floor"
                }, u.createElement(U, {
                    value: this.props.app.engine.debugTools.grid,
                    onChange: this.onGridChange
                })), u.createElement(k, {
                    label: "Wireframe"
                }, u.createElement(U, {
                    value: this.props.app.state.wireframe,
                    onChange: this.onWireFrameChange
                }))), u.createElement(Jn, {
                    value: this.props.app.state.transformOrientation,
                    onChange: this.onTransformOrientationChange
                }))
            }
        }
        class Y extends u.PureComponent {
            constructor(e) {
                super(e), this.selection = new Mi(this), this._params = new $n, this._popups = u.createRef(), this._canvasViewRef = u.createRef(), this._contextOptions = [{
                    label: "Focus",
                    onSelect: () => {
                        this._commands.execute(Ka.ID)
                    }
                }, {
                    type: "separator"
                }, {
                    label: "Hide",
                    onSelect: () => {
                        this._commands.execute(cn.ID)
                    }
                }, {
                    label: "Delete",
                    onSelect: () => {
                        this._commands.execute(Ua.ID)
                    }
                }, {
                    type: "separator"
                }, {
                    label: "Hide others",
                    onSelect: () => {
                        this._commands.execute(cn.ID, {
                            invert: !0
                        })
                    }
                }, {
                    label: "Delete others",
                    onSelect: () => {
                        this._commands.execute(Ua.ID, {
                            invert: !0
                        })
                    }
                }, {
                    type: "separator"
                }, {
                    label: "Break apart",
                    onSelect: () => {
                        var e = Ki.separate(this.selection.getTarget(), this.engine, !0);
                        this.setState({
                            selected: e[0] || null
                        })
                    }
                }], this.onPaste = e => {
                    var t;
                }, this.onSelectNode = e => {
                    this.setState({
                        selected: e
                    })
                }, this.onCameraChange = e => {
                    this.setState({
                        camera: e
                    })
                }, this.onSceneChange = e => {
                    this.engine.clear(), this.forgetScene(this.state.scene), this.setState({
                        scene: e
                    }), this.watchScene(e)
                }, this.onSceneTreeChange = () => {
                    this.invalidateUI()
                }, this.onResize = () => {
                    this.invalidateUI()
                }, this.updateUI = () => {
                    this.forceUpdate()
                }, this.onSampleModelSelected = e => {
                    this._project.load(e)
                }, this.onCloseWelcomeView = () => {
                    this.setState({
                        showWelcome: !1
                    })
                }, this.onAnimationChange = () => {
                    var e;
                    null != (e = this.state.scene) && e.signals.change.dispatch()
                }, this.setGrid = e => {
                    this._engine.debugTools.grid = e, this.invalidate(), this.updateUI()
                }, this.onDroppingChange = e => {
                    this.setState({
                        dropping: e
                    })
                }, Y.inst = this, w.f.defaultConfig.keepData = !0, this._engine = new rr, this._keyboard = new qn(this), this._commands = new dn(this);
                e = new ye.c({
                    near: .01,
                    far: 1e5
                });
                e.lookAt([0, 0, 0], [-5, 7, 10]), this._project = new _t(this.params), this.watchScene(this._project.scene), this.state = {
                    scene: this._project.scene,
                    scenes: [this._project.scene],
                    animation: void 0,
                    camera: e,
                    selected: null,
                    showWelcome: !0,
                    showAnimation: !0,
                    loading: !1,
                    dropping: !1,
                    wireframe: !1,
                    viewNormals: !1,
                    navigationMode: "",
                    transformOrientation: "local"
                }, this._project.signals.change.add(this.onProjectChange, this), this._project.signals.loadStarted.add(this.onLoadStarted, this), this._project.signals.loadCompleted.add(this.onLoadCompleted, this), document.body.addEventListener("paste", this.onPaste), this._params.url && this._project.load(this._params.url)
            }
            onLoadStarted() {
                this._engine.clear(), this.setState({
                    loading: !0,
                    showWelcome: !1
                })
            }
            onLoadCompleted(e) {
                for (this.setState({
                        loading: !1
                    }); 1 === (null == e ? void 0 : e.children.length);) e = e.children[0];
                e && (this.onSelectNode(e), this._commands.execute(Ka.ID))
            }
            forgetScene(e) {
                e && (e.signals.tree.remove(this.onSceneTreeChange), e.signals.select.remove(this.onSelectNode))
            }
            watchScene(e) {
                e && (e.signals.tree.add(this.onSceneTreeChange), e.signals.select.add(this.onSelectNode))
            }
            invalidate() {
                var e;
                null != (e = this.state.scene) && e.signals.change.dispatch()
            }
            invalidateUI() {
                Xn.debounce(this.updateUI)
            }
            onProjectChange(e) {
                var t, s = e.scene.camera || this.state.camera;
                null != (t = this.state.animation) && t.signals.change.remove(this.onAnimationChange), this.setState({
                    scenes: e.scenes,
                    animation: e.animationEngine,
                    camera: s,
                    selected: null,
                    showWelcome: !1,
                    loading: !1
                }), this.onSceneChange(e.scene), null != (t = e.animationEngine) && t.signals.change.add(this.onAnimationChange)
            }
            setNavigationMode(e) {
                this.setState({
                    navigationMode: e
                }), this.invalidate()
            }
            get project() {
                return this._project
            }
            get commands() {
                return this._commands
            }
            get shortcuts() {
                return this._keyboard.shortcuts
            }
            get popups() {
                return this._popups.current
            }
            get keyboardListener() {
                return this._keyboard.keyboardListener
            }
            get engine() {
                return this._engine
            }
            get params() {
                return this._params
            }
            get canvasView() {
                return this._canvasViewRef.current
            }
            renderCanvas() {
				
                return u.createElement(Wn, {
                    ref: this._canvasViewRef,
                    scene: this.state.scene,
                    camera: this.state.camera,
                    engine: this._engine,
                    onResize: this.onResize,
                    onNodeSelect: this.onSelectNode,
                    selected: this.state.selected,
                    navigationMode: this.state.navigationMode,
                    className: "CanvasView"
                }, u.createElement(u.Fragment, null, u.createElement("div", {
                    className: h({
                        preloader: !0,
                        loading: this.state.loading
                    })
                }, u.createElement("div", {
                    className: "spinner"
                })), u.createElement(Zn, {
                    app: this
                }), u.createElement(Qn, {
                    app: this
                })))
            }
            
            
            render() {
                var e = "none" !== this._params.ui;

                let app = u.createElement(Hn, {
                    app: this,
                    onDroppingChange: this.onDroppingChange
                }, u.createElement("div", {
                    className: h("app", {
                        dropping: this.state.dropping
                    })
                }, e ? u.createElement(u.Fragment, null, u.createElement($i, {
                    app: this
                }), u.createElement("div", {
                    className: "hbox flex_1",
                    style: {
                        overflowY: "hidden"
                    }
                }, u.createElement(_n, {
                    scene: this.state.scene,
                    scenes: this.state.scenes,
                    selected: this.state.selected,
                    onSelect: this.onSelectNode,
                    camera: this.state.camera,
                    onCameraChange: this.onCameraChange,
                    onSceneChange: this.onSceneChange
                }), u.createElement(kr, {
                    options: this._contextOptions
                }, this.renderCanvas()), u.createElement(Ri, {
                    app: this,
                    node: this.state.selected,
                    engine: this._engine,
                    scene: this.state.scene
                })), !this.state.dropping && this.state.showAnimation && this.state.animation && u.createElement(jn, {
                    animation: this.state.animation,
                    onClose: () => this.setState({
                        showAnimation: !1
                    })
                }), u.createElement(Ur, {
                    ref: this._popups,
                    keyboardListener: this._keyboard.keyboardListener
                })) : this.renderCanvas()))
                return app;
            }
            
        }(0, te.s)(document.getElementById("appHolder")).render(u.createElement(Y, null))
    }
})();
